# 타입스크립트

- 자바스크립트는 동적 타입 언어
- 따라서 변수의 타입은 런타임에 의해서 결정

- 반대로 정적 타입의 언어도 존재
- 정적 타입 언어의 변수의 타입 -> 컴파일 타임에 결정
  - 예로 `자바`, `C++`, `PHP`

> 동적 타입, 정적 타입

    동적 : 변수의 타입 -> 런타임 시점
    정적 : 변수의 타입 -> 컴파일 타임 시점

## 타입스크립트란

- 타입스크립트는 자바스크립트의 모든 기능을 포함하면서 정적 타입을 지원하는 언어
- 정적 타입과 동적 타입을 비교해보면서 왜 JS에 정적 타입이 필요한지 학습
- JS에 정적 타입을 추가해 주는 언어와 도구는 다양
  - `Elm`, `ReasonML`, `PureScript`, `Flow`

### 동적 타입 언어와 정적 타입 언어

- 동적 타입 언어와 정적 타입 언어의 차이

| 동적 타입 언어                                    | 정적 타입 언어                                      |
| ------------------------------------------------- | --------------------------------------------------- |
| 타입에 대한 고민을 하지 않아도 되서 러닝커브 down | 변수를 선언할 때 마다 타입을 고민 -> 러닝 커브 up   |
| 코드의 양이 적을 때 생산성이 좋음                 | 콛의 양이 많을 때 동적 타입 언어에 비해 생성성 좋음 |
| 타입 오류가 런타임시 발견                         | 타임 오류가 컴파일 시 발견                          |

- 동적 타입 언어와 정적 타입 언어는 장단점이 서로 달라 프로젝트의 성격에 따라 선택
- 작은 규모의 프로젝트 -> 동적 타입
- 큰 규모 프로젝트 -> 정적 타입

#### 정적 타입 언어가 생산성이 높은 이유

- 정적 타입 언어의 코드는 타입으로 서로 연결
- 연관된 코드 간의 이동이 쉽고 변수명, 함수명 변경하는 리팩터링이 쉬움
- `import` 하지 않고 코드를 작성해도 단축키 한 번이면 `IDE`가 필요한 `import`코드 삽입
- 함수를 입력 하면 `매개변수` 종류, `반환값` 타입을 확인 가능

> 결론 : 타입을 정할 때는 귀찮지만 결론적으로 코딩이 편해짐

### 타입스크립트의 장점

- MS(마이크로소프트) 에서 개발하고 있으며 업데이트 버전이 꾸준히 나오는 중
- `JS`에 기능 추가 -> `TS`에도 빠르게 기능추가

- 타입스크립트는 다른 경쟁 언어에 비해 큰 생테계를 가지고 있음
- 유명한 라이브러리 -> 타입스크립트 타입 정의 파일을 가지고 있음

  - 타입 정의 라이브러리로 가지고 있거나, `DefinitelyTyped`라는 깃허브 장소에 포함

- `vscode` 또한 MS에서 제작 -> `Ts`에 대한 지원이 잘됨
- 타입스크립트 이용해서 자바스크립트 파일도 타입 검사
  - `레거시(legacy)` 프로젝트에서 유용

### 실습을 위한 준비

- 타입스크립트 홈페이지에서 코드 실행

```ts
let v1 = 123; // -1-
v1 = '123'; // 오류
```

1. v1의 타입을 명시적으로 입력하지 않아도 `Ts` 숫자 타입으로 인식
   - 자동 타입 인식 -> `type interface` 타입 추론
   - 타입 추론 덕분에 기존의 `Js` 코드를 크게 변경하지 않고 `Ts` 비교적 쉽게 적용 가능

#### Ts에서 타입 선언의 방법

```ts
let v1: number | string = 123; // -1-
v1 = 'abc'; // -2-
```

1. 변수 v1을 숫자나 문자열인 타입으로 정의
   - 변수 이름은 이름 오른쪽에 콜론(`:`)과 함께 타입을 선언가능
2. 변수 v1은 문자열도 포함하는 타입으로 타입 에러가 발생하지 않음

## Ts의 여러 가지 타입

- 타입 스크립트로 정의할 수 있는 여러가지 타입 학습

### Ts의 다양한 타입

- Ts에서 사용되는 기본 타입 학습

```ts
const size: number = 123;
const isBig: boolean = size >= 100;
const msg: string = isBig ? '크다' : '작다';

// -1-
const values: number[] = [1, 2, 3];
const values2: Array<number> = [1, 2, 3];
// -1-

values.push('a'); // 타입 에러 -2-

const data: [string, number] = [msg, size]; // -3-
data[0].substr(1);
data[1].substr(1); //타입 에러 -4-
```

1. 배열 타입은 두 가지 방법으로 정의 가능
2. 숫자 배열에 문자열을 입력하면 에러 발생
3. 문자열과 숫자로 구성된 `튜플(tuple)` 타입을 정의
4. 두 번째 아이템의 타입은 숫자인데 문자열의 메서드를 호출하면 타입 에러발생
   - `substr` -> 문자열 메서드

#### null과 undefined 타입

- `Js`에서 값으로 존재하는 `null`, `undefined`는 타입스크립트에서 각각 타입으로 존재

```ts
`use strict`;
// -1-
let v1: undefined = undefined;
let v2: null = null;
// -1-
v1 = 123; // 타입 에러 -2-

let v3: number | undefined = undefined; // -3-
v3 = 123;
```

1. `undefined`, `null`은 타입으로 사용이 가능
2. `undefined` 타입에 숫자를 입력하면 타입 에러 발생
3. `undefined`, `null` 타입은 다른 타입과 함께 `유니온` 타입으로 정의할 때 많이 사용

> 유니온 타입

     `파이프(|)`를 이용해서 여러 가지중에 하나를 표현
     제너릭의 표현의 한계를 해결해준다.
     `파이프(|)`를 맨압에 사용하는 것도 가능함

```ts
type Animal = Rabbit | Dog | Cat;
```

> 정리

     Js와는 다르게 Ts 에서는 `undefined`, `null`을 타입으로 표현가능
     Js 에서는 값으로 표현됨

#### 문자열 리터럴과 숫자 리터털 타입

- Ts 에서는 문자열 리터럴과 숫자 리터럴을 타입으로 정의 가능

```ts
'use strict';

let v1: 10 | 20 | 30; // -1-
v1 = 10;
v1 = 15; // 타입 에러 -2-

let v2: '경찰관' | '소방관'; // -3-
v2 = '의사';
```

1. 숫자 10, 20, 30은 각각 타입으로 사용
   - 변수 `v1`은 오직 숫자 10, 20, 30만 가질 수 있는 타입으로 정의
2. 지정된 숫자가 아닌 다른 숫자는 입력 불가
3. 변수 `v2`는 문자열 리터럴 타입으로 정의

> 정리

     문자열 리터럴과 숫자 리터럴 타입으로 변수 타입을 정의 가능하다.

#### any 타입

- `any` 타입은 모든 종류의 값을 허용하는 타입

```ts
let val: any;
val = 123;
val = '456';
val = () => {};
```

- any 타입에는 `숫자`, `문자열`, `함수`도 입력 가능
- `any` 타입은 기존 Js -> Ts로 `포팅`하는 경우 유용하게 사용가능

- 다만 `any` 타입을 난발하면 타입스크립트를 사용하는 의미가 퇴색

#### void와 never 타입

- 아무 값도 반환하지 않고 종료되는 함수의 반환 타입은 `void` 타입으로 정의 가능
- 항상 예외가 발생해서 비정상적 종료되거나 무한 루프 때문에 종료되지 않는 함수의 반환타입은 `never`타입으로 정의 가능

```ts
'use strict';
// -1-
function f1(): void {
  console.log('hello');
}
// -2-
function f2(): never {
  throw new Error('some error');
}
// -3-
function f3(): never {
  while (true) {}
}
```

1. 아무 값도 반환하지 않으므로 `void` 타입으로 정의
2. 함수가 항상 비정상적으로 종료되므로 `never` 타입으로 정의
3. 함수가 종료되지 않으므로 `never`타입으로 정의

> 정리

     void : 아무것도 반환 하지 않을 때
     never : 함수가 종료되지 않을 경우

#### object 타입

- `object` 타입은 `Js`에서 일반적으로 사용되는 객체으 ㅣ타입

```ts
let v: object;
v = { name: 'abc' };
console.log(v.prop1); // 타입 에러 -1-
```

1. 객체의 속성에 대한 정보가 없기 때문에 특정 속성값에 접근하면 타입 에러 발생
   - 속성 정보를 포함해서 타입을 정의하기 위해서는 `interface`를 사용해야 함

#### 교차 타입과 유니온 타입

- 여러 타입의 교집합과 합집합을 각각 교차(`intersection`) 타입과 유니온(`union`) 타입으로
- 표현이 가능
- 교차 타입 -> `&`
- 유니온 타입 -> `|`

```ts
let v1: (1 | 3 | 5) & (3 | 5 | 7); // -1-
v1 = 3;
v1 = 1; // 타입 에러 -2-
```

1. 변수 `v1`의 타입은 3 | 5 와 같음
2. `v1`에 3또는 5가 아닌 값을 할당 불가

> 정리

     | : 유니온(union)
     & : 교차(intersection)

#### type 키워드로 타입에 별칭주기

- `type` 키워드를 사용해서 타입에 별칭을 줄 수 있음
- 타입 별칭은 타입을 선언할 때 편리하게 사용 가능

```ts
type Width = number | string; // -1-
let width: Width;
width = 100;
width = '100px';
```

1. number | string 타입에 Width라는 별칭을 부여
2. Width는 일반적인 타입처럼 사용될 수 있음

### 열거형 타입

- 열거형 타입은 `enum` 키워드를 사용해서 정의
- 역거형 타입의 각 원소는 `값`으로 사용될 수 있고 `타입`으로 사용 가능

```ts
// -1-
enum Fruit {
  Apple,
  Banana,
  Orange,
}
const v1: Fruit = Fruit.Apple; // -2-
const v2: Fruit.Apple | Fruit.Banana = Fruit.Banana; // -3-
```

1. 열거형 타입을 이용해서 파일을 정의
2. 열거형 타입의 원소인 Apple을 값으로 사용
3. Apple 타입을 사용

#### 명시적으로 원소의 값 입력하기

```ts
enum Fruit {
  Apple, // -1-
  // -2-
  Banana = 5,
  Orange,
}
console.log(Fruit.Apple, Fruit.Banana, Fruit.Orange);
```

1. 열거형 타입의 첫 번째 원소에 값을 할당하지 않으면 자동으로 0이 할당
2. 열거형 타입의 각 원소에 숫자 또는 문자열 할당할 수 있다.
   - 명시적으로 값을 입력 X -> 이전 원소에서 1만큼 증가한 값이 할당

- 다른 코드들과 달리 열거형 타입은 컴파일 후에도 관련된 코드가 남음

```ts
var Fruit;
(function (Fruit) {
  Fruit[(Fruit['Apple'] = 0)] = 'Apple'; // -2-
  Fruit[(Fruit['Banana'] = 5)] = 'Banana';
  Fruit[(Fruit['Orange'] = 5)] = 'Orange';
})(Fruit || (Fruit = {})); // -1-
console.log(Fruit.Apple, Fruit.Banana, Fruit.Orange);
```

1. 열거형 타입은 `객체`로 존재
2. 열거형 타입의 각 원소는 이름과 값이 양 방향으로 매핑(`mapping`) 됨
   - 열거형 타입은 객체로 존재하기 때문에 해당 객체를 `런타임`에 사용 가능

#### 열거형 타입의 객체 사용하기

```ts
enum Fruit {
  Apple,
  Banana = 5,
  Orange,
}
console.log(Fruit.Banana);
console.log(Fruit['Banana']);
console.log(Fruit[5]);
```
