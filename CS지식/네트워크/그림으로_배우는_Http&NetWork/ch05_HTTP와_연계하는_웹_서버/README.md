# 5. HTTP와 연계하는 웹 서버

- 웹 서버 : 1대의 서버에서 멀티 도메인으로
- ┣ 웹사이트를 실행하거나 중계 서버를 두어
- ┗ 통신 중에 효율을 올릴 수 있음

## 목차

- [5. HTTP와 연계하는 웹 서버](#5-http%EC%99%80-%EC%97%B0%EA%B3%84%ED%95%98%EB%8A%94-%EC%9B%B9-%EC%84%9C%EB%B2%84)
  - [5.1 1대로 멀티 도메인을 가능하게 하는 가상 호스트](#51-1%EB%8C%80%EB%A1%9C-%EB%A9%80%ED%8B%B0-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%84-%EA%B0%80%EB%8A%A5%ED%95%98%EA%B2%8C-%ED%95%98%EB%8A%94-%EA%B0%80%EC%83%81-%ED%98%B8%EC%8A%A4%ED%8A%B8)
  - [5.2 통신을 중계하는 프로그램 : 프록시, 게이트웨이, 터널](#52-%ED%86%B5%EC%8B%A0%EC%9D%84-%EC%A4%91%EA%B3%84%ED%95%98%EB%8A%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8--%ED%94%84%EB%A1%9D%EC%8B%9C-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4-%ED%84%B0%EB%84%90)
    - [프록시](#%ED%94%84%EB%A1%9D%EC%8B%9C)
    - [게이트 웨이](#%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%9B%A8%EC%9D%B4)
    - [터널](#%ED%84%B0%EB%84%90)
    - [5.2.1 프록시](#521-%ED%94%84%EB%A1%9D%EC%8B%9C)
      - [캐싱 프록시 (Cashing Proxy)](#%EC%BA%90%EC%8B%B1-%ED%94%84%EB%A1%9D%EC%8B%9C-cashing-proxy)
      - [투명 프록시 (Transparent Proxy)](#%ED%88%AC%EB%AA%85-%ED%94%84%EB%A1%9D%EC%8B%9C-transparent-proxy)
    - [5.2.2 게이트웨이](#522-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4)
    - [5.2.3 터널](#523-%ED%84%B0%EB%84%90)
  - [5.3 리소스를 보관하는 캐시](#53-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A5%BC-%EB%B3%B4%EA%B4%80%ED%95%98%EB%8A%94-%EC%BA%90%EC%8B%9C)
    - [5.3.1 캐시는 유효기간이 존재](#531-%EC%BA%90%EC%8B%9C%EB%8A%94-%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84%EC%9D%B4-%EC%A1%B4%EC%9E%AC)
    - [5.3.2 클라이언트 측에도 캐시가 존재](#532-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%B8%A1%EC%97%90%EB%8F%84-%EC%BA%90%EC%8B%9C%EA%B0%80-%EC%A1%B4%EC%9E%AC)

## 5.1 1대로 멀티 도메인을 가능하게 하는 가상 호스트

- HTTP/1.1 : 하나의 HTTP 서버에서 → 여러개의 웹 사이트 실행 가능
- ┣ ex) 웹 호스팅을 제공하고 있는 사업자 :
- ┣ 1대의 서버에 여러 고객의 웹 사이트를 넣을 수 있음
- ┣ 고객마다 다른 도메인, 다른 사이트 실행 가능
- ┗ 이를 위해 → `가상 호스트(Virtual Host)` 기능을 사용

- `가상 호스트` 사용 : 물리적으로는 서버 1대
- ┗ 가상으로 `여러대가 있는 것 처럼 동작`

- HTTP 사용해서 client → server 엑세스
- ┣ 호스트 명, 도메인 명이 자주 사용됨
- ┣ 인터넷에서 `도메인 명` : `DNS`에 의해서
- ┣ `IP주소로 변환`되고 나서 → `엑세스`하게 됨
- ┣ 결국 : 리퀘스트가 서버에 도착한 시점에는
- ┗ IP 주소를 기준으로 엑세스 하게됨

- 같은 `서버 상에 같은 IP 주소의 웹 서버`에서
- ┣ 두개의 도메인이 실행되고 있다면
- ┣ `DNS를 사용해서 이름을 해결 못함`
- ┗ 결국 둘 다 같은 수신인이 되어버림

> 같은 IP 주소에 다른 호스트 도메인 명

    이 경우에는 여러 `웹사이트가 같은 IP`
    ┣ 주소에서 실행이 되고 있음
    ┣ HTTP 리퀘스트를 보낼 때
    ┣ 호스트명, 도메인명을 완전하게 포함한
    ┣ 1. `URL 지정`하거나
    ┗ 2. `Host 헤더 필드에 지정`

## 5.2 통신을 중계하는 프로그램 : 프록시, 게이트웨이, 터널

- HTTP : client, server 이외에
- ┣ 1. `프록시`, 2. `게이트 웨이`, 3. `터널` 같은
- ┣ 통신을 중계하는 프로그램과 서버 연계 가능
- ┣ 1. 다음에 있는 다른 서버에 `request를 중계`하고
- ┗ 2. 서버로부터 받은 `response → client에 반환`

### 프록시

- server <-> client 양쪽 역할을 하는 `중계 프로그램`
- ┣ client으로 부터의 `request → server에 전송`
- ┗ server로 부터의 `response → client 전송`

### 게이트 웨이

- 다른 서버를 중계하는 서버
- ┣ client로 부터 수신한 request → `리소스` 보유한
- ┣ `서버인 것처럼 수신`함
- ┣ 경우에 따라 client : 상대가 게이트 웨이인지
- ┗ `확인을 못하는 경우도 존재`

### 터널

- 서로 떨어진 두 대의 `client, server 사이를 중계`,
- ┗ `접속을 주선하는 중계 프로그램`

### 5.2.1 프록시

- 프록시 서버의 기본적인 동작 :
- ┣ client로부터 수신한 request → server 전달
- ┣ client로부터 받은 `request URL` 변경X
- ┗ 이를 다음의 리소스를 가지고 있는 서버에 보냄

- 리소스 본체 가진 서버 : `오리진 서버(Origin Server)`
- ┣ 오리진 서버로부터 되돌아온 response
- ┗ `프록시 서버를 경유` → client에 돌아옴

> 프록시 서버를 경유해서 request, response 릴레이 진행마다
> Via 헤더 필드에 정보를 추가함

- HTTP 통신을 할 때 : 프록시 서버를 여러 대 경유도 가능
- ┣ 체인과 같이 여러 대 경유해서 request, response 중계
- ┗ 중계 시 : `Via 헤더 필드에 경유 정보 추가!`
- 프록시 서버의 사용 이유 :
- ┣ 1. 캐시를 사용해서 네트워크 대역 등을 `효율적 사용`
- ┣ 2. 조직 내 특정 웹 사이트에 대한 `엑세스 제한`
- ┗ 3. 엑세스 로그를 획득하는 정책을 `철저하게 지키려는 목적`

- 프록시의 사용 방법 : 여러가지 존재
- ┣ 2개의 기준으로 분류함
- ┣ 1. `하나는 캐시하는지 안하는 여부로 구분`
- ┗ 2. `메세지를 변경의 여부`

#### 캐싱 프록시 (Cashing Proxy)

- 프록시로 리스폰스 중계하는 때 :
- ┣ 프록시 서버 상에 `리소스 캐시를 보존` 해두는
- ┣ `타입의 프록시`
- ┣ 프록시에 → 다시 같은 리소스에 리퀘스트가 온 경우
- ┣ 오리진 서버로부터 `리소스를 획득하는 것이 아닌`
- ┗ `캐시를 리스폰스로서 돌려주는 것`

#### 투명 프록시 (Transparent Proxy)

- 프록시로 request, response 중계 시
- ┣ `메시지를 변경하지 않는 타입의 프록시` :
- ┗ 투명 프록시라고 부름

> 반대의 개념으로 메시지 변경 시 → 비투과 프록시

### 5.2.2 게이트웨이

- 게이트웨이의 동작 : `프록시와 매우 유사`
- ┣ 게이트웨이의 경우 → 그 다음에 있는 서버
- ┣ `HTTP 서버 이외의 서버를 제공하는 서버`가 됨
- ┣ client, gateway 사이의 `암호화` 등으로
- ┗ `안전`하게 접속함으로 → `통신의 안정성`을 높힘

- ex) 게이트웨이 : `데이터베이스에 접속`해서
- ┣ SQL 쿼리를 사용해서 `데이터를 얻는 곳에 이용`
- ┗ 그 밖 → 신용 카드 결제 시스템 등과 연계

### 5.2.3 터널

- 터널 : 요구에 따라서 다른 `서버와의 통신 경로를 확립`
- ┣ client → `SSL 같은 암호화 통신`을 통해 서버와
- ┗ 안전하게 통신을 하기 위해서 사용함

- 터널 자체 : HTTP request → `해석하려고 하지 않음`
- ┣ 결국 `request를 그대로 다음 서버에 중계`
- ┣ 터널은 통신하고 있는 양쪽 끝의 `접속이 끊어질 때`
- ┗ 종료함

## 5.3 리소스를 보관하는 캐시

- 캐시 : 프록시 서버, client의 로컬 디스크에 보관된
- ┣ `리소스의 사본을 가리킴`
- ┣ 캐시를 사용하면 → 리소스를 가진 서버에의 엑세스를 줄이는
- ┗ 것이 가능하기 때문에 `통신량과 통신 시간을 절약 가능`
- 캐시 서버 : 프록시 서버의 하나로 → 캐싱 프록시로 분류
- ┣ 결국 : 프록시가 서버로부터의 `리스폰스를 중계하는 때`에
- ┗ 프록시 서버 상에 `리소스의 사본을 보존`함

- client <-> 캐시 서버 <-> origin server
- ┣ index.html 파일 전송 시
- ┗ 리소스 사본을 캐시 서버에 남겨둠

> 리소스의 유효성 등을 오리진 서버에 확인하러 가는 경우도 존재

- `캐시 서버 장점` : 캐시를 이용함으로써
- ┣ 같은 `데이터를 몇 번이고 오리진 서버에 전송 필요 X`
- ┣ client → 네트워크에서 가까운 서버로부터
- ┣ 리소스를 얻을 수 있게 되어 서버는 같은
- ┗ `request를 매번 처리할 필요가 없음`

### 5.3.1 캐시는 유효기간이 존재

- 캐시 서버에 캐시가 있는 경우라도
- ┣ `같은 리소스의 request에 대해서`
- ┣ 항상 같은 캐시를 돌려주는 것은 아님
- ┗ 캐시되어 있는 `리소스의 유효성과 관계`

- 언제까지나 같은 캐시를 계속해서 사용시
- ┣ 오리진 서버에 있는 원래 `리소스의 갱신 경우도 존재`
- ┗ 캐시 서버 갱신되기 전의 `낡은 리소스 전송`

- 고로 : 캐시를 가지고 있다고 하더라도
- ┣ 1. `클라이언트 요구`
- ┣ 2. `캐시의 유효 기간`에 의해서
- ┣ 오리진 서버에 `리소스의 유효성을 확인` 하거나
- ┗ 리소스를 다시 획득하러 가는 경우도 존재

### 5.3.2 클라이언트 측에도 캐시가 존재

- 캐시 서버만 캐시를 가지고 있는 것은 아님
- ┣ `client 사용하는 브라우저에서도 캐시를 가질 수 있음`
- ┣ 이를 → 인터넷 임시 파일이라고 부름
- ┣ 유효한 캐시를 가지고 있는 경우
- ┗ 같은 리소스의 엑세스 → `로컬 디스크`로부터 가져옴

> 캐시 서버와 동일하게 리소스 오래된 경우
> 유효성 확인, 재획득 하러가는 경우 존재
