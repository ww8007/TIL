# 3. HTTP 정보는 HTTP 메시지에 있다

- HTTP 통신
- ┣ 1. `리퀘스트` : 클라이언트 → 서버
- ┗ 2. `리스폰스` : 서버 → 클라이언트

## 목차

- [3. HTTP 정보는 HTTP 메시지에 있다](#3-http-%EC%A0%95%EB%B3%B4%EB%8A%94-http-%EB%A9%94%EC%8B%9C%EC%A7%80%EC%97%90-%EC%9E%88%EB%8B%A4)
  - [3.1 HTTP 메시지](#31-http-%EB%A9%94%EC%8B%9C%EC%A7%80)
  - [3.2 리퀘스트 메시지와 리스폰스 메시지의 구조](#32-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%8B%9C%EC%A7%80%EC%99%80-%EB%A6%AC%EC%8A%A4%ED%8F%B0%EC%8A%A4-%EB%A9%94%EC%8B%9C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0)
  - [3.3 인코딩으로 전송 효율을 높이다](#33-%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9C%BC%EB%A1%9C-%EC%A0%84%EC%86%A1-%ED%9A%A8%EC%9C%A8%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8B%A4)
    - [3.3.1 메시지 바디와 엔티티 바디의 차이](#331-%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B0%94%EB%94%94%EC%99%80-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%B0%94%EB%94%94%EC%9D%98-%EC%B0%A8%EC%9D%B4)
    - [3.3.2 압축해서 보내는 콘텐츠 코딩](#332-%EC%95%95%EC%B6%95%ED%95%B4%EC%84%9C-%EB%B3%B4%EB%82%B4%EB%8A%94-%EC%BD%98%ED%85%90%EC%B8%A0-%EC%BD%94%EB%94%A9)
    - [3.3.3 분해해서 보내는 청크 전송 코딩](#333-%EB%B6%84%ED%95%B4%ED%95%B4%EC%84%9C-%EB%B3%B4%EB%82%B4%EB%8A%94-%EC%B2%AD%ED%81%AC-%EC%A0%84%EC%86%A1-%EC%BD%94%EB%94%A9)
  - [3.4 여러 데이터를 보내는 멀티파트](#34-%EC%97%AC%EB%9F%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%B3%B4%EB%82%B4%EB%8A%94-%EB%A9%80%ED%8B%B0%ED%8C%8C%ED%8A%B8)
  - [3.5 일부분만 받는 레인지 리퀘스트](#35-%EC%9D%BC%EB%B6%80%EB%B6%84%EB%A7%8C-%EB%B0%9B%EB%8A%94-%EB%A0%88%EC%9D%B8%EC%A7%80-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8)
  - [3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션](#36-%EC%B5%9C%EC%A0%81%EC%9D%98-%EC%BD%98%ED%85%90%EC%B8%A0%EB%A5%BC-%EB%8F%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-%EC%BD%98%ED%85%90%EC%B8%A0-%EB%84%A4%EA%B3%A0%EC%8B%9C%EC%97%90%EC%9D%B4%EC%85%98)

## 3.1 HTTP 메시지

- `HTTP 메시지` : HTTP에서 교환하는 정보
- ┣ 리퀘스트쪽 : 리퀘스트 메시지(HTTP)
- ┗ 리스폰스쪽 : 리스폰스 메시지(HTTP)

- HTTP 메시지 : `복수행(개행: CR+LF)`
- ┣ 데이터로 구성된 텍스트 문자열
- ┣ HTTP 메시지 : 크게 구분하면
- ┣ 1. `메시지 헤더`, 2. `메시지 바디`로 구현되어 있음
- ┣ 최초에 나타나는 `개행 문자(CR+LF)`
- ┗ 이 안에 메시지 바디가 항상 존재한다고는 할 수 없음

- 메시지 헤더
- ┣ 서버와 클라이언트가 꼭 처리해야 하는
- ┗ 리퀘스트, 리스폰스 내용과 속성

- CR + LF
- ┣ `CR(carriage return)` : 16진수 `0x0d`
- ┗ `LF(line feed)` : 16진수 `0x0a`

- 메시지 바디
- ┗ 꼭 전송되는 데이터 그 자체

## 3.2 리퀘스트 메시지와 리스폰스 메시지의 구조

- request 메시지와 response 메시지 구조 학습

> request 메시지

1. 메시지 헤더

   - ┣ 1) request 라인
   - ┣ 2) request 헤더 필드
   - ┣ 3) 일반 헤더 필드
   - ┣ 4) 엔티티 헤더 필드
   - ┗ 5) 그 외

2. 개행 문자(CR+LF)

3. 메시지 바디

> response 메시지

1. 메시지 헤더

   - ┣ 1) 상태 라인
   - ┣ 2) request 헤더 필드
   - ┣ 3) 일반 헤더 필드
   - ┣ 4) 엔티티 헤더 필드
   - ┗ 5) 그 외

2. 개행 문자(CR+LF)

3. 메시지 바디

> 해설

- `request 라인` :
- ┣ request에 사용하는 1. `메서드`와 2. `리퀘스트 URI`
- ┗ 3. `사용하는 HTTP 버전`

- `상태 라인` :
- ┣ response 결과를 나타내는 1. `상태코드, 설명`
- ┗ 2. `사용하는 HTTP 버전`

- `헤더 필드` :
- ┣ `request`, `response`의 여러 `조건과 속성`을 나타내는
- ┣ `각종 헤더 필드가 포함`
- ┣ 1. 일반 헤더 필드
- ┣ 2. request 헤더 필드
- ┣ 3. response 헤더 필드
- ┗ 4. 엔티티 헤더 필드

> 그 외

    HTTP의 RFC에는 없는 헤더 필드(쿠키) 포함

## 3.3 인코딩으로 전송 효율을 높이다

- `HTTP로 데이터를 전송`할 경우
- ┣ 그대로 전송할 수도 있지만
- ┣ 전송할 때에 `인코딩(변환)을 실시`함으로써
- ┗ `전송 효율을 높일 수 있음`

- `전송할 때 인코딩`을 하면 :
- ┣ 다량의 엑세스를 효율 좋게 처리 가능
- ┗ 단지 컴퓨터에서 인코딩 처리 → CPU 등의 `리소스는 더 많이 소비`

### 3.3.1 메시지 바디와 엔티티 바디의 차이

- `메시지`
- ┣ HTTP 통신의 기본 단위 : `옥텟 시퀀스(Octet sequence)`
- ┣ `octet : 8비트`
- ┗ 구성되고 `통신을 통해서 전송`

- `엔티티(entity)`
- ┣ `request`와 `response`의 `페이로드(payload)` → 부가물
- ┗ 전송되는 정보 : 1. `헤더 필드`, 2. `엔티티 바디`로 구성

- `HTTP 메시지 바디`의 역할 : `request`랑 `response`에 관한
- ┣ `엔티티 바디를 운반`하는 일
- ┣ 기본적으로 `메시지 바디`, `엔티티 바디`는 `같지만`
- ┣ `전송 코딩 적용` → `엔티티 바디의 내용이 변화`
- ┗ `메시지 바디와 달라짐`

- 메시지와 엔티티라는 단어는 뒤에서도 자주 등장하기 때문에 구분

### 3.3.2 압축해서 보내는 콘텐츠 코딩

- 메일에 `파일을 첨부`해서 보낼 경우
- ┣ 용량을 줄이기 위해서 `파일을 zip으로 압축`하고
- ┣ 첨부해서 보내는 경우가 있듯이
- ┣ `HTTP에도 이와 같은 일이 가능`한
- ┣ `콘텐츠 코딩(Content Codings)`라고 불리는 기능이 구현
- ┣ 콘텐츠 코딩 : `엔티티에 적용하는 인코딩`을 가리킴
- ┣ `엔티티 정보를 유지한채로 압축`
- ┗ 콘텐츠 코딩된 엔티티 : `수신한 클라이언트 측에서 디코딩`

> 엔티티를 작게 압축해서 송신한다고 생각하면 됨

- 주요 압축 콘텐츠
- ┣ 1. `gzip(GNU zip)`
- ┣ 2. `compress(UNIX의 표준 압축)`
- ┣ 3. `deflate(zlib)`
- ┗ 4. `identity(인코딩 없음)`

### 3.3.3 분해해서 보내는 청크 전송 코딩

- HTTP 통신에는 `리퀘스트했었던 리소스 전부`에서
- ┣ `엔티티 바디의 전송이 완료되지 않으면`
- ┣ 브라우저에 `표시되지 않음`
- ┣ 사이즈가 큰 데이터를 전송하는 경우
- ┣ `데이터를 분할해서 조금씩 표시 가능`
- ┣ 이렇게 엔티티 바디를 분할하는 기능
- ┗ `청크 전송 코딩(Chunked transfer Coding)`이라고 부름

1. 엔티티 바디를 작게 쪼개고 나서 송신
   - ┗ 분해한 것 : 청크(덩어리)

- `청크 전송 코딩` : `엔티티 바디를 청크(덩어리) 분해`
- ┣ `청크 사이즈`를 `16진수로 사용`해서 → `단락을 표시`
- ┗ 엔티티 바디 끝 → "`0(CR+LF)`"를 기록

- `청크 전송 코딩된 엔티티 바디` : 수신한 클라이언트 측에서
- ┣ `원래의 엔티티 바디로 디코딩`
- ┣ `HTTP/1.1` : `전송 코딩(Transfer Codings)`라는 `인코딩 방식`에 따라
- ┣ 전송하는 구조가 마련되어 있지만 `전송 코딩` :
- ┗ `청크 전송 코딩만 정의`

## 3.4 여러 데이터를 보내는 멀티파트

- 메일의 경우 : 메일의 본문이나 복수의 첨부 파일을 붙여
- ┣ 함께 보낼 수 있음
- ┣ 이것은 MIME(Multipurpose Internet Mail Extensions)
- ┣ 다목적 인터넷 메일 확장 사양 으로 불리는 텍스트, 영상, 이미지
- ┗ 와 같은 다른 데이터를 다루기 위한 기능을 사용

- `MIME` : 이미지 등의 바이너리 데이터 → `아스키(ASCII) 문자열`에
- ┣ `인코딩 하는 방법`과 `데이터 종류를 나타내는 방법` 등을 규정
- ┣ `MIME 확장 사양`에 있는 `멀티파트(Multipart)`라고 하는 여러 다른 종류의
- ┗ `데이터를 수용하는 방법을 사용`하고 있는 것

- `HTTP`도 `멀티파트에 대응하고 있어 하나의 메시지 바디 내부`에
- ┣ `엔티티를 여러개 포함시켜 보낼 수 있음`
- ┗ `주로 이미지나 텍트 파일등을 업로드` 하는데 사용

- 멀티파티에는 여러가지 종류가 존재

1. multipart/form-data

   - ┗ Web 폼으로부터 파일 업로드에 사용

2. multipart/byteranges
   - ┗ 상태 코드 206(Partial Content) 리스폰스가 복수의 범위 포함 시 사용

- `HTTP 메시지로 멀티파트` 사용 : `Content-type 헤더필드`를 사용
- ┣ 멀티파트 엔티티 구분 → `boundary 문자열`을 사용함
- ┣ 엔티티의 선두 : "boundary" 문자열 앞에 `"--"` 삽입
- ┗ 멀티 파트에 마지막 : 문자열 마지막 `"--"` 삽입

- ex) `--AaB03x--`, `--THIS_STRING_SEPARATES--`

- `멀티파트` : `파트마다 헤더 필드가 포함`
- ┣ `파트 중간` : `멀티파트를 만드는 것과 같이 파트를 내부에 포함 가능`
- ┗ 자세한 설명은 `RFC2046 참고`

## 3.5 일부분만 받는 레인지 리퀘스트

- 사용자가 광대역 네트워크 사용할 수 있기 전에는
- ┣ 대용량의 이미지와 데이터를 사용하기 힘들었음
- ┣ → 다운로드 중에 커넥션이 끊어지면
- ┗ 처음부터 다운로드 진행

- 문제 해결 : 일반적인 `리줌(resume)`
- ┣ resume을 통해 이전에 다운로드를 한 곳에서 부터
- ┗ 다운로드를 재개 가능

- 이 기능 실현 → `엔티티의 범위를 지정`해서 다운로드 할 필요 존재
- ┗ 이와 같이 `범위를 지정해서 request` → `레인지 리퀘스트(range request)`

- `레인지 리퀘스트` 사용 →
- ┣ 전체 10,000 바이트 정도 크기의 리소스 :
- ┗ 5001 ~ 10000 바이트 범위만을 리퀘스트 할 수 있음

> 리퀘스트에 대한 분할이 가능

- 레인지 리퀘스트 할 때는 Range 헤더 필드를 사용해서
- ┣ 리소스의 바이트 레인지를 지정
- ┗ 바이트 레인지는 다음과 같은 형식으로 지정

> 5,001 ~ 10,000 바이트

    Range: bytes = 5001~10000

> 5,001 바이트 이상

    Range: bytes=5001-

> 처음부터 3,000 바이트까지, 그리고 5,000~7000 바이트 까지

    Range: bytes=-3000, 5000-7000

- `레인지 리퀘스트에 대한 리스폰스` :
- ┣ `상태 코드 206 Partial Content` 라는 `리스폰스 메시지`가 돌아옴
- ┣ `복수 범위`의 레인지 리퀘스트에 대한 리스폰스 :
- ┗ `multipart/bytesranges`로 리스폰스가 `되돌아옴`

> 서버가 레인지 리퀘스트 지원 안하는 경우
> 상태 코드 200 OK 리스폰스 메시지로
> 완전한 엔티티가 되돌아옴

## 3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션

- 같은 콘텐츠(내용)이지만 `여러 개의 페이지를 지닌 웹 페이지`가 있음
- ┣ ex) 내용은 같지만 영판, 한판이 존재하는 경우
- ┣ 각각 `페이지를 분리하여 웹페이지를 표시`하게 되는데
- ┗ 이를 `콘텐츠 네고시에이션(Content Negotiation)`

- `콘텐츠 네고시에이션` : `client, server가 제공`하는
- ┣ `리소스의 내용에 대해서 교섭`하는 것
- ┗ client에는 `더욱 적합한 리소스를 제공하기 위한 구조`

- 콘텐츠 네고시에이션 제공 리소스 →
- ┗ 1. 언어, 2. 문자 세트, 3. 인코딩 방식을 기준으로 판단

- 판단 기준 : 리퀘스트 메시지에 포함된 다음과 같은 리퀘스트
- ┣ 헤더필드임
- ┣ 1. Accept
- ┣ 2. Accept-Charset
- ┣ 3. Accept-Encoding
- ┣ 4. Accept-Language
- ┗ 5. Content-Language

- 콘텐츠 네고시에이션의 종류

1. `서버 구동형 네고시에이션(Server-driven Negotiation)`

   - ┣ `서버 측` → 콘텐츠 네고시에이션을 하는 방식
   - ┣ 서버 측에서 `request 헤더 필드의 정보를 참고`하여
   - ┣ `자동으로 처리`를 함
   - ┗ 브라우저가 보내는 정보를 근거 → 유저에게 좋음

2. `에이전트 구동형 네고시에이션(Agent-driven Negotiation)`

   - ┣ `클라이언트 측`에서 진행
   - ┣ 브라우저에 표시된 선택지 중에서 `유저가 수동으로 선택`
   - ┣ `JS`등을 사용해서 `웹 페이지에서 자동으로 정함`
   - ┣ OS의 종류나 브라우저 종류 등에 의해서
   - ┗ `PC, 스마트폰 웹 페이지 자동 전환` → 이에 해당

3. `트랜스페어런트 네고시에이션(Transparent Negotiation)`
   - ┣ `서버 구동형과 에이전트 구동형을 혼합한 것`
   - ┗ 서버와 클라이언트가 `각각` `콘텐츠 네고시에이션`을 하는 방식
