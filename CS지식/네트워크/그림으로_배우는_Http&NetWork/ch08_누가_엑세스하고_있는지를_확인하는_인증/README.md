# 8. 누가 액세스하고 있는지를 확인하는 인증

- 웹에는 특정 인물에게만 보여주고 싶은 페이지나
- ┣ 자신의 전용 페이지 등이 필요한 경우가 존재
- ┣ `그러기 위해서 필요한 기능 → 인증`
- ┗ 이번 장 에서는 인증 구조에 대해 설명

## 8.1 인증이란?

- 컴퓨터 : 모니터 앞에 앉은 사람 누구인지 모름
- ┣ 게다가 네트워크 저편에 누가 있는지 알 수 없음
- ┣ 서버에 액세스 하고 있는 사람이 누구인지 알려면
- ┗ `상대방 클라이언트에 이름을 요청해야 함`

- 다만 : 엑세스하고 있는 사람이 이름을 밝혀도
- ┣ 진짜 그 사람인지 확인 불가
- ┗ 고로 → `특정 정보로 확인해야 함`

> 특정 정보

    1. 패스워드
    2. 원타임 토큰
    ┣ 본인만이 가지고 있는 기기 등에
    ┗ 한 번 쓰고 버리는 패스워드 등 정보
    3. 전자 증명서 : 본인(단말기)만이
    ┗ 가지고 있는 정보
    4. 바이오 매트릭스
    ┣ 지문, 홍채 등 본인의 신체 정보
    5. IC 카드 : 본인만이 가지고 있는 정보

### HTTP에서 사용하는 인증 방법

- HTTP/1.1에서 이용할 수 있는 인증 방법의 종류

1. BASIC 인증

2. DIGEST 인증

3. SSL 클라이언트 인증

4. 폼 베이스 인증

5. Windows 인증(Kerberos 인증)

6. NTLM 인증

## 8.2 BASIC 인증

- BASIC 인증 : HTTP/1.0에 구현된 인증방식
- ┣ 현재에도 일부 사용되고 있음
- ┣ `웹 서버와 대응하고 있는 클라이언트 사이에서`
- ┗ 이루어지는 인증 방식

### 8.2.1 BASIC 인증 수순

1. BASIC 인증이 필요한 리소스에

- ┣ request가 있는 경우에은
- ┣ 서버에 상태 코드 401 (Authorization Required)와 함께
- ┣ `인증의 방식(BASIC)`과 `Request-URI의 보호 공간을 식별 위한`
- ┣ `문자열(realm)`을 WWW-Authenticate 헤더 필드에 포함해서
- ┗ response를 반환함

2. 상태 코드 401을 받은 클라이언트

- ┣ BASIC 인증을 위해서 유저 ID, PW를
- ┣ 서버에 송신할 필요가 있음
- ┣ 송신하는 문자열 :
- ┣ 유저 ID와 패스워드를 `콜론(":")`으로 연결한
- ┣ 문장을 `Base64이라 불리는 형식으로 인코드 한 것`
- ┣ `이 문장을 Authorization 헤더 필드에 포함해서`
- ┣ `request를 송신함`
- ┣ 유저 에어전트에 브라우저를 사용하고 있는 경우 이용자가
- ┗ ID, PW 입력하면 `브라우저가 자동으로 Base64로 인코딩`

3. Authorization 헤더 필드를 포함한

- ┣ request를 수신한 서버의 경우 :
- ┣ 인증 정보가 정확한지 여부를 판단함
- ┣ `인증 정보가 정확하면 Request-uRI 리소르를 포함한`
- ┗ `response를 반환함`

- BASIC 인증에서는
- ┣ BASE64라는 인코딩 형식을 사용하지만
- ┣ 이것은 암호화는 아니기 때문에
- ┣ 아무런 부가 정보 없이 복호화가 가능함
- ┗ `즉 : 정보 도난의 가능성이 있음`

- 또한 : 한번 BASIC 인증을 하면
- ┣ 일반 브라우저에서는 로그아웃 할 수 없다는 단점
- ┗ `고로 사용 빈도수가 높지 않음`

## 8.3 DIGEST 인증

- BASIC 인증의 약점을 보안하여
- ┣ HTTP/1.1에 소개되어 있음
- ┣ DIGEST 인증에는 챌린지 response 방식이 사용
- ┗ `BASIC 인증 같이 패스워드를 있는 그대로 보내는 경우 없음`

- `챌린지 response` 방식 :
- ┣ 최초에 상대방에게 인증 요구를 보내고
- ┣ `상대방 측에서 받은 챌린지 코드를 사용하여`
- ┣ `response 코드를 계산함`
- ┗ 이 값을 상대에게 송신하여 인증을 하는 방식

- response 코드 :
- ┣ `PW, 챌린지 코드를 사용하여`
- ┣ 계산한 결과를 상대방에게 보내기 때문에
- ┣ `BASIC 방식에 비해서 패스워드 누출 가능성을`
- ┗ `줄여줌`

1. 인증이 필요한 리소스에 request가 있는 경우

- ┣ 서버 : 상태 코드 401 Authorization Required와 함께
- ┣ 챌린지 response 방식의 인증에 필요한
- ┣ `챌린지 코드(nonce)`를 `WWW-Authenticate` 헤더 필드에
- ┣ 포함해서 response를 반환함

- ┣ WWW-Authenticate 필요한 정보
- ┣ 1. `realm`
- ┣ 2. `nonce `
- ┣ 클라이언트와 이 값을 서버에 보내는 것으로
- ┣ 인증이 이루어짐
- ┣ `nonce : 401 리스폰스를 반환할 때마다 `
- ┣ `생성되는 유일한 문자열임`
- ┣ 이 문자열은 `BASE64, 16진수가 권장되고 있음`
- ┗ `문자열의 내용 : 구현된 서버에 의존함`

2. 상태 코드 401을 수신한 클라이언트 :

- ┣ DIGEST 이능을 위해 필요한 정보를
- ┣ `Authorization 헤더 필드에 포함해서`
- ┣ response를 반환하게 됨

- Authorization 헤더 필드에 반드시 필요한 정보 :
- ┣ 1. `username`
- ┣ 2. `realm`
- ┣ 3. `nonce`
- ┣ 4. `uri`
- ┣ 5. `response` 임
- ┗ 이 중에서 `realm, nonce 서버에서 받은 것을 사용`

- `username` : 지정된 realm에서 인증 가능한
- ┣ `사용자 이름을 의미`
- ┣ `uri(digest-uri)` : Request-URI에 있는
- ┣ URI를 의미 하지만 `프록시에 변경 될 수 있으므로`
- ┣ `여기에 복사를 시켜둠`
- ┣ response: `Request-Digest 패스워드 문자열을`
- ┗ `MD5로 계산한 것, 리스폰스 코드임`

3. Authorization 헤더 필드를 포함한 request 받은 서버 :

- ┣ 인증 정보가 정확한 것인지 아닌지를 판단
- ┣ 인증 정보가 정확한 경우에는
- ┣ `Request-URI 리소스를 포함한 response를 반한함`
- ┣ 이 때 서버 : `Authentication-Info 헤더 필드에 성공한`
- ┗ `인증에 대한 몇 가지 정보를 추가할 때도 있음`

- `DIGEST 인증`은 BASIC 인증에 비해서 높은 보안 등급을 제공함
- ┣ `HTTPS 클라이언트 인증 등과 비교하면 `
- ┣ `보안 등급은 낮음`
- ┣ 패스워드 도청 방지를 위한 보호 기능은 제공하지만
- ┗ `위장을 방지하는 기능은 기능은 제공하지 않음`

> DIGEST 인증도 BASIC 인증과 마찬가지로 사용자의 문제와 많은

    보안 등급에도 미치지 못한다는 점에서
    ┗ 그다지 사용되고 있지 않음

## 8.4 SSL 클라이언트 인증

- 유저 ID와 패스워드를 사용한 인증 방식은
- ┣ 두 가지 정보가 정확하다면
- ┣ 본인으로서 인증이 가능함
- ┣ 이 정보가 도난되었을 때에는 제 3자가
- ┣ `위장을 하는 경우가 있음`
- ┣ 이를 방지하기 위한 대책 중의 하나로
- ┗ `SSL 클라이언트 인증이 사용되는 일이 있음`

- `SSL 클라이언트 인증 : HTTPS 클라이언트`
- ┣ `인증서를 이용한 인증 방식임`
- ┣ HTTPS 장에서 설명했던 클라이언트 증명서를
- ┣ 인증할 때 사용하는 방식으로
- ┣ `사전에 등록된 클라이언트에서의 엑세스인지 아닌지`
- ┗ 판단이 가능함

### 8.4.1 SSL 클라이언트 인증의 인증 수순

- SSL 클라이언트 인증을 할 때에는
- ┣ 1. `사전에 클라이언트에 클라이언트 증명서`
- ┣ `배포를 하고`
- ┗ 2. `인스톨을 할 필요성이 있음`

1. `인증이 필요한 리소스의 request가 있었을 경우`에는

- ┣ 서버는 클라이언트에게
- ┣ 클라이언트 증명서를 `"Certification Request"`
- ┗ 메시지를 송신해야함

2. `유저 : 송신하는 클라이언트 증명서를 선택함`

- ┣ 그리고 클라이언트 : 클라이언트 증명서를
- ┗ `"Client Certificate"` 라는 메시지를 송신함

3. 서버 : 클라이언트 증명서를 검증하여

- ┣ 검증 결과가 정확하다면
- ┣ `클라이언트의 공개키를 취득함`
- ┗ 그 이후에 `HTTPS에 의한 암호를 개시함`

### 8.4.2 SSL 클라이언트 인증은 2-factor 인증에서 사용됨

- `SSL 클라이언트 인증은 대부분의 경우`
- ┣ 단독으로 사용되지 않고
- ┣ 이후에 다룰 품 베이스 인증과 함벼처서
- ┣ `2-factor 인증의 하나로서 이용되고 있음`
- ┣ `2-factor 인증이란` EX:
- ┣ 패스워드라는 한 개의 요소만이 아닌
- ┗ 이용자가 가진 `다른 정보를 병용해서 인증을 하는 방법`

- 즉 : `첫 번째 인증 정보로서 SSL 클라이언트`
- ┣ `인증을 사용하여 클라이언트의 컴퓨터를 인증하고`
- ┣ 다른 인증 정보로서 패스워드를 사용하여
- ┣ `유저의 본인 확인을 함`
- ┣ 이로 인해 본인이 컴퓨터에서 엑세스 하고 있음을
- ┗ 확인할 수 있음

### 8.4.3 SSL 클라이언트 인증은 이용하는데 비용이 필요함

- `SSL 클라이언트 인증에서는`
- ┣ 클라이언트 증명서를 이용할 필요가 있음
- ┣ 이 클라이언트 증명서를 이용하기 위해서
- ┣ 비용이 필요하게 됨
- ┣ `이 경우에 비용은 인증 기관에서 클라이언트`
- ┣ 증명서를 구입하는 비용이나 서버의 운영자가
- ┗ `자신이 인증 기간을 비용 입니다`

> 비용이 듬

## 8.5 폼 페이스 인증

- 폼 베이스 인증 : HTTP 프로토콜로서
- ┣ 사용이 정의되어 있는 인증 방식은 아님
- ┣ 클라이언트가 서버 상의 웹 애플리케이션
- ┣ `자격 정보(Credential)를 송신하여` 그
- ┗ `자격 정보의 검증 결과에 따라 인증을 하는 방식`

- 이것은 웹 애플리케이션에 따라 제공되는
- ┗ `인터페이스나 인증 방식이 다양함`

- 대부분의 경우에는 사전에 등록해 둔
- ┣ 자격 정보인 유저ID(임의의 문자열이나
- ┣ 메일 주소 등이 자주 사용됨)와 패스워드를 입력해서
- ┣ 이것을 `웹 애플리케이션 측에 송신하고`
- ┗ `검증 결과를 토대로 검증 성공 여부를 결정함`

### 8.5.1 인증의 대부분은 폼 페이스 인증

- HTTP 표준으로 제공하는
- ┣ BASIC 인증이나 DIGEST 인증은
- ┣ 사용상의 문제와 보안적인 문제로 거의
- ┣ 사용되고 있지 않음
- ┣ 또한 보안 등급이 높은 SSL 클라이언트 인증도
- ┣ 도입 비용이나 운용 비용 등의 문제로
- ┗ `널리 사용되고 있지 못하고 있음`

> 웹 에플리케이션에서 제각각

    구현하는 폼 페이스
    ┗ 폼 베이스 인증을 채용

### 8.5.2 세션 관리와 쿠키에 의한 구현

- 폼 베이스 인증 :
- ┣ `표준적인 사양이 결정되어 있지 않지만`
- ┣ 세션 관리를 위해서 쿠키를 사용하는
- ┗ 방법이 존재함

- 폼 베이스 인증의 인증 자체는
- ┣ 서버 측의 웹 애플리케이션 등에 의해서
- ┣ 클라이언트가 송신해온 유저 ID와 PW가
- ┣ `사전에 등록하고 잇는 것과 일치하는지`
- ┗ `어떤지를 검증하면서 이루어짐`

- 그러나 `HTTP : 스테이트리스 프로토콜이기 때문에`
- ┣ 방금 전에 인증을 성공했던 유저라는 상태를
- ┣ `프로토콜 레벨에서는 유지할 수 없음`
- ┣ 즉 : 상태 관리가 안되기 때문에
- ┣ 다음에 그 유저가 엑세스 했다고 하더라도
- ┣ 다른 유저와 구별하지 못함
- ┣ 그래서 세션 관리와 쿠리를 사용해서
- ┗ `HTTP에 없는 상태 관리 기능을 보충함`

1. 클라이언트와 서버에 유저 ID나 PW 등의

- ┣ `자격 정보를 포함한 request를 송신함`
- ┣ 보통은 POST 메소드를 사용되어
- ┣ `엔티티 바디에 자격 정보를 저장함`
- ┣ 이때 HTML 폼 화면 표시와 입력 데이터의
- ┗ `송신에는 HTTPS 통신을 이용함`

2. 서버 측 : 유저를 식별하기 위해서

- ┣ 세션 ID를 발행함
- ┣ 클라이언트에서 `수신한 자격 정보를 검증하는 것으로`
- ┣ 인증을 진행하고
- ┣ 유저의 인증 상태를 세션 ID와 연관지어
- ┣ 서버 측에 기록함
- ┣ 클라이언트 측에 송신할 때는
- ┣ `Set-Cookie 헤더 필드에 세션 ID를 저장해서`
- ┗ `response를 반환함`

- 세션 ID : 다른 유저와 구별하기 위한 것임
- ┣ 세션 ID가 제 3자에게 악용되면
- ┣ `세션 ID의 주인 행세를 할 수 있기 때문에`
- ┣ 도난당하거나 쉽게 유추되지 않도록 해야 할
- ┣ 필요성이 있음
- ┣ 세션 ID는 추측하기 어려운 문자열을 사용하고
- ┣ `서버측 : 유효 기간을 관리하는 보안을 유지할 `
- ┣ `필요성이 존재함`
- ┣ `크로스 사이트 스크립팅 등의 취약성이 존재한`
- ┣ 경우라도 피해를 줄이기 위해서
- ┗ `쿠키에는 httponly` 속성을 부여해둠

- 이 구현 방법은 어디까지나
- ┣ 하나의 예 이기 때문에
- ┗ 다른 방법으로 구현된 경우도 존재함

- 또한 `폼 베이스 인증`에서는
- ┣ 자격 정보를 교환하는 방법은
- ┣ `표준화 되어 있지 않고`
- ┣ ID, PW 등의 자격 정보를 서버 측에서
- ┣ 어떻게 보존해야 하는지도 표준화가
- ┗ 되어 있지 않음

- 일반적으로 안전한 방법 :
- ┣ 패스워드를 `salt`라는 부가 정보를 사용해서
- ┣ `해시라는 알고리즘으로 계산한 값을 저장`
- ┣ 평문의 패스워드를 서버에 그대로 보존하는 것도
- ┣ 눈에 띔
- ┗ `패스워드가 누설될 가능성도 존재함`
