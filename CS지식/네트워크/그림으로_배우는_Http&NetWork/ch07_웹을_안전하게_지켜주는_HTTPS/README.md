# 7. 웹을 안전하게 지켜주는 HTTPS

## 목차

- [7. 웹을 안전하게 지켜주는 HTTPS](#7-%EC%9B%B9%EC%9D%84-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%A7%80%EC%BC%9C%EC%A3%BC%EB%8A%94-https)
  - [7.1 HTTP의 약점](#71-http%EC%9D%98-%EC%95%BD%EC%A0%90)
    - [7.1.1 평문이기 때문에 도청 가능](#711-%ED%8F%89%EB%AC%B8%EC%9D%B4%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EB%8F%84%EC%B2%AD-%EA%B0%80%EB%8A%A5)
      - [TCP/IP는 도청 가능한 네트워크](#tcpip%EB%8A%94-%EB%8F%84%EC%B2%AD-%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)
    - [암호화로 도청을 피하다](#%EC%95%94%ED%98%B8%ED%99%94%EB%A1%9C-%EB%8F%84%EC%B2%AD%EC%9D%84-%ED%94%BC%ED%95%98%EB%8B%A4)
      - [1. 통신 암호화](#1-%ED%86%B5%EC%8B%A0-%EC%95%94%ED%98%B8%ED%99%94)
      - [2. 콘텐츠 암호화](#2-%EC%BD%98%ED%85%90%EC%B8%A0-%EC%95%94%ED%98%B8%ED%99%94)
    - [7.1.2 통신 상대를 확인하지 않기 때문에 위장 가능](#712-%ED%86%B5%EC%8B%A0-%EC%83%81%EB%8C%80%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%9C%84%EC%9E%A5-%EA%B0%80%EB%8A%A5)
      - [누구나 리퀘스트할 수 있다](#%EB%88%84%EA%B5%AC%EB%82%98-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4)
      - [상대를 확인하는 증명서](#%EC%83%81%EB%8C%80%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EC%A6%9D%EB%AA%85%EC%84%9C)
    - [7.1.3 완전한 증명할 수 없기 때문에 변조 가능](#713-%EC%99%84%EC%A0%84%ED%95%9C-%EC%A6%9D%EB%AA%85%ED%95%A0-%EC%88%98-%EC%97%86%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EB%B3%80%EC%A1%B0-%EA%B0%80%EB%8A%A5)
      - [수신한 내용이 다를지도 모른다](#%EC%88%98%EC%8B%A0%ED%95%9C-%EB%82%B4%EC%9A%A9%EC%9D%B4-%EB%8B%A4%EB%A5%BC%EC%A7%80%EB%8F%84-%EB%AA%A8%EB%A5%B8%EB%8B%A4)
      - [변조를 방지하려면?](#%EB%B3%80%EC%A1%B0%EB%A5%BC-%EB%B0%A9%EC%A7%80%ED%95%98%EB%A0%A4%EB%A9%B4)
  - [7.2 HTTP + 암호화 + 인증 + 완정성 보호 = HTTPS](#72-http--%EC%95%94%ED%98%B8%ED%99%94--%EC%9D%B8%EC%A6%9D--%EC%99%84%EC%A0%95%EC%84%B1-%EB%B3%B4%ED%98%B8--https)
    - [7.2.1 HTTP에는 암호화와 인증과 완정성 보호를 더한 HTTPS](#721-http%EC%97%90%EB%8A%94-%EC%95%94%ED%98%B8%ED%99%94%EC%99%80-%EC%9D%B8%EC%A6%9D%EA%B3%BC-%EC%99%84%EC%A0%95%EC%84%B1-%EB%B3%B4%ED%98%B8%EB%A5%BC-%EB%8D%94%ED%95%9C-https)
    - [7.2.2 HTTPS는 SSL의 껍질을 덮어쓴 HTTP](#722-https%EB%8A%94-ssl%EC%9D%98-%EA%BB%8D%EC%A7%88%EC%9D%84-%EB%8D%AE%EC%96%B4%EC%93%B4-http)
    - [7.2.3 상호간에 키를 교환하는 공개키 암호화 방식](#723-%EC%83%81%ED%98%B8%EA%B0%84%EC%97%90-%ED%82%A4%EB%A5%BC-%EA%B5%90%ED%99%98%ED%95%98%EB%8A%94-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%A9%EC%8B%9D)
      - [공통키 암호의 딜레마](#%EA%B3%B5%ED%86%B5%ED%82%A4-%EC%95%94%ED%98%B8%EC%9D%98-%EB%94%9C%EB%A0%88%EB%A7%88)
      - [두 개의 키를 사용하는 공개키 암호](#%EB%91%90-%EA%B0%9C%EC%9D%98-%ED%82%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EC%95%94%ED%98%B8)
      - [HTTPS : 하이브리드 암호 시스템](#https--%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C-%EC%95%94%ED%98%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C)
    - [7.2.4 공개키가 정확한지 아닌지 증명하는 승명서](#724-%EA%B3%B5%EA%B0%9C%ED%82%A4%EA%B0%80-%EC%A0%95%ED%99%95%ED%95%9C%EC%A7%80-%EC%95%84%EB%8B%8C%EC%A7%80-%EC%A6%9D%EB%AA%85%ED%95%98%EB%8A%94-%EC%8A%B9%EB%AA%85%EC%84%9C)
      - [조직의 실제성을 증명하는 EV SSL 증명서](#%EC%A1%B0%EC%A7%81%EC%9D%98-%EC%8B%A4%EC%A0%9C%EC%84%B1%EC%9D%84-%EC%A6%9D%EB%AA%85%ED%95%98%EB%8A%94-ev-ssl-%EC%A6%9D%EB%AA%85%EC%84%9C)
      - [클라이언트를 확인하는 클라이언트 증명서](#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%A6%9D%EB%AA%85%EC%84%9C)
      - [인증 기관는 신용이 제일](#%EC%9D%B8%EC%A6%9D-%EA%B8%B0%EA%B4%80%EB%8A%94-%EC%8B%A0%EC%9A%A9%EC%9D%B4-%EC%A0%9C%EC%9D%BC)
      - [자기 인증 기관 발행 증명서는 '나야 나' 증명서](#%EC%9E%90%EA%B8%B0-%EC%9D%B8%EC%A6%9D-%EA%B8%B0%EA%B4%80-%EB%B0%9C%ED%96%89-%EC%A6%9D%EB%AA%85%EC%84%9C%EB%8A%94-%EB%82%98%EC%95%BC-%EB%82%98-%EC%A6%9D%EB%AA%85%EC%84%9C)
    - [7.2.5 안전한 통신을 하는 HTTPS의 구조](#725-%EC%95%88%EC%A0%84%ED%95%9C-%ED%86%B5%EC%8B%A0%EC%9D%84-%ED%95%98%EB%8A%94-https%EC%9D%98-%EA%B5%AC%EC%A1%B0)
      - [SSL과 TLS](#ssl%EA%B3%BC-tls)
      - [SSL은 느리다?](#ssl%EC%9D%80-%EB%8A%90%EB%A6%AC%EB%8B%A4)

## 7.1 HTTP의 약점

- 지금까지 HTTP의 좋은 점이나
- ┣ 편리한 점만을 다루어 왔지만
- ┗ HTTP에도 약점이 존재함

1. 평문(암호화 하지 않은) 통신이기 때문에 `도청 가능`

2. 통신 상대를 확인하지 않아 → `위장 가능`

3. 안정성을 증명할 수 없기 때문에 `변조 가능`

- 이 약점은 HTTP만 아닌
- ┣ 다른암호화 하지 않은 프로토콜에도
- ┣ 공통되는 문제임
- ┣ 그 밖에도 HTTP는 다른 문제점을 가지고 있음
- ┣ `특정 웹 서버나 특정 웹 클라이언트의 구현상의`
- ┣ 약점(취약성 또는 시큐리티 홀) `Java나 PHP 등으로`
- ┗ 구축한 웹 애플리케이션 취약성 등이 있음

### 7.1.1 평문이기 때문에 도청 가능

- HTTP를 사용한 request, response 통신 내용
- ┣ HTTP 자신을 암호화 하는 기능은 없기 때문에
- ┣ 통신 전체가 암호화 되지는 않음
- ┗ 즉 : 평문(암호화 X)으로 HTTP 메시지를 보내게 됨

#### TCP/IP는 도청 가능한 네트워크

- 암호화 되지 않는 통신에 약점이 있는 이유는
- ┣ TCP/IP의 구조의 통신 내용은
- ┣ 전부 통신 경로의 도중에 엿볼 수 있음
- ┣ 인터넷은 전 세계를 경유하는 네트워크임
- ┣ 어느 서버와 클라이언트가 통신을 할 때
- ┣ 통신 상에 있는 네트워크 기기나 케이블이나 컴퓨터 등을
- ┗ 모두 자신이 소유할 수 없음

- 이 과정에서 악의를 가진 누군가가 엿볼 수 있음
- ┣ 통신 내용 엿본다 : 암호화된 통신에도
- ┣ 암호화되지 않은 통신도 같음
- ┗ `암호화 통신의 경우 메시지 내용 자체는 볼 수 있음`

- 같은 세그먼트의 통신을 도청하는 것은
- ┣ 어려운 일이 아님
- ┣ `네트워크 상을 흐르고 있는 패킷을 수집` :
- ┣ 이것만으로도 도청이 가능함
- ┗ 패킷 수집 → 패킷 캡처, 스피너 툴

### 암호화로 도청을 피하다

- 현재 도청으로부터 정보를 지키기 위한 방법은
- ┣ 몇 가지가 있음
- ┣ 그 중 가장 보급되어 있는 기술 :
- ┗ `암호화`임

#### 1. 통신 암호화

- 한 가지는 통신을 암호화하는 방법
- ┣ HTTP에는 암호화 구조는 없지만
- ┣ `SSL(Secure Socket Layer)`이나
- ┣ `TSL(Transport Layer Security)`라는
- ┣ 다른 프로토콜을 조합함으로써 HTTP 통신 내용을 암호화
- ┣ 1. `SSL 등을 이용한 안전한 통신로를 확립하고`
- ┣ 2. `그 통신로를 사용해 HTTP 통신을 함`
- ┣ SSL을 조합한 `HTTP → HTTPS(HTTP Secure)`
- ┗ 또는 `HTTP over SSL` 이라고 부름

#### 2. 콘텐츠 암호화

- `콘텐츠의 내용 자체를 암호화 `
- ┣ HTTP에 암호화를 하는 기능은 없기 때문에
- ┣ `HTTP를 사용해서 운반하는 내용을 암호화`
- ┣ 즉 : HTTP 메시지에 포함되는 `콘텐츠만 암호화`
- ┣ 이 경우 클라이언트에서 HTTP 메시지를 암호화해서
- ┣ 출력하는 처리가 필요함

- ┣ 물론 콘텐츠의 암호화를 유효하게 하기 위해서는
- ┣ 클라이언트와 서버가 콘텐츠의 암호화나 복호화 구조를
- ┣ 가지고 있는 것이 전제가 됨
- ┣ 평상시에 유저가 사용하는 브라우저 웹 서버 이용 어려움
- ┗ 주로 웹 서비스 에서 이루어지는 방법

### 7.1.2 통신 상대를 확인하지 않기 때문에 위장 가능

- HTTP를 사용한 request, response에서는
- ┣ 통신 상대를 확인하지 않음
- ┣ request를 보낸 서버가 정말로 URI에서 지정한
- ┗ 호스트인지 아닌지 확인이 불가함

#### 누구나 리퀘스트할 수 있다

- HTTP에 의한 통신에는 상대가 누구인지 확인하는
- ┣ 처리는 존재하지 않음
- ┣ 고로 누구나 request 요청이 가능함
- ┣ 또한 request가 오면 상대가 누구든지
- ┗ response에 대해서 반환하도록함

- 이 경우 매우 간단하지만
- ┗ 이것이 약점이 될 수 있음

1. `리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 `

- ┣ 리스폰스를 보내야 하는 웹 서버인지 아닌지 확인 불가
- ┗ `위장한 웹 서버일 우려 있음`

2. 리스폰스를 반환한 곳의 클라이언트가

- ┣ 의도한 클라이언트인지 확인 불가
- ┗ `위장한 클라이언트일 우려 있음`

3. 통신하고 있는 상대가 허가된 상대인지 확인 불가

- ┣ 중요한 정보를 가진 웹 서버에서는
- ┗ `특정 상대만 통신을 허가하고 싶은 경우가 있음`

4. 어디의 누가 리퀘스트를 했는지 확인 할 수 없음

5. 의미없는 request도 수신하게 됨

- ┗ `대량의 리퀘스트에 의한 Dos 공격을 방지할 수 없음`

#### 상대를 확인하는 증명서

- HTTP 에서는 통신 상대를 확인할 수 없지만
- ┣ `SSL로 상대를 확인할 수 있음`
- ┣ SSL : 1. `암호화 뿐만 아닌`
- ┣ 2. `상대를 확인하는 수단`으로 증명서를 제공함
- ┣ 증명서는 신뢰할 수 있는 `제 3자 기관에 의해 발행됨`
- ┣ `서버나 클라이언트가 실재하는 사실을 증명함`
- ┗ 증명서를 가지고 내가 통신하는 상대를 판단가능

### 7.1.3 완전한 증명할 수 없기 때문에 변조 가능

- 완전성 : 정보의 정확성을 가리킴
- ┗ 이것을 증명 X → 정보가 정확한지 아닌지 확인 불가의 의미

#### 수신한 내용이 다를지도 모른다

- HTTP가 완전성을 증명할 수 없다는 뜻 :
- ┣ request, response가 발신된 후에 상대가
- ┣ 수신할 때 사이에 변조가 되었다 하더라도
- ┣ 이 사실을 알 수 없다는 의미임
- ┗ 즉 : 발신과 수신에 대해서 확인 불가

> 공격자가 도중에 request, response 뺐어서 변조

    중간자 공격
    Main in the Middle

#### 변조를 방지하려면?

- HTTP를 사용해서 완정성을 확인하기 위한
- ┣ 방법은 존재하지만 확실하면서 편한 방법 X
- ┣ 그 중에서도 많이 사용되는 것
- ┣ 1. `MD5, SHA-1` 등의 해시 값을 확인하는 방법
- ┣ 2. 파일의 디지털 서명을 확인하는 방법

- 파일 다운로드 서비스를 제공하는 웹 사이트에서는
- ┣ `PGP(Pretty Good Privacy)`에 의한 서명과
- ┣ MD5에 의한 해시 값을 제공하는 일이 있음
- ┣ `PGP : 파일을 작성했다는 증명을 위한 서명`
- ┣ `MD5 : 단방향성 함수에 의한 해시값임`
- ┣ 어느 쪽을 사용하더라도 클라이언트를 이용하는
- ┗ 유저 자신이 다운로드 받은 파일을 토대로 검사할 필요 존재

> 브라우저에서 자동적으로 검사가 이루어지는 것이 아님

- 아쉽게도 이 방법으로 확실한 것은 아님
- ┣ PGP, MD5 자체도 적절하게 수정되어 있다고 한다면
- ┣ 유저로서는 알 수 없음
- ┣ 고로 : HTTPS를 사용할 필요가 있음
- ┗ `SSL에는 인증이나 암화화, 다이제스트 기능을 제공함`

## 7.2 HTTP + 암호화 + 인증 + 완정성 보호 = HTTPS

### 7.2.1 HTTP에는 암호화와 인증과 완정성 보호를 더한 HTTPS

- HTTP 통신 : 암호화되지 않은 평문으로 실시됨
- ┣ 신용카드 번호 → 도청됨
- ┣ 통신 상대의 서버나 클라이언트 인증 수단이 없음
- ┗ 실제로는 의도한 통신 상대와 통신하고 있지 않을 가능성도 존재

- 이러한 문제를 해결하기 위해서는
- ┣ `암호화와 인증과 완정성 보호 같은 구조를`
- ┣ HTTP에 추가할 필요성이 있음
- ┗ `이를 HTTPS라고 부름`

- HTTPS 사용 :
- ┣ 1. https://
- ┗ 2. 자물쇠 표시

### 7.2.2 HTTPS는 SSL의 껍질을 덮어쓴 HTTP

- HTTPS : 새로운 애플리케이션 계층의 프로토콜이 아님
- ┣ HTTP 통신을 하는 소캣 부분을
- ┣ SSL(Secure Socket layer), TLS(Transport Layer Security)
- ┗ 라는 프로토콜로 대체하고 잇을 뿐임

| 애플리케이션 <br/> HTTP |
| ----------------------- |
| TCP                     |
| IP                      |

| 애플리케이션 <br/> HTTP |
| ----------------------- |
| SSL                     |
| TCP                     |
| IP                      |

- 보통 HTTP : 직접 TCP와 통신을 하지만
- ┣ SSL을 사용한 경우 : HTTP은 SSL과 통신하고
- ┣ SSL이 TCP와 통신하게 됨
- ┗ 즉 : SSL 이라는 껍질을 덮어쓴 HTTP가 HTTPS임

- SSL을 사용함으로써 HTTP :
- ┣ `암호화와 증명서와 완전성 보호를 이용가능`
- ┣ SSL : HTTP와는 독립된 프로토콜로
- ┣ HTTP만으로는
- ┣ `애플리케이션 계층에서 동작하는`
- ┗ `SMTP, Telnet 등에서도 이용가능`

### 7.2.3 상호간에 키를 교환하는 공개키 암호화 방식

- SSL을 설명하기 전에 암호화 방식에 대해서 설명
- ┣ `SSL : 공개키 암호화 방식이라 불리는 암호화 방식 채용`
- ┣ 현대의 암호 : 알고리즘이 공개되어 있고
- ┣ `키를 비밀에 부침으로써 안정성을 유지함`
- ┣ 암호화나 복호화에서 이 키를 사용하게 됨
- ┣ 키가 없으면 암호를 풀 수 없지만 키를 가지고 있으면
- ┗ 누구나 암호를 풀 수 있음

#### 공통키 암호의 딜레마

- 암호화와 복호화에 하나의 키를 같이 사용하는 방식을
- ┣ 공통키 암호라고 부름
- ┣ 공통키 암호화 방식 : 상대방에게 키를 넘겨주지
- ┣ 않으면 제대로 동작할 수 없음
- ┣ `네트워크를 통해 넘겨줄 때 도청 되면 암호화의 의미가 사라짐`
- ┗ 그리고 넘겨 받고도 안전하게 보관하려는 노력을 해야함

#### 두 개의 키를 사용하는 공개키 암호

- 공통키 암호의 문제를 해결하기 위해
- ┣ 공개키 암호화 방식이 등장
- ┣ `공개키 암호화 방식` :
- ┣ `서로 다른 두 개의 키 페어(쌍)을 사용함`
- ┣ 한쪽 : `비밀키(private key)`
- ┣ 다른 한쪽 : `공개키(public key)`
- ┗ 비밀키 : 누구에게도 알려져서는 안됨

- 공개키 암호를 사용한 암호화는
- ┣ `암호를 보내는 측` : `상대의 공개키를 사용해`
- ┣ `암호화를 진행하게 됨`
- ┣ 그리고 `암호화된 정보를 상대` :
- ┣ `자신의 비밀키를 사용해 복호화를 실시함`
- ┣ 이 방식 : 암호를 푸는 비밀키를 통신으로
- ┣ 보낼 필요가 없기 때문에
- ┗ 도청에 의한 키를 빼앗길 걱정이 없음

- 또한 : 암호문과 공개키라는 정보에서
- ┣ 평문을 구하는 것은 매우 어려운 수학적인 특징
- ┗ 그리 간단하지 않음

#### HTTPS : 하이브리드 암호 시스템

- HTTP : 공통키 암호화 공개키 암호의
- ┣ 양쪽 성질을 가진 하이브리드 암호 시스템임
- ┣ 키를 안전하게 교환할 수 만 있다면
- ┣ `공개키 암호만을 사용해서 통신을 해도 괜찮다고`
- ┣ 생각할 수 있겠지만 → `공개키 암호` :
- ┗ `공통키 암호에 비해서 처리 속도가 늦음`

- 여기서 두 가지 장점을 살릴 수 있도록
- ┣ 각각의 방식을 조합해서 통신함
- ┣ `키를 교환하는 곳` : `공개키 암호`를 사용
- ┣ `통신에서 메시지를 교환하는 곳` :
- ┗ `공통키 암호`를 사용

> 공개키 암호 : 공통키 암호보다 처리가 느림

    따라서 모든 통신에 공개키 암호
    ┣ 사용하는 것은
    ┗ 비효율적임

### 7.2.4 공개키가 정확한지 아닌지 증명하는 승명서

- 아쉽게도 공개키 암호에도 문제점이 존재함
- ┣ 문제점 : 공개키가 진짜인지 아닌지 증명 불가
- ┣ 이를 해결하기 위해 인증 기관(CA)와 그 기관이
- ┣ `발행하는 공개키 증명서가 이용되고 있음`
- ┣ 인증 기관 : 클라이언트, 서버가 모두 신뢰하는
- ┗ 제 3자의 기관 (EX : VeriSign)

- 인증 기관은 다음과 같이 이용됨
- ┣ 먼저 서버의 `운영자가 인증 기관에 공개키를 제출함`
- ┣ `인증 기관은 제출된 공개키에 디지털 서명을 하고`
- ┣ `서명이 끝난 공개키를 만듬`
- ┗ 공개키 인증서에 `서명이 끝난 공개키를 담음`

- 서버 : 이 인증 기관에 의해서
- ┣ `작성된 공개키 인증서를 클라이언트에`
- ┣ 보내고 `공개키 암호로 통신을 함`
- ┣ 공개키 인증서 : 디지털 증명서, (증명서)라고 부름
- ┣ 증명서를 받은 클라이언트 : 증명 기관의 공개키를
- ┣ 사용해서 서버의 공개키를 인증한 것이 진짜 인증기관,
- ┗ `서버의 공개키가 신뢰할 수 있다는 것을 확인 가능`

- 여기에서 사용되는 인증 기관의 공개키 :
- ┣ 안전하게 클라이언트에 전달되 않으면 않됨
- ┣ 통신 중에는 어떤 방법을 사용하더라도
- ┣ 안전하게 전달하는 것은 어렵기 때문에
- ┣ `많은 브라우저가 주요 인증기관의 공개키를`
- ┗ `사전에 내장한 상태로 제품을 내놓고 있음`

#### 조직의 실제성을 증명하는 EV SSL 증명서

- 증명서의 역할 : 서버가 올바른 통신 상대임을 증명
- ┣ `상대방이 실제로 있는 기업인지 확인하는 역할도 존재`
- ┗ 그러한 역할을 가진 증명서 : EV SSL 증명서
- `EV SSL 증명서` : 세계 표준의 인정 가이드라인에 의해
- ┣ 발행되는 증명서임
- ┣ 운영하는 조직의 실재성을 확인하는 방법을
- ┗ `엄격히 규정하고 있어 신뢰성 높일 수 있음`

- `브라우저의 주소창의 색이 녹색으로 변하면`
- ┣ EV SSL 증명서로 증명된 웹 사이트인 것을
- ┣ 시각적으로 알 수 있음
- ┣ 주소창 옆에는 SSL 증명성에 기재되어 있는
- ┗ 조직명 및 증명서를 발행한 인증 기관 명이 표시됨

> 이는 피시 사기 방지 의도

#### 클라이언트를 확인하는 클라이언트 증명서

- HTTPS에서는 클라이언트 증명성도 이용가능
- ┣ 클라이언트 증명서를 이요하여
- ┣ 서버 증명서와 같이 서버가 통신하고 있는 상대가
- ┗ 의도한 클라이언트임을 인증가능함

- 몇 가지 문제점 존재
- ┣ 1. `증명서의 입수와 배포`
- ┣ 유저가 클라이언트 증명서를 인스톨해야함
- ┣ `유료로 구입할 필요 → 유저 수 만큼 비용`
- ┣ `높은 비용을 들일 필요가 있는 곳에서만 이용`
- ┣ EX ) 은행 시스템
- ┣ 2. 어디까지나 클라이언트 실재를 증명할 뿐
- ┣ `사용자의 존재 유무를 증명하는 증명서는 아님`
- ┗ 컴퓨터 사용 권한을 가진 사람이라면 누구나 증명서 이용 가능

#### 인증 기관는 신용이 제일

- SSL 인증 관을 신용할 수 있다는 전재로 이러어짐
- ┣ `증명서를 무효화하는 증명서 취소 리스트(CRL)이라는`
- ┣ `구조나 루트 인증 기관을 클라이언트에서 삭제하는 대첵`
- ┗ 그러나 얼마나 많은 유저가 피해를 입을 지 알 수 없음

#### 자기 인증 기관 발행 증명서는 '나야 나' 증명서

- OpenSSL 등의 소프트웨어를 사용하면
- ┣ 누구든지 인증 기관을 구축하여 서버 증명서
- ┣ 발행이 가능함
- ┣ 이 서버 증명서 : 인터넷 상에 증명서로서
- ┣ 구실을 하지 못하기 때문에 쓸모가 없음
- ┣ 독자적 구축 인증 기관 : 자기 인증기관
- ┣ 이를 나야나 증명서라고 부름
- ┣ 자기 인증 기관이 발행한 서버 증명서가
- ┣ 필요가 없다는 점은 위장의 가능성을 불식할 수 없기 때문
- ┣ 자기 인증 기관이기 때문에
- ┗ 스스로 자칭하고 있는 상태가 됨

> 신뢰할 수 잇는 제 3자 기관이 인증하기 때문에
> 브라우저에서 내장된 인증 기관의 공개키가 가능하게 되고
> 그 서버의 증명이 가능해짐

### 7.2.5 안전한 통신을 하는 HTTPS의 구조

1. 클라이언트가 `Client Hello 메시지를 송신하면서`

- ┣ SSL 통신을 시작함
- ┣ 메시지에는 클라이언트가 제공하는
- ┣ 1. `SSL의 버전을 지정하고`
- ┣ 2. `암호 스위트(Cipher Suite)로 불리는 리스트`
- ┣ (사용하는 암호화의 아고리즘이나 키 사이즈)
- ┗ 등이 포함되어 있음

2. 서버가 SSL 통신이 가능한 경우에는

- ┣ `Server Hello 메시지로 응답함`
- ┣ 클라이언트와 같이 1. `SSL 버전`과
- ┣ 2. `암호 스위트를 포함함`
- ┣ 서버의 암호 스위트 내용은 :
- ┗ 클라이언트에서 받은 암호 스위트 내용에서 선택된 것

3. 서버가 Certificate 메시지를 전송함

- ┗ 메시지에는 공개키 증명서가 포함

4. 서버가 Sever Hello Done 메시지를 송신하여

- ┗ 최초의 SSL 네고시에시션 부분이 끝남을 통지

5. SSL의 최초 네고시에이션이 종료되면

- ┣ 클라이언트가 `Client Key Exchange 메시지로 응답함`
- ┣ 메시지에는 통신을 암호화 하는데 사용하는
- ┣ `Pre-Master secret`이 포함되어 있음
- ┣ 이 메시지에는 `3`의 공개키 증명서에서 꺼낸
- ┗ 공개키로 암호화 되어 있음

6. 클라이언트는 `Change Cipher Spec 메시지를 전송함`

- ┣ 이 메시지 : 이 메시지 이후의 통신은
- ┗ `암호키를 사용해서 진행한다는 것을 나타냄`

7. 클라이언트 : `Finished 메시지를 전송함`

- ┣ 이 메시지 : 접속 전체의 체크 값을 포함하고 잇음
- ┣ `네고시에션이 성공했는지 어떤지는`
- ┣ 서버가 이 메시지를 올바르게 `복호화 할 수 있는지`
- ┗ 아닌지가 결정됨

8. 서버 : `마찬가지로 Change Cipher Spec 메시지 송신`

9. 서버 : `마찬가지로 Finished 메시지를 전송`

10. `서버와 클라이언트 Finished 메시지 교환이 완료되면`

- ┣ SSL에 의해서 접속은 확립됨
- ┣ 물론 : `통신은 SSL에 의해서 보호되고 있음`
- ┣ `이제부터 애플리케이션 게층의 프로토콜에 의해`
- ┣ 통신을 함
- ┗ 즉 : HTTP 리퀘스트를 송신함

11. 애플리케이션 계층의 프로토콜에 의한 통신

- ┗ HTTP 리스폰스를 송신

12. 마지막에 클라이언트가 접속을 끊음

- ┣ 접속을 끊을 경우에는
- ┣ `close_notify` 메시지를 송신
- ┗ `TCP FIN` 메시지를 보내 → TCP 통신을 종료

- 이 흐름에 더하여 애플리케이션 계층의
- ┣ 데이터를 송신할 때는
- ┣ `MAC(Massage Authentication Code)라고 부르는`
- ┣ `메시지 다이제스트를 덧붙일 수 있음`
- ┣ MAC 이용 : 변조를 감지 가능해져서
- ┗ `완정성 보호를 실현할 수 잇음`

#### SSL과 TLS

- HTTPS : SSL, TLS라는 두개의 프로토콜 사용
- ┣ SSL 3.0 기반으로 한 TLS1.0 책정되어
- ┣ TLS1.1, TLS1.2가 존재함
- ┗ 현재 : `SSL3.0, TLS1.0` 주로 사용함

#### SSL은 느리다?

- HTTPS에도 문제는 있음
- ┗ `처리 속도가 느려짐`

- SSL 통신 지연 이유 2가지 존재
- ┣ 1. `통신 속도가 떨어지는 것`
- ┗ 2. `CPU 메모리 등의 리소스를 다량 소비`

- 네트워크의 부하 : HTTP를 사용하는 경우에 비해
- ┣ 2배에서 100배 정도 느려질 수 있음
- ┣ TCP 접속과 TTP request/response 이외에
- ┗ `SSL에 필요한 통신이 추가되어 통신량 증가`

- SSL : 반드시 암호화 처리를 하고 있기 때문에
- ┣ `서버나 클라이언트 에서는 암호화, 복호화를 위한 계산`
- ┗ 그렇기 때문에 `서버나 클라이언트의 리소스를 소비하여 느려짐`

- 느려지는 것에 대한 근본적인 해결 방법은 없음
- ┣ `SSL 엑셀레이터라는 하드웨어(appliance서버)를 사용해서`
- ┣ 이 문제를 해결하기도 함
- ┣ 위는 : SSL을 처리하기 위한 전용 하드웨어로
- ┣ 소프트웨어를 사용하여 SSL 처리할 때 보다
- ┗ 몇 배 빠른 계산이 가능
