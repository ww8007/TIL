# 25. 일련 번호와 확인 응답 번호의 구조

- 3-way 핸드셰이크 이후 데이터 전송에 사용되는
- ┣ TCP 헤더의 일련번호와
- ┗ 확인 응답 번호에 대해서 학습

## 25.1 일렵번호와 확인 응답 번호란?

- 24장에서 배웠듯 3-way 핸드 셰이크에 대해서 학습
- ┣ 실제 데이터를 보내거나 + 상대방이 받을 때(핸드 셰이크 끝)
- ┗ TCP 헤더 : `일련 번호`, `확인 응답 번호 사용`하게 됨

- TCP : `데이터를 분할해서 전송`
- ┣ 일련 번호 : 송신 측에서 수신측에
- ┣ 이 데이터가 `몇번째 데이터` 인지 알려줌
- ┣ 전송된 데이터에 `일련 번호를 부여` →
- ┣ 수신자 : 원래 데이터의 `몇 번째 데이터`를
- ┗ `전송 받았는지` 확인 가능

> 일련번호 : 순서, 연속된 번호를 의미하게 됨

- 확인 응답 번호 : 수신 측 →
- ┣ 몇 번째 데이터를 수신햇는지 수신측에 알려주는 역할
- ┣ 다음 번호의 데이터를 요청하는데 사용됨
- ┗ ex ) 10번째 사용 → 11번째 데이터 전송

- EX ) 일련번호 3001 : 지금 보내는 200 바이트 데이터의
- ┣ `첫 번째 바이트의 번호`
- ┣ 확인 응답 번호 : 다음에 보냈으면 하는
- ┗ `데이터의 첫 번째 바이트 번호`가 됨

> 일련번호 : 계속 같은 걸 사용
> 확인 응답 번호 : 다음에 받을걸 지정

- TCP의 특징으로 데이터가 항상 올바르게 전달되는 것은
- ┣ 아니므로 `일련번호`와 `확인 응답 번호를 사용`해서
- ┣ 데이터가 손상되거나 유실된 경우에 데이터를
- ┣ 재전송 하도록 설정이 되어 있음
- ┗ 이를 : `재전송 제어`라고 함

## 25.2 윈도우 크기란?

- 바로 전 데이터 : 세그먼트(데이터) 하나 전송마다
- ┣ 확인 응답을 한 번 반환하는 통신이였음
- ┣ 효율이 높은 편이 아님
- ┣ → `세그먼트 연속해서 보내고` `확인 응답을 반환`하면
- ┗ `효율이 높아`지게 됨

> 이렇게 되면 세그먼트가 계속 쌓일 것이 염려가 됨

    이를 방지하기 위해서 버퍼(buffer) 존재
    ┗ 세그먼트를 일시적으로 보관하는 장소

- 버퍼의 사용으로 세그먼트를 연속해서 전송해도
- ┣ 1. `수신측에 대응`이 가능하고
- ┗ 2. 확인 응답의 `효율도 높아`지게 됨

- 그러나 : 수신측에 데이터가 방대하게 들어오면
- ┣ 넘쳐버리게 되는 `오버플로(overflow)` 발생
- ┗ 고로 → 버퍼의 한계 크기를 알고 있어야 함

> 이를 담당하는 것을 : 윈도우 크기(window size)

    얼마나 많은 용량의 데이터를 저장 가능한지
    ┣ 나타내는 것임
    ┣ 확인 응답을 일일이 하지 않고
    ┗ 연속해서 송/수신 가능한 크기

- 윈도우 크기 초기값 : `3-way 핸드셰이크`를
- ┣ 처음 진행할 때 판단하게 됨
- ┗ `연결 확립` : `상대방의 윈도우 크기 알아냄`

> 연속적인 세그먼트 송신 후 → 확인 응답이 이루어짐

## 25. 정리

1. 3-way 핸드셰이크 이후 데이터를 전송할 때는

- `TCP 헤더의 일련번호`와, `확인 응답 번호`가 사용됨

2. 데이터를 재전송하는 것을 `재전송 제어`라고 함

3. 수신한 세그먼트(데이터)를 일시적으로 저장하는 장소

- ┗ `버퍼(buffer)`

4. 데이터 크기 : 버퍼 크기를 넘어서는 것 : `오버플로`

5. 버퍼 용량의 크기를 `윈도우 크기`라고 함
