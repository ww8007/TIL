# 2. 리펙터링 원칙

## 목차

- [2. 리펙터링 원칙](#2-%EB%A6%AC%ED%8E%99%ED%84%B0%EB%A7%81-%EC%9B%90%EC%B9%99)
  - [2.1 리팩터링 정의](#21-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%A0%95%EC%9D%98)
  - [2.2 두 개의 모자](#22-%EB%91%90-%EA%B0%9C%EC%9D%98-%EB%AA%A8%EC%9E%90)
  - [2.3 리팩터링하는 이유](#23-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)
    - [리팩터링하는 소프트웨어 설계가 좋아짐](#%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%ED%95%98%EB%8A%94-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%84%A4%EA%B3%84%EA%B0%80-%EC%A2%8B%EC%95%84%EC%A7%90)
    - [리팩터링하면 소프트웨어를 이해하기 쉬워짐](#%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%ED%95%98%EB%A9%B4-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EC%89%AC%EC%9B%8C%EC%A7%90)
    - [리팩터링하면 버그를 쉽게 찾을 수 있음](#%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%ED%95%98%EB%A9%B4-%EB%B2%84%EA%B7%B8%EB%A5%BC-%EC%89%BD%EA%B2%8C-%EC%B0%BE%EC%9D%84-%EC%88%98-%EC%9E%88%EC%9D%8C)
    - [리팩터링하면 프로그래밍 속도를 높힐 수 있음](#%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%ED%95%98%EB%A9%B4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%86%8D%EB%8F%84%EB%A5%BC-%EB%86%92%ED%9E%90-%EC%88%98-%EC%9E%88%EC%9D%8C)
  - [2.4 언제 리팩터링해야 할까?](#24-%EC%96%B8%EC%A0%9C-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C)
    - [준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기](#%EC%A4%80%EB%B9%84%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%89%BD%EA%B2%8C-%EC%B6%94%EA%B0%80%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0)
    - [이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기](#%EC%9D%B4%ED%95%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EC%89%BD%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0)
    - [쓰레기 줍기 리팩터링](#%EC%93%B0%EB%A0%88%EA%B8%B0-%EC%A4%8D%EA%B8%B0-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81)
    - [계획된 리팩터링과 수시로 하는 리팩터링](#%EA%B3%84%ED%9A%8D%EB%90%9C-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%EA%B3%BC-%EC%88%98%EC%8B%9C%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81)
    - [오래 걸리는 리팩터링](#%EC%98%A4%EB%9E%98-%EA%B1%B8%EB%A6%AC%EB%8A%94-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81)
    - [코드 리뷰에 리팩터링 활용하기](#%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0%EC%97%90-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0)
    - [관리자에게 뭐라고 말해야할까?](#%EA%B4%80%EB%A6%AC%EC%9E%90%EC%97%90%EA%B2%8C-%EB%AD%90%EB%9D%BC%EA%B3%A0-%EB%A7%90%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C)
    - [리팩터링하지 말아야 할 때](#%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%ED%95%98%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-%EB%95%8C)
  - [2.5 리팩터링 시 고려할 문제](#25-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%8B%9C-%EA%B3%A0%EB%A0%A4%ED%95%A0-%EB%AC%B8%EC%A0%9C)
    - [코드 소유권](#%EC%BD%94%EB%93%9C-%EC%86%8C%EC%9C%A0%EA%B6%8C)
    - [브랜치](#%EB%B8%8C%EB%9E%9C%EC%B9%98)
    - [테스팅](#%ED%85%8C%EC%8A%A4%ED%8C%85)
    - [레거시 코드](#%EB%A0%88%EA%B1%B0%EC%8B%9C-%EC%BD%94%EB%93%9C)
    - [데이터베이스](#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)
  - [2.6 리팩터링, 아키텍처, 애그니(YAGNI)](#26-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%95%A0%EA%B7%B8%EB%8B%88yagni)
  - [2.7 리팩터링과 소프트웨어 개발 프로세스](#27-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%EA%B3%BC-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)
  - [2.8 리팩터링과 성능](#28-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%EA%B3%BC-%EC%84%B1%EB%8A%A5)
  - [2.10 리팩터링 자동화](#210-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%9E%90%EB%8F%99%ED%99%94)

## 2.1 리팩터링 정의

- 명사나 동사로 쓸 수 있음

> 명사

    소프트웨어의 겉보기 동작은
    ┣ 그대로 유지한 채
    ┣ 코드를 이해하고 수정하기
    ┣ 쉽도록 내부 구조를 변경하는 기법

- 앞서 `함수 추출하기`
- ┣ 조건부 `로직을 다형성으로 바꾸기` 처럼
- ┣ 이름 붙은 리팩터링 기법들이
- ┣ 이 정의에 해당

> 동사

    소프트웨어의 겉보기 동작은
    ┣ 그대로 유지한 채
    ┣ 여러 가지 리팩터링 기법을
    ┣ 적용해서 소프트웨어 재구성

- 정의에 따르면 특정한 방식에 따라
- ┣ 코드를 정리하는 것만이 리팩터링임
- ┣ 리팩터링 : 결국 `동작을 보존`하는
- ┣ `작은 단계`들을 거쳐 `코드를 수정`하고
- ┣ 이러한 단계들을 `순차적으로 연결`하여
- ┣ `큰 변화를 만들어내는 것`

- 리팩터링 하는 동안에는 코드가
- ┣ 항상 정상 작동하기 때문에
- ┣ 전체 작업이 끝나지 않았더라도
- ┣ 언제든 멈출 수 있음

- `코드베이스를 정리`하거나 `구조를 바꾸는`
- ┣ 모든 작업을 `재구성`이라는 포괄적인 용어로 표현
- ┣ `리팩터링` : `재구성 중 특수한 형태를 봄`

- 리팩터링 : 겉보기 동작이라는 말을 사용
- ┣ 리팩터링 전과 후의 코드가
- ┣ 똑같이 동작해야 한다는 뜻임
- ┣ 1. `함수 추출하기`를 거치면 콜스택이 달라짐
- ┣ 그러나 사용자 관점에서는 같아야 함
- ┣ 2. `함수 선언 바꾸기`, `함수 옮기기`
- ┣ 모듈의 인터페이스가 바뀔 때 많음

- 리팩터링 : 성능 최적화와 비슷
- ┣ `코드를 변경`하지만 프로그램의 전반적
- ┣ 기능은같음

> 성능 최적화

    무조건 최적화가 목적
    ┣ 코드가 어려워 지는걸 고려 X

## 2.2 두 개의 모자

- 소프트웨어 개발
- ┣ 목적 : 1. 기능 추가
- ┣ 2. 리팩터링인지 명확히 구별

> 이를 켄트 벡 : 두개의 모자에 비유

- 기능을 추가 : 기능 추가에만 몰두
- ┣ 리팩터링 : 코드 재구성만 전념

> 작업에 더욱 몰두 가능

## 2.3 리팩터링하는 이유

- 모든 문제점을 해결하는 `만병통치약이 아님`
- ┣ `코드를 건강한 상태로 유지` 도움

### 리팩터링하는 소프트웨어 설계가 좋아짐

- 리팩터링하지 않으면 소프트웨어의
- ┣ `내부 설계(아키텍처)가 썩기 쉬움`
- ┣ `규칙적인 리팩터링은 코드의 구조를 지탱`

- 코드의 양이 줄어들면 수정하는 데 드는
- ┣ 노력은 크게 달라짐
- ┣ `중복 코드를 제거`하면 모든 코드가
- ┣ `언제나 코유한 일을 수행함을 보장 가능`
- ┣ 이는 `바람직한 설계의 핵심`

### 리팩터링하면 소프트웨어를 이해하기 쉬워짐

- `누구나 읽기 쉬운 코드를 작성`
- ┣ 문제점 : 프로그램을 `동작시키는 데만`
- ┣ 신경을 쓰다 보니 나중에 그 코드를 다룰 개발자를
- ┣ `배려하지 못하는 데 있음`
- ┣ 잘 동작 하지만 이상적인 구조가 아닌 코드가 있다면
- ┣ 이를 시간 내서 리팩터링 하는 것이 좋음

> 내 의도를 더 명확하게 전달

    코드의 목적이 잘 드러나게

### 리팩터링하면 버그를 쉽게 찾을 수 있음

- 코드를 이해하기 쉽다는 말 :
- ┣ `버그를 찾기 쉬움`
- ┣ 견고한 코드를 작성하는데 무척 효과적

### 리팩터링하면 프로그래밍 속도를 높힐 수 있음

- 리팩터링이 오히려 더 시간을 잡아먹지 않나에 대한
- ┣ 우려를 할 수 있음
- ┣ 하지만 추후 기능 추가에 대해서
- ┣ 이는 우려임

> 잘 짜여진 코드

    새 기능 구축을 돕는
    ┣ 견고한 토대가 됨

## 2.4 언제 리팩터링해야 할까?

- 3의 법칙
- ┣ 1. 처음에는 그냥 한다
- ┣ 2. 비슷한 일을 두번째로 하게 되면 일단 진행
- ┣ 3. 비슷한 일을 세번 하면 리팩터링함

> 3진아웃

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

- 리팩터링하기 가장 `좋은 시점` :
- ┣ `코드베이스에 기능을 새로 추가하기 직전`
- ┣ 이 시점에 현재 코드를 살펴 보며
- ┣ 중복 코드를 제거하는 것이 좋음

- `버그`를 잡을 때도 마찬가지
- ┣ `중복 코드`가 많으면
- ┣ `고쳐야 할 부분이 많음`

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

- 코드를 수정하려면 먼저 그 코드가 하는 일 파악
- ┣ 리팩터링하면 머리로 이해한 것을
- ┣ 코드에 옮겨 담을 수 있음
- ┣ `한눈에 구조적으로 담기 쉬워짐`

### 쓰레기 줍기 리팩터링

- 한 번에 모든것을 하려하지 말고
- ┣ `시간이 걸리는 작업이면 나중에 메모하고 처리`
- ┣ 이를 이해를 위한 리팩터링의 변형인
- ┣ `쓰레기 줍기 리팩터링`이라 함

### 계획된 리팩터링과 수시로 하는 리팩터링

- 앞선 리팩터링들은 모두 기회가
- ┣ 될 때 진행함

> 명언

    보기 싫은 코드를 발견하면 리팩터링 하자
    ┣ 잘 작성된 코드 역시 수많은 리팩터링을
    ┣ 거쳐야 함

- 소프트웨어 개발이 추가만 있는 것이 아닌
- ┣ `수정 하는 것이 오히려 추가의 도움을 줄 수 있음`

### 오래 걸리는 리팩터링

- 오래 걸리는 리팩터링도 존재함
- ┣ `주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이`
- ┣ `효과적일 때가 많음`
- ┣ 누구든지 리팩터링해야할 코드와 관련된
- ┣ 작업을 하게 될 때마다 `원하는 방향으로 개선`
- ┣ 기존 코드가 이 추상 인터페이스를 호출하도록
- ┣ 만들고 나면 라이브러리를 더 쉽게 교체 가능

### 코드 리뷰에 리팩터링 활용하기

- 다른 이의 코드를 리뷰하는 데도 도움
- ┣ 새로운 아이디어가 떠오르면
- ┣ `리팩터링하여 쉽게 구현이 가능`한지
- ┣ 내가 떠올린 아이디어를 실제로 적용했을 때의
- ┣ `모습을 더 명확하게 볼 수 있음`

### 관리자에게 뭐라고 말해야할까?

- 잘 설명이 안되면 그냥 말하지 말라
- ┣ 리팩터링을 해야 좀 더 기능 추가가 쉬워짐
- ┣ 이를 잘 생각

### 리팩터링하지 말아야 할 때

- 리팩터링 하면 안되는 상황도 존재
- ┣ `내부 동작을 제대로 이해해야 할 시점`에
- ┣ `리팩터링해야 효과`를 제대로 볼 수 있음

- 코드를 새로 작성하는 것이
- ┣ 더 도움이 되는 경우 리팩터링 x

## 2.5 리팩터링 시 고려할 문제

1. 새 기능 개발 속도 저하

- ┣ 리팩터링의 궁극적인 목적은
- ┣ 개발 속도를 높여서
- ┣ 더 적은 노력으로 더 많은 가치를 창출

- ┣ 준비를 위한 리팩터링을 하면
- ┣ 변경을 훨씬 쉽게 할 수 있음

- 가장 `위험한 오류`
- ┣ 리팩터링은 `클린 코드`나
- ┣ `바람직한 엔지니어링 습관`처럼
- ┣ `도덕적인 이유로 정당화` 하는 것
- ┣ `오로지 경제적인 이유로 하는 것임`
- ┣ `개발 기간을 단축`, `기능 추가 시간 줄이고`
- ┣ 버그 수정 시간을 줄여줌

### 코드 소유권

- 코드 소유권이 나뉘어져 있으면
- ┣ 리팩터링에 독이 됨
- ┣ 고로 코드 소유권을 느슨하게 하는 것이
- ┣ 좋은 방법 중 하나임

### 브랜치

- 브랜치 방식에 단점도 존재
- ┣ 기간이 길어질수록
- ┣ `작업 결과를 마스터로 통합하기가 어려움`

- 머지가 복잡해 지는 문제는
- ┣ 기능별 브랜치들이 독립적으로 개발되는
- ┣ 기간이 길어질수록 기하급수적으로 늘어남
- ┣ 통합 주기를 단축 시키는 것이 좋음

- 이 방식 : `지속적 통합(Continuous Integration)` `CI`
- ┣ 또는 `트렁크 기반 개발(Trunk-Based-Development)` `TBD`
- ┣ CI에 따르면 하루에 최소 한 번 마스터와 통합
- ┣ 마스터를 건강하게 유지 하는 것이 중요함

- CI의 경우 리팩터링과 궁합이 좋음
- ┣ 함수 이름을 바꾸는 경우가 이러한 예임
- ┣ 켄트 벡이 CI와 리팩터링을 합쳐서
- ┣ `익스트림 프로그래밍(eXtreme Programming)` 만든 이유
- ┣ 두 기법의 궁합이 잘 맞기 때문

### 테스팅

- 리팩터링의 두드러진 `특성` :
- ┣ 프로그램의 겉보기 동작은 똑같이 유지됨
- ┣ `동작이 깨지지 않도록 하는 것이 중요`

- ┣ 오류가 생기면 빨리 잡아야 함
- ┣ 다양한 측면을 검사하는 `테스트 스위트(test suite) 필요`

### 레거시 코드

- 프로그래밍 관점에서 레거시 코드는
- ┣ 별로 좋은 것이 아님
- ┣ `처음부터 테스트 코드를 작성하고`
- ┣ 시작해야 `개발 속도를 더욱 높힐 수 있음`

### 데이터베이스

- `진화형 데이터베이스 설계`와
- ┣ `데이터베이스 리팩터링 기법`은
- ┣ 데이터베이스 리팩터링을 더욱 쉽게 해줌

- 간단하게 필드(열)의 이름을 변경 가정
- ┣ 함수 선언 바꾸기에 따르면 데이터 구조의
- ┣ 원래 선언과 이 데이터 구조를 호출하는
- ┣ 코드를 모두 변경해야 함
- ┣ 고로 선언된 데이터 구조나
- ┣ 접근 루틴을 변경하는 코드와 함께
- ┣ 버전 관리 시스템에 저장

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

- 리팩터링 : 아키텍처에 미치는 실질적인 효과
- ┣ 요구사항 변화에 자연스럽게 대응하도록
- ┣ 코드베이스를 잘 설계해준다는 데 있음

- ┣ 코딩 전에 아키텍처 확정
- ┣ 대표적인 문제는 소프트웨어
- ┣ 요구사항을 모두 알아야 함
- ┣ 그러나 실제 사용후 원하는 바를 알게 하는 경우가 허다

- 한 가지 방법 : 유연성 메커니즘
- ┣ 함수를 정의하다 보면 범용적으로 사용가능 생각
- ┣ 매개변수를 추가하는 경우가 있음
- ┣ 그러나 매개변수를 늘려가면
- ┣ 함수가 복잡해짐
- ┣ 모든 상황으로 고려하면
- ┣ 변화에 대응하는 능력이 줄어듬

- 그러나 리팩터링의 경우 :
- ┣ 한가지 요구사항에 목적을 둠

- 호출하는 측에서 항상 같은 넘기는 매개변수
- ┣ 매개변수 목록에 넣지 않음
- ┣ 그러다 매개변수를 추가해야 할 시점이 오면
- ┣ 간단한 리팩터링 기법인 함수 매개변수화하기로 해결
- ┣ 예상되는 변경을 미리 반영하는 리팩터링을 미루면
- ┣ 훨신 힘들어짐

- 이런식으로 설계하는 방식을
- ┣ `간결한 설계(simple design)`
- ┣ `점진적 설계(increments design)`
- ┣ `YAGNI(you aren't going to need it)`
- ┣ 나중에 문제를 더 깊이 이해 했을 때
- ┣ 처리하는 쪽도 도움됨

## 2.7 리팩터링과 소프트웨어 개발 프로세스

- 리팩터링이 퍼지게 된 것
- ┣ 리팩터링 시스템이 도입
- ┣ 지속적 통합, 자가 테스트 코드
- ┣ 리팩터링등의 개성이 강해지면서
- ┣ 상호 의존하는 기법들을 하나로 묶은 프로세스
- ┣ 이를 묶어서 TDD

- 최초의 애자일 소프트웨어 방법론 중
- ┣ XP는 애자일의 부흥
- ┣ 애자일을 제대로 적용하기 위해서는
- ┣ 팀의 역량과 열정이 뒷받침

- 리팩터링의 첫 번째 토대는 자가 테스트 코드

## 2.8 리팩터링과 성능

- 성능 무시의 이유 :
- ┣ 설계의 순수성을 우선시
- ┣ 조만간 더 빠른 하드웨어
- ┣ 리팩터링 하면
- ┣ `성능을 튜닝하기는 더 쉬워짐`
- ┣ `하드 리얼타임(hard real-time)시스템`을 제외한
- ┣ 소포트웨어를 빠르게 만드는 비결
- ┣ `튜닝을 쉽게 → 속도를 빠르게`

> 빠른 소프트웨어를 작성하는 방법

- 1. `시간 예산 분배(time budgeting)`
- ┣ 가장 엄격한 방법
- ┣ 하드 리얼타임 시스템에 많이 사용
- ┣ 이 방식에 따르면 설계를 여러 컴포터트로 나눠
- ┣ `컴포넌트마다 자원(시간과 공간) 예산을 할당`
- ┣ 컴포넌트 : 할당된 자원과 예산을 초과 불가
- ┣ 단 : `주어진 자원을 주고받는 메커니즘을 가능`

- 2. `끊임없는 관심 기울이기`
- ┣ 그러나 효과가 없는 경우가 많음
- ┣ 컴파일러와 런타임 하드웨어의 동작을
- ┣ 제대로 이해하지 못한 채 작성하는 경우가 많음

- 프로파일러로 프로그램을 분석하여
- ┣ 시간과 공간을 많이 잡아먹는 지점을 알아냄
- ┣ `성능에 영향을 많이 미치는 부분부터 수정`

## 2.10 리팩터링 자동화

- 리팩터링과 관련하여 리팩터링을 지원하는
- ┣ 도구가 등장한 것

- 리팩터링을 자동화하는 가장 어설픈 방법
- ┣ 소스 코드의 텍스트를 직접 조작하는 것
