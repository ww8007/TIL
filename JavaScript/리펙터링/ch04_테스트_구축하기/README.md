# 4. 테스트 구축하기

- `리팩터링`은 분명 가치 있는 도구이지만
- ┣ 그것만으로는 부족함
- ┣ 리팩터링을 `제대로 하기 위해`서는
- ┣ 불가피하게 저지르는 실수를 잡아주는
- ┗ `테스트 스위트(test suite)`가 뒷받침돼야 함

- 단점으로 보일 수 있지만 이는 `단점이 아님`
- ┣ 리팩터링을 하지 않더라도 `좋은 테스트를 작성하는 것`
- ┗ 이는 `개발 효율을 높혀줌`

## 목차

- [4. 테스트 구축하기](#4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0)
  - [4.1 자가 테스트 코드의 가치](#41-%EC%9E%90%EA%B0%80-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%9D%98-%EA%B0%80%EC%B9%98)
  - [4.2 테스트할 샘플 코드](#42-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%A0-%EC%83%98%ED%94%8C-%EC%BD%94%EB%93%9C)
  - [4.3 첫 번째 테스트](#43-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8)
  - [4.4 테스트 추가하기](#44-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0)
  - [4.5 픽스처 수정하기](#45-%ED%94%BD%EC%8A%A4%EC%B2%98-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0)
  - [4.6 경계 조건 검사하기](#46-%EA%B2%BD%EA%B3%84-%EC%A1%B0%EA%B1%B4-%EA%B2%80%EC%82%AC%ED%95%98%EA%B8%B0)
  - [4.7 끝나지 않은 여정](#47-%EB%81%9D%EB%82%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%97%AC%EC%A0%95)

## 4.1 자가 테스트 코드의 가치

- 프로그래미들이 코드를 작성하는 시간의 비중은
- ┣ 그렇게 크지 않음을 알수 있음
- ┣ `대부분의 시간은 디버깅`에 씀
- ┣ `버그 수정 자체는 대체로 금방 끝남`
- ┣ 진짜 끔찍한 것은 `버그를 잡는 과정`

> 모든 테스트를 완전히 자동화 하고 그 결과까지 스스로 검사

> 테스트 스위트는 강력한 버그 검출 도루고 버그를 찾는 시간을 줄여줌

- `테스트를 작성하기 가장 좋은 시점` :
- ┣ 프로그래밍을 `시작하기 전`임
- ┣ `기능을 추가`해야 할 때 테스트 부터 작성
- ┣ 테스트를 작성하다보면 `원하는 기능을 추가하기 위해`
- ┣ `무엇이 필요한지` 고민하게 됨
- ┣ `구현보다 인터페이스에` 집중하게 된다는 장점도 존재
- ┣ 게다가 코딩이 완료되는 시점을 정확하게
- ┣ 판단이 가능해짐
- ┗ `테스트를 모두 통과한 시점이 바로 코드를 완성한 시점임`

- 켄트 벡은 이처럼 테스트부터 작성하는 습관을 바탕으로
- ┣ `테스트 주도 개발(Test-Driven Development)` `TDD`라는 기법을 창시
- ┣ 1. `처음에는 통과하지 못할 코드를 작성`
- ┣ 2. 이 `테스트를 통화하게끔 코드를 작성`
- ┣ 3. `결과 코드를 최대한 깔끔하게 리팩터링`
- ┣ 이 과정을 `짧은 주기`로 반복하게 됨
- ┣ 이러한 `테스트 - 코딩 - 리팩터링` 과정을
- ┣ 한 시간에도 여러 차례 진행하기 때문에
- ┣ 코드를 대단히 생산적이면서도 차분하게 작성이 가능함

## 4.2 테스트할 샘플 코드

- UI를 보면 이 스포트웨어의 전반적인 기능을 파악 가능함
- ┣ 여기서는 비즈니스 로직을 집중해서 살펴봄
- ┣ 다시 말해 수익과 생산 부족분을 계산하는
- ┣ 클래스들만 살펴보고
- ┣ HTML을 생성하고 필드 값 변경에 반응하여
- ┣ 비즈니스 로직을 적용하는 코든느 생략
- ┣ 이 장의 목적은 어디까지나 `자가 테스트 코드 작성법`
- ┣ 을 파악하는데 있음

- 비즈니스 로직 코드는 클래스 두 개로 구성됨
- ┣ 1. 생산자를 표현하는 Producer이고
- ┣ 2. 다른 하나는 지역 전체를 표현하는 Province임
- ┣ Province 생성자는 JSON 문서로부터 만들어진
- ┣ JS 객체를 인수로 받음

## 4.3 첫 번째 테스트

- 이코드를 테스트 하기 위해서는 먼저
- ┣ 테스트 프레임워크를 마련해야 함
- ┣ 시중에는 다양한 프레임워크가 존재
- ┣ JS 용으로 나온 것만 해도 여러 개
- ┣ 여기서는 `모카(Mocha)를 사용`

> 생산 부족분을 제대로 계산하는지 확인하는 테스트

```js
import { Producer, Province, sampleProvinceData } from './ex.js';
import assert from 'assert';
describe('province', function () {
	it('shortfall', function () {
		const asia = new Province(sampleProvinceData());
		assert.equal(asia.shortfall, 5);
	});
});
```

- 모카 프레임워크는 테스트 코드를
- ┣ `블록 단위로 나눠서 각 블록에 테스트`
- ┣ `스위트를 담는 구조`임
- ┣ `테스트`는 `it 블록`에 담김
- ┣ 앞의 예에서는 `테스트를 두 단계로 진행했음`
- ┣ 1. 테스트에 필요한 데이터와 객체를 뜻하는 `픽스처(fixture)를 설정`
- ┣ 이 예시 샘플 지역 정보루터부터 생성한 Province 객체를 픽스처로 설정
- ┣ 2. 이 `픽스처의 속성들을 검증`
- ┣ 여기서는 주어진 초기값에 기초하여 `생산 부족문을 정확히 계산했는지 확인`

> describe it 설명

- `describe 블록과 it 블록에 부연 설명용`
- ┣ `문자열을 써넣는 방식`은 개발자 마다 다름
- ┣ 테스트가 무엇을 검사하는지를 설명해 넣는 사람이 있고
- ┣ 비워두는 사람도 존재함
- ┣ 필자는 테스트가 무엇인지 식별할 수 있을 정도로 작성

> 실패해야 할 상황에는 반드시 실패하게 만들자

- 지금처럼 기존 코드를 검증하는 테스트를 작성했고
- ┣ 모두 통과했다는 것은 좋은 일임
- ┣ 하지만 `테스트가 내 의도와는 다른 방식으로`
- ┣ 코드를 다루는 건 아닌지 확인해야 함
- ┣ `일시적으로 다른 코드를 주입하는 것`

```js
// Province 클래스
get shortfall() {
    return this._demand - this.totalProduction * 2;
}
```

> 자주 테스트 하기

    최소한 몇 분 간격으로 테스트 하고
    ┣ 적어도 하루에 한 번은 전체 테스트
    ┣ 돌려보는 습관

- 모카 프레임워크에서는 `어서션(단위, 확언)`
- ┣ 라이브러리라고 하는 `픽스처 검증 라이브러리를`
- ┣ 선택해 사용할 수 있음
- ┣ 여기서는 `차이(Chai) 라이브러리`를 사용
- ┣ 차이를 사용하면 `assert 문을 이용해 코드를 검증 가능`

> assert, expect

```js
assert.equal(asia.shortfall, 5);
expect(asia.shortfall).equal(5);
```

## 4.4 테스트 추가하기

- 계속해서 테스트를 더 추가
- ┣ 이번에는 클래스가 하는 일을 모두 살펴보고
- ┣ `각각의 기능에서 오류가 생길 수 있는 조건을`
- ┣ `하나씩 테스트`하는 식으로 진행
- ┣ 일부 프로그래머들이 선호하는
- ┣ public 메서드를 빠짐없이 테스트하는 방식돠는 다름
- ┣ 테스트는 위험 요인을 중심으로 작성해야 함
- ┣ 테스트의 목적인 어디까지나 `현재 혹은 향후에 발생하는데`
- ┣ `발생하는 버그를 찾는데 있음`
- ┣ 따라서 단순히 필드를 읽고 쓰기만 하는 접근자의 경우
- ┣ 테스트의 필요가 없음
- ┣ 너무 단순해서 버그가 숨어들 가능성도 별로 없음

> 완벽하게 만드느라 테스트를 수행하지 못하느니
> 불완전한 테스트라도 작성해서 실행하는 게 낫다

```js
import { Producer, Province, sampleProvinceData } from './ex.js';
import { expect } from 'chai';
describe('province', function () {
	const ais = new Province(sampleProvinceData()); // 이렇게 하면 안됨
	it('shortfall', function () {
		expect(asia.shortfall).equal(5);
	});
	it('profit', function () {
		expect(asia.profit).equal(230);
	});
});
```

- 위와 같이 작성하면 안됨
- ┣ 일시적인 효과는 있겠지만
- ┣ 테스트 관련 버그 중 가장 지저분한 유형인
- ┣ 테스트끼리 상호작용하게 하는 `공유 픽스처를 생성함`
- ┣ JS에서 const 키워는 asia 객체의 내용이 아니라
- ┣ `asia가 가르키는 참조가 상수임을 뜻함`
- ┣ 나중에 다른 테스트에서 이 공유 객체의 값을
- ┣ `수정하게 되면 다른 테스트가 실패 할 수 있음`

> 고로 사용법

```js
import { Producer, Province, sampleProvinceData } from './ex.js';
import { expect } from 'chai';
describe('province', function () {
	let asia;
	this.beforeEach(function () {
		asia = new Province(sampleProvinceData());
	});
	it('shortfall', function () {
		expect(asia.shortfall).equal(5);
	});
	it('profit', function () {
		expect(asia.profit).equal(230);
	});
});
```

- `beforeEach 구문` :
- ┣ `각각의 테스트 바로 전에 실행`되어
- ┣ `asia를 초기화` 하기 때문에
- ┣ 모든 테스트가 자신만의 `새로운 asia를 사용`하게 됨
- ┣ 이처럼 개별 테스트를 실행할 때마다 `픽스처를 새로 생성하여`
- ┣ 모든 테스트를 `독립적으로 구성할 수 있어서`
- ┣ 결과를 예측할 수 없어 골치를 썩는 사태 예방

- 그러면 매번 픽스처를 생성하느라
- ┣ `테스트가 느려지지 않나요? 질문` 가능함
- ┣ 하지만 `눈에 띄게 느려지는 경우는 거의 없음`
- ┣ 정말 `문제가 될 때는 공유 픽스처를 사용하지만`
- ┣ 대부분의 경우 픽스처 값을 변경하지 못하도록 설정함
- ┣ `불변임이 확실한 픽스처는 공유도 가능함`
- ┣ 가장 선호하는 방식은 `매번 새로운 픽스처를 만드는 것임`
- ┣ 공유 픽스처를 사용하다 디버깅 오류가 더 힘듬

- 테스마다 `beforeEach 구문이 실행된다면`
- ┣ 그 안의 `코드를 각각의 it 블록에 넣으면 되지 않냐고`
- ┣ 질문이 가능함
- ┣ 테스트들에서 `모두 똑같은 픽스처에 기초하여`
- ┣ `검증을 수행하기를 바람`
- ┣ 그래야 표준 픽스처에 익숙해져서 테스트할 속성을
- ┣ 다양하게 찾아낼 수 있음
- ┣ `beforeEach 블록의 등장`은 `내가 표준 픽스처를 사용`한다는
- ┣ 사실을 알려주게됨
- ┣ 고로 `다른 프로그래머가 해당 describe 블록 내에서`
- ┣ `모두 똑같은 기준` 데이터로부터 시작한다는 사실을 알 수 있음

## 4.5 픽스처 수정하기

- 지금까지 작성한 테스트 코드를 통해
- ┣ 그 속성을 확인하는 방법을 알 수 있었음
- ┣ 하지만 `실전에서는 사용자가 값을 변경하면서`
- ┣ `픽스처의 내용도 수정되는 경우가 흔함`

- 이러한 수정 대부분은 `세터에서 이뤄짐`
- ┣ 세터는 보통 아주 단순하여 버그가 생길 일도 별로
- ┣ 없으니 잘 테스트 하지 않음
- ┣ 하지만 `Producer의 production() 세터`는 좀 복잡한
- ┣ 동작을 수행하기 때문에 테스트해볼 필요가 있음

```js
it('change production', function () {
	asia.producers[0].production = 20;
	expect(asia.shortfall).equal(-6);
	expect(asia.profit).equal(292);
});
```

- 흔히 볼 수 있는 패턴
- ┣ beforeEach 블록에서 `설정`한 표준 픽스처를 취해서
- ┣ 테스트를 `수행`하고 이 픽스처가 일을 기대한 대로
- ┣ 처리 했는지를 `검증`함
- ┣ 테스트에 대한 공부를 했다면
- ┣ 이 패턴을 `설정-실행-검증`,
- ┣ `조건-발생-결과`
- ┣ `준비-수행-단언` 등으로 부름

> 해체 혹은 청소 4번째 단계

    픽스처를 제거하는 일
    ┣ 이는 프레임워크가 알아서 해체
    ┣ 그러나 해체를 명시적으로 수행해야
    ┣ 할 경우가 생길 수 있음
    ┣ 특히 생성하는 시간이 걸려서
    ┣ 여러 테스트가 공유해야만 하는
    ┣ 픽스처가 여기 해당함

- 이테스트는 `it 구문 하나에서 두 가지 속성`을
- ┣ 검증을 하고 있음
- ┣ `일반적으로 it 구문 하나당 검증도 하나씩만`
- ┣ 하는게 좋음
- ┣ `앞쪽 검증을 통과하지 못하면`
- ┣ `나머지 검증은 실행해보지도 못하고`
- ┣ 테스트가 실패하게 됨
- ┣ 그러면 실패 원인을 파악하는 데
- ┣ 유용한 정보를 놓치기 쉬움

## 4.6 경계 조건 검사하기

- 지금까지 작성한 테스는 모든 일이
- ┣ 순주롭고 아용자도 우리 의도대로 사용하는
- ┣ 일명 `꽃길 상황`에 집중하였음
- ┣ 그런데 이 범위를 벗어나는 경계 지점에서 문제가 생기면
- ┣ `어떤 일이 벌어지는지 확인하는 테스트도 작성하면 좋음`

- 예시 :
- ┣ producers와 같은 컬렉션과 마주하면
- ┣ `그 컬렉션이 비었을 때 어떤 일이 일어나는지 확인`

```js
describe('no producers', function () {
	let noProducers;
	this.beforeEach(function () {
		const data = {
			name: 'no producers',
			producers: [],
			demand: 30,
			price: 20,
		};
		noProducers = new Province(data);
	});
	it('shortfall', function () {
		expect(noProducers.shortfall).equal(30);
	});
	it('profit', function () {
		expect(noProducers.profit).equal(0);
	});
});
```

> 음수나 0 넣어보기

```js
it('zero demand', function () {
	asia.demand = 0;
	expect(asia.shortfall).equal(-25);
	expect(asia.profit).equal(0);
});
// 음수 넣어보기
it('negative demand', function () {
	asia.demand = -1;
	expect(asia.shortfall).equal(-26);
	expect(asia.profit).equal(-10);
});
```

- 여기서 드는 의문점
- ┣ `수요가 음수일 때 수익이 음수`가 나온다는 것이
- ┣ `프로그램을 사용하는 고객이 말이 되는 소리일까?`
- ┣ 인수가 음수라면 에러를 던지거나 0으로 지정하는 식으로
- ┣ 정상적인 경우와 다르게 처리해야 하는 것이 아닌가
- ┣ 이처럼 경계를 확인한는 테스트를 작성해보면
- ┣ `예외 처리에 대한 생각을 해볼 수 있음`

> 입력란이 비어있는 경우

```js
// 입력란이 비어있는 경우
it('empty string demand', function () {
	asia.demand = '';
	expect(asia.shortfall).NaN;
	expect(asia.profit).NaN;
});
```

> 흥미로운 테스트

```js
describe('string for producers', () => {
	it('', () => {
		const data = {
			name: 'String producers',
			producers: '',
			demand: 30,
			price: 20,
		};
		const prov = new Province(data);
		expect(prov.shortfall).equal(0);
	});
});
```

- 모카는 이 경우를 실패로 처리함
- ┣ 모카와 달리 에러와 실패를 구분하는 테스트 프레임워크도 많음
- ┣ `실패` : `검증 단계에서 실제 값이 예상 범위를 벗어났다는` 의미
- ┣ `에러` : `검증보다 앞선 과정(이 예제 설정)에서`
- ┣ 발생한 예외 상황을 말함
- ┣ `코드 작성자가 미처 예상하지 못한 것`

- 프로그램은 이 상황에 어떻게 대응해야 할까
- ┣ 에러 상황을 지금보다 잘 처리하도록 코드를
- ┣ 추가하는 방법도 존재함
- ┣ 더 의미 있는 오류 메시지를 출력할 수 있고
- ┣ `그냥 (로그 메시지만 남기고) producers를 빈 배열로`
- ┣ `설정할 수 있음`
- ┣ 물론 지금 상태로 남겨둘 합당할 이유도 있을 수 있음
- ┣ 예컨대 `입력 객체를 (같은 코드 베이스 안처럼) 신뢰할 수 `
- ┣ 있는 곳에서 `만들어주는 경우가 여기 속함`
- ┣ 같은 코드베이스의 모듈 사이에서
- ┣ `유효성 검사(validation check)코드가 너무 많으면`
- ┣ `다른 곳에서 확인한 걸 중복으로 검증하여 오히려 문제`
- ┣ 하지만 JSON으로 인코딩된 요청처럼
- ┣ `외부에서 들어오는 입력 객체는 유효한지 확인`해봐야 하므로
- ┣ 테스트를 작성해야 함

> 어차피 모든 버그를 잡아낼 수 없다고 생각하느라
> 테스트를 작성 하지 않는다면
> 대다수의 버그를 버그를 잡을 기회를 날리는 셈

- 테스트를 그럼 어디까지?
- ┣ `오히려 의욕이 떨어지는 경우`도 존재
- ┣ 위험한 부분에 적용
- ┣ `함수에서 오류가 생길만한 부분을 찾아보고`
- ┣ 리팩터링을 하면서 `프로그램을 더욱 깊게 이해 가능`

## 4.7 끝나지 않은 여정

- 이 장에서 한 것은
- ┣ `단위 테스트`임
- ┣ 단위 테스트란 `작은 영역만`으로
- ┣ `빠르게 실행되도록 설계된 테스트`임
- ┣ 단위 테스트 : 자가 테스트 코드의 핵심이자
- ┣ `자가 테스트 시스템은 대부분 단위 테스트가 핵심임`

- 테스트도 반복적으로 진행

> 버그 리포트를 받으면 가장 먼저 그 버그를 드러내는
> 단위 테스트부터 작성

- 자가 테스트의 목적은 :
- ┣ 리팩터링 후 테스트 결과가 모두 `정상 동작하는 것`
- ┣ `이를 목표로 삼고 해야 함`
