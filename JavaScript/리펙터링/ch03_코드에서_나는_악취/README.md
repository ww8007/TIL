# 03 코드에서 나는 악취

- 이제 리팩터링의 작동에 대한 감
- ┣ 그러나 제때 적용 하는 것을 모름
- ┗ 언제 시작하고 언제 그만할지 판단

- 딜레마 존재 : 인스턴스 변수를 삭제하거나
- ┣ 상속 계층을 만드는 방법을 설명은 쉽지만
- ┣ 언제 리팩터링을 적용해야 하는지에 대한 기준이 모호

> 조건에 맞는 리팩터링 기법을 책에서 찾아서 적용

## 목차

- [03 코드에서 나는 악취](#03-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EB%82%98%EB%8A%94-%EC%95%85%EC%B7%A8)
  - [3.1 기이한 이름](#31-%EA%B8%B0%EC%9D%B4%ED%95%9C-%EC%9D%B4%EB%A6%84)
  - [3.2 중복 코드](#32-%EC%A4%91%EB%B3%B5-%EC%BD%94%EB%93%9C)
  - [3.3 긴 함수](#33-%EA%B8%B4-%ED%95%A8%EC%88%98)
  - [3.4 긴 매개변수 목록](#34-%EA%B8%B4-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EB%AA%A9%EB%A1%9D)
  - [3.5 전역 데이터](#35-%EC%A0%84%EC%97%AD-%EB%8D%B0%EC%9D%B4%ED%84%B0)
  - [3.6 가변 데이터](#36-%EA%B0%80%EB%B3%80-%EB%8D%B0%EC%9D%B4%ED%84%B0)
  - [3.7 뒤엉킨 변경](#37-%EB%92%A4%EC%97%89%ED%82%A8-%EB%B3%80%EA%B2%BD)
  - [3.8 산탄총 수술](#38-%EC%82%B0%ED%83%84%EC%B4%9D-%EC%88%98%EC%88%A0)
  - [3.9 기능 편애](#39-%EA%B8%B0%EB%8A%A5-%ED%8E%B8%EC%95%A0)
  - [3.10 데이터 뭉치](#310-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AD%89%EC%B9%98)
  - [3.11 기본형 집착](#311-%EA%B8%B0%EB%B3%B8%ED%98%95-%EC%A7%91%EC%B0%A9)
  - [3.12 반복되는 switch 문](#312-%EB%B0%98%EB%B3%B5%EB%90%98%EB%8A%94-switch-%EB%AC%B8)
  - [3.13 반복문](#313-%EB%B0%98%EB%B3%B5%EB%AC%B8)
  - [3.14 성의 없는 요소](#314-%EC%84%B1%EC%9D%98-%EC%97%86%EB%8A%94-%EC%9A%94%EC%86%8C)
  - [3.15 추측성 일반화](#315-%EC%B6%94%EC%B8%A1%EC%84%B1-%EC%9D%BC%EB%B0%98%ED%99%94)
  - [3.16 임시 필드](#316-%EC%9E%84%EC%8B%9C-%ED%95%84%EB%93%9C)
  - [3.17 메시지 체인](#317-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%B2%B4%EC%9D%B8)
  - [3.18 증계자](#318-%EC%A6%9D%EA%B3%84%EC%9E%90)
  - [3.19 내부자 거래](#319-%EB%82%B4%EB%B6%80%EC%9E%90-%EA%B1%B0%EB%9E%98)
  - [3.20 거대한 클래스](#320-%EA%B1%B0%EB%8C%80%ED%95%9C-%ED%81%B4%EB%9E%98%EC%8A%A4)
  - [3.21 서로 다른 인터레이스의 대안 클래스들](#321-%EC%84%9C%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EC%9D%B8%ED%84%B0%EB%A0%88%EC%9D%B4%EC%8A%A4%EC%9D%98-%EB%8C%80%EC%95%88-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%93%A4)
  - [3.22 데이터 클래스](#322-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4)
  - [3.24 주석](#324-%EC%A3%BC%EC%84%9D)

## 3.1 기이한 이름

- 코드는 단순하고 명료하게 작성하는 것이 최고
- ┣ 가장 중요한 요소 : 이름
- ┣ 함수, 모듈, 변수, 클래스 :
- ┣ 이름만 보고도 각각이 무슨 일을 하고
- ┣ 어떻게 사용해야 하는지 명확히 알 수 있도록
- ┣ 엄청나게 이름에 대한 신경을 많이 써야함

- 하지만 이름 짓기는 프로그래밍에서
- ┣ 가장 어렵기로 손꼽히는 두 가지
- ┣ 1. 함수 선언 바꾸기
- ┣ 2. 변수 이름 바꾸기
- ┣ 3. 필드 이름 바꾸기
- ┣ 잘 지어놓은 이름은 나중에
- ┣ 파악하느라 헤매는 시간을 줄일 수 있음

- 단순하게 이름을 다르게 표현하는 연습이 아님
- ┣ 마땅한 이름이 떠오리지 않는다면
- ┣ 설계에서 더 근본적인 문제가 숨어 있을 가능성
- ┣ 혼란스러운 이름을 잘 정리 하다보면
- ┗ 코드가 훨씬 간결해지는 경우가 많음

## 3.2 중복 코드

- 똑같은 코드 구조가 여러 곳에서 반복 된다면
- ┣ 하나로 통합하여 더 나은 프로그램을 만들 수 있음
- ┣ 코드가 중복되면 각각을 볼 때 마다
- ┣ 서로 차이점이 없는지에 대해 주의 깊게 살펴봐야 하는
- ┣ 부담이 생김

- 가장 간단한 중복 코드의 예로
- ┣ 한 클래스에 딸린 두 메서드가 똑같은 표현식을
- ┣ 사용하는 경우가 존재함
- ┣ 1. 이럴 때는 함수 추출하기를 써서
- ┣ 양쪽 모두 추출된 메서드를 호출하게 바꾸면 됨
- ┣ 2. 코드가 비슷하기는 한데 와넌히 똑같지 않다면
- ┣ 문장 슬라이드하기로 비슷한 부분을 한곳에 모아
- ┣ 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴보고
- ┣ 같은 부모로부터 파생된 서브 클래스에 부모가 중복되어 있다면
- ┗ 메서드 올리기를 통해 부모로 옮김

## 3.3 긴 함수

- 오랜 기간 잘 활용되는 프로그램들은
- ┣ 하나같이 짧은 함수로 구성됐음
- ┣ 짧은 함수로 구성된 코드베이스를 얼핏 흝으면
- ┣ 연산하는 부분이 하나도 없어 보임
- ┣ 코드가 끝없이 위임하는 방식으로 작성되어 있음
- ┣ 간접 호출(indirection)의 효과
- ┣ 코드를 이해하고 공유하고 선택하기 쉬워진다는 장점은
- ┣ 함수를 짧게 구성할 때 나오는 것임

- 프로그래밍 초창기부터 사람들은
- ┣ 함수가 길수록 이해하기 어렵다는 사실을 알았음
- ┣ `예전언어 : 서브루틴을 호출하는 비용이 컸기 때문에`
- ┣ `짧은 함수를 꺼려하는 경향`이 있었음
- ┣ 하지만 요즘 언어는 `프로세스 안에서의 함수 호출 비용을`
- ┣ `거의 없애 버렸음`
- ┣ 물론 코드를 읽는 사람 입장 :
- ┣ 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하는 여전히
- ┣ 부담성이 존재하게 됨
- ┗ `이를 함수 이름을 잘 지어서 해결`이 가능함

- 그러기 위해서 훨씬 적극적으로 함수를 쪼개야 함
- ┣ 주석을 달아야 할 만한 부분은 무조건 함수로 만듬
- ┣ 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고
- ┣ 함수 이름 : 동작 방식이 아닌
- ┣ 의도가 드러나도록 짓게됨
- ┣ 이렇게 함수로 묶는 코드는 여러 줄일 수 있고
- ┣ 단 한줄 일 수 있음
- ┣ 핵심 : 함수의 길이가 아닌
- ┣ 함수의 목적(의도)와 구현 코드의 괴리가 얼마나 큰가임
- ┣ 즉 : 무엇을 하는지를 코드가 잘 설명해주지 못살수록
- ┣ 함수로 만드는게 유리함

- 함수를 짧게 만드는 작업의 99%는
- ┣ 함수 추출하기가 차지함
- ┣ 함수 본문에서 따로 묶어 빼내면
- ┣ 좋은 코드 덩어리를 찾아 새로운 함수를 만드는 것

- 함수가 매개변수와 임시 변수를 많이 사용 한다면
- ┣ 추출 작업에 방해가 됨
- ┣ 이런 상황에서 함수를 추출이 어려워짐
- ┣ 임시 변수를 질의 함수로 바꾸기로
- ┣ 임시 변수의 수를
- ┣ 매개변수 개체 만들기와
- ┣ 객체 통째로 넘기기로는
- ┣ 매개변수의 수를 줄일 수 있음

- 그렇다면 추출할 코드 덩어리는 어떻게 찾아낼까
- ┣ 한 가지 좋은 방법 : 주석을 참고한느 것
- ┣ 함수 이름을 주석의 내용을 토대로 지음
- ┣ 조건문이나 반목분도 추출 대상의 실마리를 제공함
- ┣ 조건문은 : 조건문 분해하기(10.1)대응
- ┣ 거대한 switch문을 구성하는 case문마다
- ┣ case 본문을 함수로 바꿈

- 반복문도 그 안의 코드와 함께 추출해서
- ┣ 독립된 함수로 만듬
- ┣ 추출한 반복문 코드에 적합한 이름이
- ┣ 떠오르지 않는다면 성격이 다른 두 가지
- ┣ 작업이 섞여 있기 때문일 수 있음
- ┣ 이럴 때는 과감히 반복문 쪼개기(8.7)를 적용해서
- ┗ 작업을 분리함

## 3.4 긴 매개변수 목록

- 프로그래밍을 배우면
- ┣ 함수에 필요한 것들을 모조리 매개변수로
- ┣ 전달하라고 배웠음
- ┣ 그래야 암적 존재인 전역 데이터가 늘어나는 사태를
- ┣ 막을 수 있기 때문
- ┣ 하지만 매개변수 목록이 늘어나면
- ┣ 그 자체로 이해하기 어려울 때가 많아짐

- 종종 다른 매개변수에서 값을 얻어올 수 있는
- ┣ 매개변수가 존재할 수 있으
- ┣ 이런 경우 매개변수를 질의 함수로 바꾸기
- ┣ 사용 중인 데이터 구조에서 값들을 뽑아서
- ┣ 각각을 별개의 매개변수가 전달하는 코드라면
- ┣ 객체 통째로 넘기기를 적용하여
- ┣ 원본 데이터 구조를 그대로 전달함
- ┣ 항상 함께 전달되는 매개변수들은
- ┣ 매개변수 객체 만들기로 하나로 묶어버림
- ┣ 함수의 동작 방식을 정하는 플래그 역할의 매개변수
- ┣ 플래그 인수 제거하기로 없애줌

- 클래스 : 매개변수 목록을 줄이는 데 효과적인 수단
- ┣ 특히 여러 개의 함수가 특정 매개변수들의
- ┣ 값을 공통으로 사용할 때 유용함
- ┣ 이럴 때는 여러 함수를 클래스 함수로 묶기를
- ┣ 이용하여 공통 값들을 클래스의 필드로 정의함
- ┣ 함수형 프로그래밍의 경우 일련의 부분적용 함수들을
- ┣ 생성한다고 볼 수 있음

## 3.5 전역 데이터

- 전역 데이터 : 어디에서든 건들 수 있고
- ┣ 값을 누가 바꿧는지 찾아낼 매커니즘이 없다는게 문제임
- ┣ 전역 데이터의 대표적인 형태는 전역 변수이지만
- ┣ 클래스 변수와 싱글톤에서도 같은 문제가 발생함

- 이를 방지하기 위해 사용하는 방법 :
- ┣ `변수 캡슐화 하기`(6.8)
- ┣ 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다
- ┣ 이 기법을 가장 먼저 적용함
- ┣ 이런 데이터를 함수로 감싸는 것만으로도
- ┣ 데이터를 수정하는 부분을 쉽게 찾을 수 있고
- ┣ 접근을 통제할 수 있게 됨
- ┣ 더 나아가 접근자 함수들을
- ┣ 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록
- ┣ 접근 범위를 최소로 줄이는 것도 좋음

- ┣ 전역 데이터가 가변(mutable)이라면 특히나 다루기
- ┣ 까다로운 경우가 존재

## 3.6 가변 데이터

- 데이터를 변경했더니 예상치 못한 결과나
- ┣ 골치 아픈 버그
- ┣ 이런 이유로 함수형 프로그래밍 에서는
- ┣ 데이터는 절대 변하지 않고
- ┣ 데이터를 변경하려면 반드시
- ┣ 변경하려는 값에 해당하는 복사복을 만들어서
- ┣ 반환한다는 개념을 기본으로 삼고 있음

- 하지만 함수형 언어가 프로그래밍에서 차지하는 비중은
- ┣ 여전히 적고 변수 값을 바꿀 수 있는 언어를
- ┣ 사용하는 프로그래머가 더 많음
- ┣ 그렇다고 불변성이 주는 장점을 포기할 필요는 없음

- ┣ 1. 변수 캡슐화 하기(6.6)을 적용하여
- ┣ 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면
- ┣ 값이 어떻게 수정되는지 감시하거나
- ┣ 코드를 개선하기 쉬움
- ┣ 하나의 변수에 용도가 다른 값들을 저장하느라
- ┣ 값을 개선하는 경우라면
- ┣ 변수 쪼개기(9.1)를 이용하여 용도별로 독립 변수에 저장하여
- ┣ 값 갱신이 문제를 일으킬 여지를 없앰
- ┣ 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋음
- ┣ 고로 문장 슬라이드하기(8.6)와 함수 추출하기(6.1)를 이용하여
- ┣ 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리
- ┣ `API`를 만들 경우 `질의 함수와 변경 함수 분리하기`(11.1)를
- ┣ 활용하여 꼭 필요한 경우가 아니라면
- ┣ `부작용이 있는 코드를 호출할 수 없게 함`
- ┣ 세터 제거하기(11.7)도 적용함
- ┣ 간혹 세터를 호출하는 클라이언트를 찾는 것만으로도
- ┣ 변수의 유효범위를 줄이는 데 도움이 될 때가 있음

- 값을 다른 곳에서 설정할 수 있는 가변 데이터의 문제는
- ┣ 생각보다 높음
- ┣ 이럴 때는 `파생 변수를 질의 함수로 바꾸기`(9.3)를 사용

- `변수의 유효범위가 단 몇 줄뿐`이라면
- ┣ 가변데이터라 해도 문제를 일으킬 일이 별로 없음
- ┣ 하지만 `나중에 유효범위가 넓어질 수 있고`
- ┣ 이는 더 큰 문제로 생길 수 있는 위험성이 존재함
- ┣ 1. `여러 함수를 클래스로 묶기(6.9)`
- ┣ 2. `여러 함수를 변환 함수로 묶기(6.10)`
- ┣ 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면
- ┣ `일반적으로 참조를 값으로 바꾸기`(9.4)
- ┣ 적용하여 내부 필드를 직접 수정하지 말고
- ┗ 구조체를 통째로 교체하는 편이 나음

## 3.7 뒤엉킨 변경

- 소프트웨어는 자고로 소프트해야 마땅
- ┣ 코드를 수정할 때는
- ┣ 시스템에서 고쳐야 할 딱 한군데를 찾아서
- ┣ 그 부분만 수정할 수 있기를 바람
- ┣ 이렇게 할 수 없다면 문제가 발생함

- 뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로
- ┣ 지켜지지 않을 때 나타남
- ┣ 하나의 모듈이 서로 다른 이유들로 인해
- ┣ 여러가지 방식으로 변경되는 일이 많을 때
- ┣ 발생하게 됨
- 데이터베이스에서 데이터를 가져와서
- ┣ 금융 상품 로직에서 처리해야 하는 일처럼
- ┣ 순차적으로 실행되는게 자연스러운 맥락이라면
- ┣ 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게
- ┣ 하는 식으로 `단계를 분리함(단계 쪼개기(6.11))`
- ┣ 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는
- ┣ `빈도가 높다면`
- ┣ 각 맥락에 해당하는 `적당한 모듈`을 만들어서
- ┣ `관련 함수들을 모음(함수 옮기기(8.1))`
- ┣ 이때 여러 맥락의 일을 관여하는 함수가 있다면
- ┣ 옮기기 전에 `함수 추출하기(6.1)`부터 수행함
- ┣ 모듈이 클래스 : 클래스 추출하기 사용

## 3.8 산탄총 수술

- 산탄총 수술 : 뒤엉킨 변경과 비슷하면서도 정반대

|                 | 뒤엉킨 변경           | 산탄총 수술          |
| --------------- | --------------------- | -------------------- |
| 원인            | 맥락 이해 X           | 맥락 이해 x          |
| 해법(원리)      | 맥락을 명확히 구분    | 맥락을 명확히 구분   |
| 방생 과정(현상) | 한 코드에 섞여 들어감 | 여러 코드에 흩뿌려짐 |
| 해법(실제 행동) | 맥락별로 분리         | 맥락별로 모음        |

- 변경할 부분이 코드 전에 퍼져 있다면
- ┣ 찾기도 어렵고
- ┣ 꼭 수정해야 할 곳을 지나치기 쉬움

- ┣ 이럴 때는 함께 변경되는 대상들을
- ┣ 함수 옮기기(8.1), 필드 옮기기(8.2)로 모두 한 모듈에
- ┣ 묶어두면 좋음
- ┣ 비슷한 데이터를 다루는 함수가 많다면
- ┣ 여러 함수를 클래스로 묶기(6.9)를 적용
- ┣ 데이터 구조를 변환하거나 보강하는 함수들에는
- ┣ 여러 함수를 변환 함수로 묶기(6.10)를 적용함
- ┣ 이렇게 묶은 함수들의 출력 결과를 묶어서
- ┣ 다음 단계의 로직으로 전달할 수 있다면
- ┣ 단계 쪼개기(6.11)를 적용

- 어설프게 분리된 로직을
- ┣ 1. 함수 인라인 하기
- ┣ 2. 클래스 인라인 하기
- ┣ 같은 인라인 리팩터링으로 하나로 합치는 것도
- ┣ 산탄총 수술에 대처하는 좋은 방법임
- ┣ 메서드나 클래스가 비대해지지만
- ┣ 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리 가능

## 3.9 기능 편애

- 프로그램을 모듈화할 때
- ┣ 코드를 여러 영역으로 나눈 뒤
- ┣ 영역 안에서 이뤄지는 상호작용은 최대한 늘리고
- ┣ 영역 사이에서 이뤄지는 상호 작용은 최소로 줄이는 줄이는데 주력
- ┣ 우리는 실행 ㅘ정에서 외부 객체의 게터 메서드 여러개를
- ┣ 호출하도록 작성된 함수를 수없이 바왔음
- ┣ 이 함수가 데이터와 가까기 있고 싶어 한다는 의중이 뚜렷이
- ┣ 드러나므로
- ┣ 소원대로 데이터 근처로 옮겨주면 됨
- ┣ 때로는 함수의 일부에서만 기능을 편애도 가능함
- ┣ 이러 때는 그 부분만 `독립 함수로 빼낸 다음(함수 추출하기 6.1)`
- ┣ `원하는 모듈로 보내줌(함수 옮기기(8.1))`

> 물론 어디로 옮길지가 명확하게 드러나지 않는 경우도 존재

- 함수가 사용하는 모듈이 다양하다면
- ┣ 어느 모듈로 옮겨야 할까
- ┣ 이럴 때 우리는 가장 많은 데이터를 포함한 모듈로 옮김
- ┣ 함수 추출하기로 함수를 여러 조각으로 나눈 후
- ┣ 각각을 적합한 모듈로 옮기면 더 쉽게 해겨로디는 경우도 많음

- 한편 아픠 두 문단에서 설명한 규칙을 거스르는
- ┣ 복잡한 패턴도 존재함
- ┣ 디자인 패턴 중 전략 패턴, 방문자 패턴 존재
- ┣ 켄트 벡의 자기 위임도 여기 속함
- ┣ 가장 기본이 되는 원칙은 :
- ┣ 함께 변경할 대상을 한데 모으는 것
- ┣ 데이터와 이를 활용하는 동작은
- ┣ 함께 변경해야 할 때가 많지만
- ┣ 예외가 존재함
- ┣ 그럴 때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록
- ┣ 옮기면 됨
- ┣ 전략 패턴과 방문자 패턴을 적용하면
- ┣ 오버라이드해야 할 소량의 동작 코드를
- ┣ 각각의 클래스로 격리 하므로 수정이 쉬워짐
- ┣ (대신 간접 호출이 늘어남)

## 3.10 데이터 뭉치

- 데이터 항목은 어린아이와 같음
- ┣ 서로 어울려 노는 것을 좋아함
- ┣ 이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 마련

- 가장 먼저 필드 형태의 데이터 뭉치를 찾아서
- ┣ 클래스 추출하기(7.5)로 하나의 객체로 묶음
- ┣ 다음은 메서드 시그니처에 있는 데이터 뭉치 차례
- ┣ 먼저 매개변수 객체 만들기(6.8)난 객체 통째로 넘기기(11.4)를
- ┣ 적용해서 매개변수 수를 줄여봄
- ┣ 그 즉시 메서드 호출 코드가 간결
- ┣ 새 객체로 뽑아낸 필드가 두 개 이상이기만 해도
- ┣ 확실히 예전보다 나아지기 때문

> 데이터 뭉치인지 판별

    값 하나를 삭제해봄
    ┣ 나머지 데이터만으로는
    ┣ 의미가 없다면
    ┣ 그는 객체로 환생하길 갈망하는
    ┣ 데이터 뭉치임

## 3.11 기본형 집착

- 대부분의 프로그래밍 언어 :
- ┣ 정수, 부동소수점 수, 문자열 같은
- ┣ 다양한 기본형을 제공함
- ┣ 라이버르러를 통해 날짜 같은 간단한
- ┣ 객체를 추가로 제공하기도 함

- 전화번호를 단순히 문자 집합으로만
- ┣ 표현하기에는 아쉬움이 많음
- ┣ 최소한 사용자에게 보여줄 때는
- ┣ 일관된 형식으로 출력해주는
- ┣ 기능이라도 갖춰야 함
- ┣ 이를 문자열화된 변수라는 이름도 붙음

- 기본형을 객체로 바꾸기(7.3)을 적용하면
- ┣ 기본형만이 거주하는 구석이 동굴을
- ┣ 의미 있는 자료형이 사는 최신 온돌식 코드로
- ┣ 탈바꿈이 가능해짐
- ┣ 기본형으로 표현된 코드가
- ┣ 조건부 동작을 제어하는 타입 코드(type code)로 쓰였다면
- ┣ 타입 코드를 서브클래스로 바꾸기(12.6)
- ┣ 조건부 로직을 다형성으로 바꾸기(10.4)를 차례로 적용

- 자주 함께 몰려다니는 기본형 그룹도
- ┣ 데이터 뭉치임
- ┣ 클래스 추출하기와 매개변수 객체 만들기
- ┣ 이용하여 반드시 문명사회로 이꿀어줌

## 3.12 반복되는 switch 문

- 순수한 객체 지향을 선봉하는 사람들과
- ┣ 얘기하다 보면 주제는 곧 switch 문의 사악함으로
- ┣ 흘러가기 마려임
- ┣ 이들은 코드에 등장하는 switch문은 모조리
- ┣ 조건부 로직을 다형성으로 바꾸기로
- ┣ 없애 버려야 할 대상이라고 주장함
- ┣ 모든 조건부 로직을 다형성으로 바궈서
- ┣ if문 까지도 없애야 하는 대상이라고 말함

- 지금은 다형성이 널리 자리 잡아서
- ┣ 단순히 switch 문을 썻다고 해서
- ┣ 자동으로 검토 대상은 되지 않음

- 중복된 switch 문이 문제가 되는 이유는
- ┣ 조건절을 하나 추가할 때마다
- ┣ 다른 switch 문들도 모두 찾아서
- ┣ 함께 수정해야 하기 때문임
- ┣ 이럴 때 다형성 :
- ┣ 반복된 switch 문이 내뿜는 사악한 기운을 제압
- ┣ 코드베이스를 최신 스타일로 바꿔줌

## 3.13 반복문

- 지금은 일급 함수를 지원하는 언어가 많아졌기 때문에
- ┣ 반복문을 파이프라인으로 바꾸기(8.8)을 적요앻서
- ┣ 시대에 걸맞지 않은 반복문을 제거가 가능해짐
- ┣ filter, map 같은 파이프라인 연산을 사용하면
- ┣ 코드에서 각 원소들이 어떻게 처리되는지
- ┣ 쉽게 파악이 가능해짐

## 3.14 성의 없는 요소

- 코드의 구조를 잡을 때 언어가 제공하는 함수(메서드),
- ┣ 클래스, 인터페이스등 구조를 잡는데 활용하는
- ┣ 프로그램 요소를 이용하는 것을 좋아함
- ┣ 하지만 의미가 없는 경우도 존재함
- ┣ 1. `본문 코드를 그대로 쓰는 것과 같은 함수`
- ┣ 2. `메서드가 하나뿐인 클래스`
- ┣ 이러한 작업들은
- ┣ 1. `함수 인라인 하기(6.2)`
- ┣ 2. `클래스 인라인 하기(7.6)`으로 처리하기
- ┣ `상속을 사용 : 계층 합치기(12.9)`

## 3.15 추측성 일반화

- 당장에 필요없는 나중에 처리를 위한
- ┣ 모든 종류에 대한 후킹 포인트와
- ┣ 특이 케이스 처리 로직을 작성해둔 코드에서 풍김
- ┣ 그 결과는 물론 이해하거나 관리하기 어려워진 코드임
- ┣ 사용되면 좋겠지만 없다면 이는 쓸모없는 코드이므로 삭제

- 하는 일이 거의 없는 추상 클래스 :
- ┣ 계층 합치기(12.9)로 제거함
- ┣ 쓸데 없이 위임하는 코드는
- ┣ 1. 함수 인라인하기(6.2)나
- ┣ 2. 클래스 인라인하기(7.6)로 삭제
- ┣ 본문에서 사용되지 않는 매개변수는
- ┣ 함수 선언 바꾸기로 없앰
- 추측성 일반환는 테스트 코드 말고는
- ┣ 사용하는 곳이 없는 함수나 클래스에서
- ┣ 흔히 볼 수 있음
- ┣ 이런 코드를 발견하면
- ┣ 테스트 케이스를 삭제한 뒤에
- ┣ 죽은 코드 제거하기로 날려버림

## 3.16 임시 필드

- 간혹 특정 상황에서만 값이 설정되는 필드를 가진
- ┣ 클래스도 존재함
- ┣ 하지만 객체를 가져올 때는 당연히
- ┣ 모든 필드가 채워져 있으리라 기대하는 것이 보통임
- ┣ 이렇게 임식 필드를 갖도록 작성하면
- ┣ 코드를 이해하기 어려움

- 혼자 떨어져 있는 필드들을 발견하면
- ┣ 클래스 추출하기(7.5)로 제 살 곳을 찾아줌
- ┣ 그런 다음 함수 옮기기(8.1)로 임시 필드들과
- ┣ 관련되 코드를 모조리 새 클래스에 몰아넣음
- ┣ 또한 임시 필드들이 유요한지 확인한 후 동작하는
- ┣ 조건부 로직이 있을 수 있는데
- ┣ 특이 케이스 추가하기로 필드들이 유효하지 않을 때를 위한
- ┣ 대안 클래스를 만들어서 제거 가능

## 3.17 메시지 체인

- 메시지 체인 : 클라이언트가 한 객체를 통해
- ┣ 다른 객체를 얻은 뒤 방금 얻은 객체에서
- ┣ 또 다른 객체를 요청하는 식으로
- ┣ 다른 객체를 요청하는 작업 연쇄적으로 이어지는 코드를 말함
- ┣ 가령 getSomething() 같은 게터가 꼬리에 꼬리를 물고
- ┣ 이어지거나 임시 변수들이 줄줄이 나열되는 코드가 있음
- ┣ 이는 클리어언트가 객체 내비에깅션 구조에
- ┣ 종속됐음을 의미함
- 이는 위임 숨기기(7.7)로 해결함
- ┣ 이 리팩터링은 메시지 체인의 당양한 연결점에
- ┣ 적용이 가능함
- ┣ 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만
- ┣ 그러다 모든 중간 객체들이 중개자가 되기 쉬움
- ┣ 그러니 최종 결과 객체가 어떻게 쓰이는지부터 살펴보는게 좋음
- ┣ 함수 추출하기로 결과 객체를 사용하는 코드 일부를 따로 빼놓고
- ┣ 함수 옮기기로 체인을 숨길 수 있는지 살펴봄
- ┣ 나중에 이 객체들도 사용하길 원하는 클라이언트가 제법 있다면
- ┣ 이 요구를 처리해줄 메서드를 추구함

## 3.18 증계자

- 객체의 대표적인 기능 하나로
- ┣ 외부로부터 세부사항을 숨겨주는
- ┣ 캡슐화가 존재
- ┣ 캡슐화의 과정에서 위임이 자주 활용

- 하지만 지나치면 문제가 됨
- ┣ 클래스가 제공하는 메서드 중 절반이
- ┣ 다른 클래스에 구현을 위임하고 있다면?
- ┣ 이럴 때는 `중개자 제거하기(7.8)을 활용하여`
- ┣ `실제로 일을 하는 객체와`
- ┣ `직접 소통`하도록 만들면됨
- ┣ 위임 메서드를 제거한 후 남은 일이 거의 없다면
- ┣ `호출하는 쪽으로 인라인(함수 인라인(6.2))`

## 3.19 내부자 거래

- 소프트웨어 개발자 : 모듈 사이에 벽을 두껍게 세우기를
- ┣ 좋아하며 모듈 사이의 데이터 거래가 많으면
- ┣ 결합도(coupling)이 높아진다고 투덜됨
- ┣ 일이 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만
- ┣ 그 양을 최소로 줄이고 모두 투명하게 처리

- 커피 자판기 옆에서 은밀히 데이터를 주고 받는
- ┣ 모듈들이 있다면
- ┣ 함수 옮기기(8.1), 필드 옮기기(8.2) 기법으로
- ┣ 떼어놓아서 사적으로 처리하는 부분을 줄임
- ┣ 여러 모듈이 같은 관심사를 공유한다면
- ┣ 공통 부분을 정식으로 처리하는
- ┣ 제 3의 모듈을 새로 만들거나
- ┣ 위임 숨기기(7.7)를 이용하여
- ┣ 다른 모듈이 중간자 역할을 하도록 만듬

- 상속 구조에서는 부모 자식 사이에 결탁이 생길 때가 있음
- ┣ 자식 클래스는 항상 부모 클래스가 공개하고 싶은 것 이상으로
- ┣ 부모에 대해 알려고 함
- ┣ 그러다 부모 품을 떠나는 경우
- ┣ 서브 클래스를 위임으로 바꾸기(12.10)
- ┣ 슈퍼클래스를 위임으로 바꾸기(12.11) 활용

## 3.20 거대한 클래스

- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어남
- ┣ 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉬움

- 이럴때는 클래스 추출하기(7.5)로 필드들 일부를
- ┣ 따로 묶음
- ┣ 같은 컴포넌트에 모아두는 것이 합당해 보이는
- ┣ 필드들은 선택하면 됨
- 클라이언트들이 거대 클래스를 이용하는지 패턴을
- ┣ 파악하여 그 클래스를 어떻게 쪼갤지 단서를 얻을수도 잇음
- ┣ 이때 가각의 기능 그룹이 개별 클래스로 추출될 후보들
- ┣ 유용한 기능 그룹을 찾았다면
- ┣ 클래스 추출하기(7.5) 슈퍼클래스 추출하기(12.8)
- ┣ 타입 코드를 서브클래스로 바꾸기(12.6)등을 활용해서
- ┣ 여러 클래스로 분리하기

## 3.21 서로 다른 인터레이스의 대안 클래스들

- 클래스를 사용할 때의 큰 장점은
- ┣ 필요에 따라 언제든 다른 클래스로 교체 가능하다는 점
- ┣ 단 : 교체하려면 인터페이스가 같아야 함
- ┣ 따라서 함수 선언 바꾸기(6.5)로 메서드 시그니처를 일치
- ┣ 때로는 이것ㅇ만으로 부족
- ┣ 이럴 때는 함수 옮기기(8.1)를 이용하여
- ┣ 인터페이스가 같아질 때까지 필요한 동작들을
- ┣ 클래스 안으로 밀어 넣음
- ┣ 그러다 대안 클래스 사이에 중복 코드가 생기면
- ┣ 슈퍼 클래스 추출하기(12.8) 적용에 대한 고민

## 3.22 데이터 클래스

- 데이터 클래스 :
- ┣ 1. 데이터 필드
- ┣ 2. 게터/ 세터 메서드로만 구성된 클래스를 뜻함
- ┣ 그저 데이터 저장 용도로만 쓰이다 보니
- ┣ 다른 클르새가 너무 깊이까지 함부로 다루는 경우가 존재
- ┣ 이러한 클래스에 public 필드가 있다면
- ┣ 누가 보기전에 얼른 레코드 캡슐화 하기(7.1)로 숨김
- ┣ 변경하면 안되는 필드는 세터 제거하기(11.7)로 접근을 원천 봉쇄

## 3.24 주석

- 주석을 달면 안되는 것 아님
- ┣ 주석이 장황하게 달린 원인이 코드를 잘못 작성 해끼 때문인 경우가
- ┣ 의외로 많음

- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면
- ┣ 함수 추출하기(6.1) 적용
- ┣ 이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면
- ┣ 함수 선언 바꾸기(6.5)로 함수 이름 바꿔봄
- ┣ 시스템이 동작하기 위한 선행 조건을 명시
- ┣ 어서션 추가히기(10.6)가 대기

- ┣ 뭘 할지 모를 때라면 주석을 달아두면 좋음
- ┣ 현재 진행 상황뿐만 아니라
- ┣ 확실하지 않은 부분에 주석을 남김
- ┣ 코드를 지금처럼 작성한 이류를 설명하는 이유를 남길 수 있음
