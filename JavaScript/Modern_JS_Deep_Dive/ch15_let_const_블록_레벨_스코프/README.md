# 15. let, const 키워드와 블록 레벨 스코프

## 목차

- [15.1 var 키워드로 선언한 변수의 문제점](#151-var-%ED%82%A4%EC%9B%8C%EB%93%9C%EB%A1%9C-%EC%84%A0%EC%96%B8%ED%95%9C-%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90)
  - [15.1.1 변수 중복 선언 허용](#1511-%EB%B3%80%EC%88%98-%EC%A4%91%EB%B3%B5-%EC%84%A0%EC%96%B8-%ED%97%88%EC%9A%A9)
  - [15.1.2 함수 레벨 스코프](#1512-%ED%95%A8%EC%88%98-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84)
  - [15.1.3 변수 호이스팅](#1513-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85)
- [15.2 let 키워드](#152-let-%ED%82%A4%EC%9B%8C%EB%93%9C)
  - [15.2.1 변수 중복 선언 금지](#1521-%EB%B3%80%EC%88%98-%EC%A4%91%EB%B3%B5-%EC%84%A0%EC%96%B8-%EA%B8%88%EC%A7%80)
  - [15.2.2 블록 레벨 스코프](#1522-%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84)
  - [15.2.3 변수 호이스팅](#1523-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85)
  - [15.2.5 전역 객체와 let](#1525-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4%EC%99%80-let)
- [15.3 const 키워드](#153-const-%ED%82%A4%EC%9B%8C%EB%93%9C)
  - [15.3.1 선언과 초기화](#1531-%EC%84%A0%EC%96%B8%EA%B3%BC-%EC%B4%88%EA%B8%B0%ED%99%94)
  - [15.3.2 재할당 금지](#1532-%EC%9E%AC%ED%95%A0%EB%8B%B9-%EA%B8%88%EC%A7%80)
  - [15.3.3 상수](#1533-%EC%83%81%EC%88%98)
  - [15.3.4 const 키워드와 객체](#1534-const-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%99%80-%EA%B0%9D%EC%B2%B4)
- [15.4 var vs let vs const](#154-var-vs-let-vs-const)

## 15.1 var 키워드로 선언한 변수의 문제점

- ES5까지 변수를 선언할 수 있는 유일한 방법은
- ┣ var 키워드를 사용하는 것
- ┣ var 키워드로 선언된 변수는 다음과 같은 특징
- ┣ 다른 언어와 구별되는 독특한 특징으로
- ┗ 주의를 기울이지 않으면 문제 발생가능

### 15.1.1 변수 중복 선언 허용

- var 키워드로 선언한 변수는 중복 선언이 가능

```js
var x = 1;
var y = 1;

// var 키워드는 같은 스코프 내에서 중복 선언이 가능
// 초기화문이 있는 변수 선언문은 JS 엔진에 의해 var 키워드가 없는 것 처럼 동작

var x = 100;

var y;
```

- 위 예제의 `var 키워드`로 선언한 `x, y 변수는 중복 선언`됨
- ┣ `var 키워드`로 변수를 중복 선언하게 되면
- ┣ 초기화문(변수 선언과 동시에 초기화) 유무에 따라
- ┣ 다르게 동작하게됨
- ┣ 초기화 문이 존재 → 변수 선언문은 JS 엔진에 의해 var 키워드 없는 것 처럼
- ┣ 초기화 문이 없는 변수 선언문은 무시됨
- ┗ 에러는 발생하지 않음

> var 키워드를 사용해서 변수를 중복 선언하면서 값까지 할당하면
> 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생

### 15.1.2 함수 레벨 스코프

- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정
- ┗ 함수 외부에서 var 키워드로 선언한 변수 → `코드 블록 내에서 선언`해도 `전역`

```js
var x = 1;
if (true) {
	// x는 전역 변수. 이미 선언된 전역 변수 x가 있으므로 x는 중복 선언
	// 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킴

	var x = 10;
}
console.log(x); // 10
```

> for문 안에 선언하게 되더라도 동일하게 동작해버림

- 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높이게됨
- ┗ 이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생

### 15.1.3 변수 호이스팅

- `var 키워드`로 `변수를 선언`하면 → `변수 호이스팅`에 의해
- ┣ `변수 선언문`이 `스코프의 선두로 끌어올려진 것처럼 동작`
- ┣ 변수 호이스팅에 의해 var 키워드로 선언한 변수는
- ┣ `변수 선언문 이전에 참조`할 수 있음
- ┗ 할당문 이전에 변수를 참조하면 언제나 `undefined 반환`

```js
// 이 시점에는 변수 호이스팅에 의해 이미 foo 변수가 선언
// 1. 선언단계
// 변수 foo는 undefined로 초기화 됨
// 2. 초기화 단계
console.log(foo); //undefined

// 변수에 값을 할당
// 3. 할당 단계
foo = 123;

console.log(foo); // 123

// 변수 선언은 런타임 이전에 JS 엔진에 의해서
// 암묵적으로 실행됨
var foo;
```

- 변수 선언문 이전에 변수를 참조하는 것은
- ┣ 변수 호이스팅에 의해 에러를 발생키지는 않지만
- ┗ 프로그램의 흐름상 맞지 않고, 가독성 down, 오류 생길 여지 생김

## 15.2 let 키워드

- 앞에서 살펴본 `var 키워드의 단점을 보완`하기 위해서
- ┣ `ES6`에서 새로운 변수 선언 키워드인 `let`과 `const`를 도입
- ┗ var 키워드와의 차이점을 중심으로 let 키워드 살펴보자.

### 15.2.1 변수 중복 선언 금지

- `var`키워드로 이름이 동일한 변수를 중복 선언하면
- ┣ 아무런 에러가 발생하지 않음
- ┣ 변수를 중복선언 하면서, 값까지 할당한 경우는
- ┗ 의도치 않게 먼저 선언된 변수 값이 재할당 되어 변경되는 부작용

> let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러 발생

### 15.2.2 블록 레벨 스코프

- var 키워드로 선언한 변수는
- ┣ 오로지 코드 블록만을 지역 스코프로 인정하는
- ┗ `함수 레벨 스코프`를 따르게 됨
- ┣ 그러나 let 키워드로 선언한 변수 :
- ┣ 모든 코드 블록(함수, if문, for문, while문, try/catch문)을
- ┣ 지역 스코프로 인정하는
- ┗ `블록 레벨 스코프(block-level scope)`를 따름

```js
let foo = 1; //전역 변수

{
	let foo = 2; //지역 변수
	let bar = 3;
}
console.log(foo); //1
console.log(bar); // Reference Error
```

- let 키워드로 선언된 변수는 블록 레벨 스코프를 ㄸ라ㅡㅁ
- ┣ 위 코드에서 코드 블럭내의 foo, bar는 지역 변수
- ┣ 전역 변수에 선언된 foo와는 다른 별개의 변수
- ┗ bar 변수 또한 블록 레벨 스코프를 갖는 지역 변수

- 함수도 `코드 블록`이므로 `스코프를 만듬`
- ┗ `함수 내의 코드 블록`은 함수 `레벨 스코프에 중첩`

### 15.2.3 변수 호이스팅

- `var 키워드`로 선언한 변수와 달리
- ┣ `let 키워드`로 선언한 변수는 `호이스팅이 발생하지`
- ┗ `않는 것 처럼` 동작을 함

```js
console.log(foo); // Reference Error
let foo;
```

- let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면
- ┗ 참조 에러(ReferenceError)가 발생

- 변수 선언에서 살펴본 바와 같이 `var 키워드로 선언한 변수`는
- ┣ `런타임 이전`에 `JS 엔진에 의해 암묵적`으로
- ┗ `1. 선언 단계`, `2. 초기화 단계`가 한번에 진행

- `선언 단계`에서 1. `스코프(실행 컨텍스트의 렉시컬 환경)`에 `변수 식별자`를 등록해
- ┣ 2. `JS 엔진에 변수의 존재를 알림`
- ┣ 그리고 3. 즉시 초기화단계에서 undefined로 변수를 초기화
- ┣ 그렇기에 변수 선언문 이전에 변수에 접근해도
- ┣ 스코프에 변수가 존재하기 때문에 에러 x
- ┗ 다만 `undefined를 반환`

- `let 키워드`로 선언한 변수는 `1. 선언단계`, `2. 초기화 단계`가
- ┣ `분리되어 진행`됨
- ┣ `런타임 이전`에 `JS 엔진`에 의해
- ┗ `암묵적으로 선언 단계`가 `먼저 실행`되지만
- ┣ `초기화 단계`는 `변수 선언문에 도달`했을 때
- ┗ `발생`하게 됨
- ┣ 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면
- ┗ `참조 에러(Reference Error)`

- let 키워드로 선언한 변수는 변수는 스코프의 시작
- ┣ 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 참조 불가
- ┣ `스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는`
- ┗ 구간을 `일시적 사각단계(Temporal Dead Zone)`라고 부름

```js
// 런타임 이전에 선언 단계가 실행
// 아직 변수가 초기화되지 않았음
console.log(foo); //Reference Error : foo is not defined

let foo; // 변수 선언문에서 초기화 단계가 실행
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행
console.log(foo); //1
```

| 초기화, 할당 | 선언단계               | ReferenceError    |
| ------------ | ---------------------- | ----------------- |
|              | 일시적 사각 단계 (TDZ) | ReferenceError    |
| `let foo;`   | 초기화 단계            | foo === undefined |
| `foo = 1;`   | 할당 단계              | foo === 1         |

> 결국 let 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것 처럼 보이지만
> 사실은 그렇지 않음

```js
let foo = 1;
{
	console.log(foo); // ReferenceError: Cannot access 'foo' before initialize
	let foo = 2;
}
```

- `let 키워드`로 선언한 변수의 경우 변수 호이스팅이 발생하지 않는다면
- ┣ 전역 변수 foo 값을 출력 해야 정상
- ┣ 그러나 `let 키워드`로 선언한 변수도 `여전히 호이스팅 발생`
- ┗ `참조 에러`가 발생하게 됨

- JS는 ES6에서 도입된 let,const를 포함해서
- ┣ `모든 선언(var, let, const, function, function*, class)`
- ┣ 위에 모든 것들을 호이스팅함
- ┣ 그러나 ES6 에서 도입된 let, const, class를 사용한 선언문은
- ┗ 호이스팅이 발생되지 않은 것처럼 동작!

### 15.2.5 전역 객체와 let

-` var 키워드로 선언한` `전역 변수`와 `전역 함수`

- ┣ 그리고 선언하지 않은 변수에 값을 할당한 `암묵적 전역`은
- ┣ `전역 객체 window`의 `프로퍼티`가 됨
- ┗ 전역 객체의 프로퍼티를 참조할 때 `window 생략 가능`

```js
// 이 예제는 브라우저에서 실행

// 전역 변수
var x = 1;
// 암묵적 전역
y = 2;
// 전역 함수
function foo() {}

// var 키워드로 선언한 전역 변수는
// 전역객체 window의 프로퍼티임
console.log(window.x); //1
// 전역 객체 window의 프로퍼티는
// 전역 변수처럼 사용이 가능
console.log(x); // 1

// 암묵적 전역은
// 전역 객체 window의 프로퍼티
console.log(window.y); // 2
console.log(y); //2

// 함수 선언문으로 정의한 전역 함수는
// 전역 객체 window의 프로퍼티
console.log(window.foo); // f foo() {}
// 전역 객체 window의 프로퍼티는
// 전역 변수처럼 사용가능
console.log(foo); // f foo() {}
```

- `let 키워드로 선언한 전역변수` : `전역 객체의 프로퍼티가 아님`
- ┣ window.foo와 같이 `접근할 수 없음`
- ┣ `let 전역 변수`는 `보이지 않는 개념적인 블록`(전역 렉시컬 환경의
- ┣ 선언적인 환경 레코드) : 23장 실행 컨텍스트에서 학습
- ┗ 내에 존재하게 됨

## 15.3 const 키워드

- `const 키워드` : `상수(constant`)를 선언하기 위해 사용
- ┣ 하지만 `반드시 상수만을 위해 사용하는 것은 아님`
- ┣ 이는 후반부에 설명
- ┣ const 특징 == let 키워드와 비슷
- ┗ `다른 점을 중점적`으로 살펴 보도록 함

### 15.3.1 선언과 초기화

- `const 키워드`로 선언한 변수는 반드시
- ┗ `선언과 동시에 초기화` 해야함

```js
const foo = 1;
```

> 안그러면 문법 에러 발생

- `const 키워드`로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로
- ┗ `블록 레벨 스코프`를 가지며, `변수 호이스팅 발생 안되는 것처럼` 동작

```js
{
	// 변수 호이스팅이 발생하지 않는 것처럼 동작
	console.log(foo); // Reference Error;
	const foo = 1;
	console.log(foo);
}
// 블록 레벨 스코프를 가짐
console.log(foo); // ReferenceError
```

### 15.3.2 재할당 금지

- var 또는 let 키워드로 선언한 변수 : 재할당이 자유롭지만
- ┗ const 키워드로 선언한 변수는 재할당이 금지됨

```js
const foo = 1;
foo = 2; // TypeError : Assignment to constant variable
```

### 15.3.3 상수

- const 키워드를 선언한 변수에 원시 값을 할당할 경우
- ┣ 변수 값을 변경할 수 없음
- ┣ `원시 값` : `변경 불가능한 값` → `immutable value`
- ┣ 재할당 없이 값을 변경할 수 있는 방법이 없음
- ┗ 이런 특성을 이용해서 const를 상수를 표현하는데 사용

- `변수의 상대 개념인 상수` : `재할당이 금지된 변수`
- ┣ 상수도 값을 저장하기 위한 `메모리 공간이 필요`하기 때문에
- ┣ `변수`라고 할수 있음
- ┣ `변수`는 언제든지 재할당을 통해 `변수 값을 변경 가능`
- ┗ `상수는 재할당이 금지`

> 상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용

```js
let preTaxPrice = 100;

// 세후 가격
// 0.1의 의미를 정확하게 알기 힘듬
// 가독성 down
let afterTaxPrice = preTaxPrice + preTaxPrice * 0.1;

console.log(afterTaxPrice); // 110;
```

- 코드 내에서 사용한 0.1 : 어떤 의므로 사용했는지 알기 힘듬
- ┗ 세율의 경우 바뀌지 않으며 고정적으로 사용 → 상수를 사용
- `const 키워드`로 선언된 변수는 `재할당이 금지`
- ┣ const 키워드로 선언된 변수에 `원시 값을 할당`한 경우
- ┣ `원시 값` : `변경할 수 없는 값`
- ┣ `const 키워드` : `재할당이 금지`되어 있기 때문에
- ┗ 값을 변경할 수 있는 방법이 없음

> 일반적으로 상수의 이름은 대문자로 선언해 상수임을 명확하게 함
> 여러 단어 → 언더스코어(\_)로 구분해서 스네이크 케이스

```js
const TAX_RATE = 0.1;
```

### 15.3.4 const 키워드와 객체

- `const 키워드`로 선언된 변수에 `원시 값`을 할당한 경우
- ┣ 값을 변경할 수 없음
- ┣ 하지만 : `const 키워드로 선언된 변수에 객체를 할당`한 경우
- ┣ `값을 변경이 가능`하다.
- ┣ 변경 불가능한 값인 `원시값`은 재할당 없이 → `변경(불가)` 하지만
- ┗ `변경 가능한 값` : `객체 → 재할당 없이 직접 변경`이 가능

```js
const person = {
	name: 'Lee',
};
// 객체는 변경 가능한 값
// 재할당 없이 변경이 가능
person.name = 'Kim';

console.log(person); // {name: "Kim"}
```

- 변경 불가능한 값에서 본 바와 같이
- ┣ `const 키워드` : `재할당을 금지`할 뿐
- ┣ `불변`을 의미하지는 않음
- ┣ `프로퍼티 동적 생성`, `삭제`, `프로퍼티 값 변경`을 통해서
- ┣ `객체를 변경하는 것은 가능`함
- ┗ `객체가 변경되더라도` `변수에 할당된 참조 값은 변경 X`

## 15.4 var vs let vs const

- 변수 선언에는 기본적으로 `const를 사용`하고
- ┣ `let` : `재할당이 필요한 경우`에 한정해 사용하는 것이 좋음
- ┣ `const` 키워드를 사용하면 의도치 않은 `재할당 불가 가능`
- ┗ `var`, `let`, `const`는 다음과 같을 때 사용하는 권장

1. `ES6`를 사용한다면 `var 키워드는 사용하지 않는 것이 좋음`

2. `재할당`이 필요한 경우에 한정해 `let 키워드`를 사용
   ┗ `변수의 스코프`는 `최대한 좁게` 만듬

3. 변경이 발생하지 않고 `읽기 전용`으로 사용하는(재할당 필요없는)
   - ┣ `원시 값`과 `객체`에는 `const` `키워드`를 사용
   - ┗ `const 키워드` : 재할당 금지 → `var`, `let` 보다 `안전`

- 변수를 선언하는 시점에는 재할당이 필요할지 잘모름
- ┣ `객체` : 의외로 `재할당 하는 경우는 드뭄`
- ┣ `변수 선언` : `const`를 사용
- ┣ 반드시 재할당이 필요하다면 반드시 재할당이 필요한지 다시 생각
- ┗ 그 때 `const`를 `let으로 변경`해서 사용

> 결론 const쓰고 let 필요할 때만 사용
