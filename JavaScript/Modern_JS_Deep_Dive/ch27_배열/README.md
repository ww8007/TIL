# 27. 배열

## 27.1 배열이란?

- 배열(array) : 여러 개의 값을 순차적으로 나열한 자료구조
- ┣ 사용 빈도가 매우 높은 가장 기본적인 자료구조
- ┣ JS의 경우 배열을 다루기 위한 유용한 메서드 다수 제공
- ┣ 배열 : 사용 빈도가 높으므로
- ┣ 배열 메서드를 능숙하게 다룰 수 있다면 코딩에 매우 도움
- ┗ 간단한 배열

> 배열 리터럴을 이용한 배열 생성

```js
const arr = ['apple', 'banana', 'orange'];
```

- 배열이 가지고 있는 값 : `요소(element)`
- ┣ JS 모든 값은 배열의 요소가 될 수 있음
- ┣ 1. 원시값, 2. 객체, 3. 함수, 4. 배열
- ┣ JS에서 값으로 인정하는 모든 것은 배열의
- ┣ 요소가 될 수 있음

- ┣ `배열의 요소` : 자신의 위치를 나타내는
- ┣ 0 이상의 `정수인 인덱스(index)를 가짐`
- ┣ 인덱스 : 배열의 요소에 접근할 때 사용함
- ┣ 대부분의 프로그래밍 언어에서 인덱스 :
- ┗ `0부터 시작하게 됨`

- 위 예제의 배열 arr은 3개의 요소
- ┣ 1. apple
- ┣ 2. banana
- ┗ 3. orange로 구성

> 요소의 접근 : 대괄호 표기법을 사용

    대괄호 내에는 접근하고 싶은
    ┗ 요소의 인덱스를 지정함

```js
arr[0]; // 'apple'
arr[1]; // 'banana'
arr[2]; // 'orange'
```

- 배열 : 요소의 개수 → 배열의 길이를 나타내는
- ┗ `length 프로퍼티를 가짐`

```js
arr.length; // 3
```

- 배열 : 인덱스와 length 프로퍼티를 갖기 때문에
- ┗ for문을 통해 순차적으로 요소에 접근 가능

```js
// 배열의 순회
for (let i = 0; i < arr.length; i++) {
	console.log(arr[i]);
}
```

> JS에 배열이라는 타입은 존재하지 않음
> 배열은 객체 타입임

```js
typeof arr; // object
```

- 배열 : 1. `배열 리터럴`
- ┣ 2. `Array 생성자 함수`
- ┣ 3. `Array.of`
- ┣ 4. `Array.from` 메서드로 생성 가능
- ┣ 배열의 생성자 함수 : Array 이며
- ┣ `배열의 프로토타입 객체` :
- ┣ `Array.prototype`임
- ┣ Array.prototype은 `배열을 위한`
- ┗ `빌트인 메서드를 제공`함

```js
const arr = [1, 2, 3];

arr.constructor === Array; // true
Object.getPrototypeOf(arr) === Array.prototype; // true
```

- `배열 : 객체`이지만
- ┗ 일반 객체와는 `구별되는 독특한 특징이 존재`함

| 구분            | 객체                      | 배열          |
| --------------- | ------------------------- | ------------- |
| 구조            | 프로퍼티 키와 프로퍼티 값 | 인덱스와 요소 |
| 값의 참조       | 프로퍼티 키               | 인덱스        |
| 값의 순서       | x                         | o             |
| length 프로퍼티 | x                         | o             |

- 일반 객체와 배열을 구분하는 가장 명확한 차이 :
- ┣ 1. `값의 순서`
- ┣ 2. `length 프로퍼티임`
- ┣ `인덱스로 표현되는 값의 순서`와
- ┣ `length 프로퍼티를 갖는 배열`은
- ┣ 반복문을 통해 `순차적으로 값에 접근`하기
- ┗ `적합한 자료구조`임

```js
const arr = [1, 2, 3];

// 반복문으로 자료구조를 순서대로 순회하기 위해서
// 자료구조의 요소에 순서대로 접근할 수 잇어야 하며
// 자료구조의 길이를 알 수 있어야 함
for (let i = 0; i < arr.length; i++) {
	console.log(arr[i]); // 1  2 3
}
```

- `배열의 장점` : `처음부터 순차적으로 요소에 접근`할 수도 있고
- ┣ 마지막부터 `역순으로 요소에 접근할 수도 있으며`
- ┣ `특정 위치부터 순차적으로 요소에 접근`할 수도 있다는 것
- ┣ 이는 `배열이 인덱스`, 즉 : `값의 순서`와
- ┗ `length 프로퍼티를 가지기 때문에 가능한 것`

## 27.2 자바스크립트 배열은 배열이 아니다

- 자료구조에서 말하는 배열은 동일한 크기의
- ┣ 메모리 공간이 빈틈없이 연속적으로 나열된
- ┣ 자료구조를 뜻하게 됨
- ┣ 즉 : 배열의 요소 → 하나의 데이터 타입으로 통일
- ┣ 서로 연속적으로 인접해 있음
- ┗ 이러한 배열을 `밀집 배열(dense array)`

- 자료구조에서 말하는 배열 : 동일한 크기의 메모리 공간이
- ┗ 빈틈없이 연속적으로 나열된 자료구조임

- 이처럼 일반적인 의미의 배열 :
- ┣ 각 요소가 동일한 데이터 크기를 가지고 있으며
- ┣ 빈틈없이 연속적으로 이어져 있으므로
- ┣ 다음과 같이 인덱스를 통해 단 한번의 연산으로
- ┣ 임의의 `요소에 접근(임의 접근(random access))`
- ┗ `시간 복잡도O(1)` 할 수 있음

> 매우 효율적이며 고속으로 동작함

- 하지만 정열되지 않은 배열에서 특정한 요소를 검색하는 경우
- ┣ 모든 요소를 처음부터 특정 요소를 발견할 때 까지
- ┗ `차례대로 검색(선형 검색(linear search), 시간 복잡도O(n))`

```js
// 선형 검색을 통해 배열에 특정 요소가 있는지 탐색
// 배열에 특정 요소가 존재하면 특정 요소의 인덱스를 반환하고
// 존재하지 않으면 -1을 반환
function linearSearch(array, target) {
	const length = array.length;

	for (let i = 0; i < length; i++) {
		if (array[i] === target) return i;
	}

	return -1;
}
console.log(linearSearch([1, 2, 3, 4, 5, 6], 3)); // 2
console.log(linearSearch([1, 2, 3, 4, 5, 6], 0)); // -1
```

- 또한 배열에 요소를 삽입하거나 삭제하는 경우
- ┣ 배열의 요소를 연속적으로 유지하기 위해서
- ┗ `요소를 이동시켜야 하는 단점`이 존재함

- JS 배열은 지금까지 살펴본 자료구조에서 말하는
- ┣ `일반적인 의미의 배열과 다름`
- ┣ 즉 : 배열의 요소를 위한 각각의 `메모리 공간`은
- ┣ 동일한 크기를 가지지 않아도 되며
- ┣ `연속적으로 이어져 있지 않을 수도 있음`
- ┣ 배열의 요소가 연속적으로 이어져 있지 않는 배열
- ┗ 이를 `희소 배열(sparse array) 이라고 함`

- 이처럼 JS 배열은 엄밀히 말하면 일반적 의미의 배열이 아님
- ┗ `JS 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체`임

```js
// 16.2 프로퍼티 어트리뷰트와 프러퍼티 디스크립터 객체 참고
console.log(Object.getWonPropertyDescriptors([1,2,3]));

{
    '0' {value: 1, writable: true, enumerable: true, configurable: true}
    '1' {value: 2, writable: true, enumerable: true, configurable: true}
    '2' {value: 3, writable: true, enumerable: true, configurable: true}
    'length' {value: 3, writable: true, enumerable: true, configurable: false}
}
```

- 이처럼 JS 배열 : `인덱스를 나타내는 문자열을 프로퍼티 키`로 가지며
- ┣ `length 프로퍼티를 갖는 특수한 객체`임
- ┣ JS 배열의 요소는 사실 `프로퍼티 값`임
- ┣ JS에서 사용할 수 있는 `모든 값은 객체의 프로퍼티 값이 될 수 있음`
- ┗ 어떤 타입의 값 → `배열의 요소가 될 수 있음`

```js
const arr = [
	'string',
	10,
	true,
	null,
	undefined,
	NaN,
	Infinity,
	[],
	{},
	function () {},
];
```

### 일반적인 배열과 JS 배열 비교 장/단점

1. 일반적인 배열은 인덱스로 요소에 빠르게 접근 가능

   - ┣ 그러나 1) `특정 요소를 검색`하거나
   - ┣ 2) `요소를 삽입 또는 삭제`하는 경우에는
   - ┗ `효율적이지 않음`

2. JS 배열 : 해시 테이블로 구현된 객체
   - ┣ 인덱스로 요소에 접근하는 경우 일반적인 배열보다
   - ┣ 성능적인 면에 서 느릴 수 밖에 없는 `구조적 단점 존재`
   - ┣ 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우
   - ┗ 일반적인 배열보다 `빠른 성능을 기대할 수 있음`

- 즉 : JS 배열은 `인덱스로 배열 요소에 접근하는 경우`에는
- ┣ 일반적인 배열보다 느리지만
- ┣ 1. `특정 요소를 검색`하거나
- ┣ 2. `요소를 삽입 또는 삭제`하는 경우에는
- ┣ `일반적인 배열보다 빠름`
- ┣ JS 배열은 인덱스로 접근하는 경우의 성능 대신
- ┣ `특정 요소를 탐색`하거나 `배열 요소를 삽입` 또는 `삭제하는 경우`의
- ┗ `성능을 선택`한 것

- 인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수밖에
- ┣ 없는 구조적인 단점을 보완하기 위해
- ┣ 대부분의 모든 JS 엔진은 배열을 일반 객체와 구별하여
- ┣ 좀 더 배열처럼 동작하도록 최적화하여서 구현을 하였음
- ┣ 배열과 일반 객체의 성능을 테스트해보면
- ┗ `배열이 일반 객체보다 약 2배 정도 빠르다는 것`을 알 수 있음

```js
const arr = [];

console.log(time('Array Performance Test'));

for (let i = 0; i < 1000000; i++) {
	arr[i] = i;
}

console.timeEnd('Array Performance Test');
// 약 340ms

const obj = {};

console.log('Object Performance Test');

for (let i = 0; i < 1000000; i++) {
	obj[i] = i;
}

console.timeEnd('Object Performance Test');
```

## 27.3 length 프로퍼티와 희소 배열

- `length 프로퍼티` : 요소의 개수
- ┣ 즉 : 배열의 길이를 나타내는 0 이상의 정수를 값으로 가짐
- ┣ length 프로퍼티의 값은 빈 배열일 경우 0 이며
- ┗ 빈 배열이 아닐 경우 가장 큰 인덱스에 1을 더한 것과 같음

```js
[].length; // 0
[1, 2, 3].length; // 3
```

- length 프로퍼티의 값 :
- ┣ 0 ~ 2\*\*32 -1 미만의 양의 정수
- ┣ 즉 : 배열은 요소를 최대 `2**32 -1 (4,294,967,295)개`
- ┣ 가질 수 있음
- ┣ 따라서 → 배열에서 사용할 수 있는 가장 작은 인덱스는
- ┗ 0 이며 가장 큰 인덱스 : `2 ** 32 - 2`임

```js
const arr = [1, 2, 3];
console.log(arr.length); // 3

// 요소 추가
arr.push(4);
// 요소를 추가하면 length 프로퍼티의 값이 자동 갱신됨
console.log(arr.length); // 4

// 요소 삭제
arr.pop();
// 요소를 삭제시 동일하게 자동 갱신
```

- length 프로터의 값 : `요소의 개수`
- ┣ 즉 : 배열의 길이를 바탕으로 결정되지만
- ┣ `임의의 숫자 값을 명시적으로 할당`할 수도 있음
- ┣ 현재 length 프로퍼티 값보다 `작은 숫자 값을 할당`하면
- ┗ `배열의 길이가 줄어들음`

```js
const arr = [1, 2, 3, 4, 5];

// 현재 length 프로퍼티의 값인 5보다 작은 3을 할당
arr.length = 3;

// 배열의 길이가 5에서 3으로 줄어들임
console.log(arr); // [1, 2, 3]
```

- 주의 할 점 : length 프로퍼티 값보다 큰 숫자 값을
- ┣ 할당하는 경우임
- ┣ 이때 length 프로퍼티 값은 변경되지만
- ┗ `실제로 배열의 길이가 늘어나지는 않음`

> 실제보다 큰 값을 반영하는 경우

    반영은 되지만
    ┣ 실제 배열에는 아무런 영향이 없음
    ┣ 값 없이 비어 있는 요소를 위해
    ┣ 메모리 공간 확보 X
    ┗ 빈 요소를 생성하지도 않음

- 이처럼 배열의 요소가 연속적으로
- ┣ 위치하지 않고 일부가 비어 있는 배열을
- ┣ 희소 배열이라고 함

- JS : `희소 배열을 문법적으로 허용`
- ┣ 배열의 뒷부분만 비어 있어서
- ┣ 요소가 연속적으로 위치하는 것처럼
- ┣ 보일 수 있으나 중간이나 앞부분이 비어
- ┗ 있을 수 있음

```js
// 희소 배열
const sparse = [, 2, , 4];

// 희소 배열의 length 프로퍼티 값은 요소의 개수와 일치하지 않음
console.log(sparse.length); // 4
console.log(sparse); // [empty, 2, empty, 4]

// 배열 sparse에는 인덱스가 0, 2인 요소가 존재하지 않음
console.log(Object.getOwnPropertyDescriptors(sparse));
```

- 일반적인 배열의 length :
- ┣ 배열의 요소 개수 → 즉 : 배열의 길이와 언제나 일치
- ┣ 그러나 희소 배열의 경우 length와 배열 요소의 개수
- ┣ 일치하지 않게됨
- ┣ `희소 배열의 length :` `희소 배열의 실제 요소 개수`보다
- ┗ `언제나 크다`

> 희소 배열의 경우 사용하지 않는 것이 좋음

    배열에는 같은 타입의 요소를
    ┗ 연속적으로 위치시키는 것이 최선
