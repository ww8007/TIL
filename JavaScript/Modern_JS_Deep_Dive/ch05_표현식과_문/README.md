# 5 표현식과 문

- 지금까지 값이라는 용어 자주 사용
- ┣ 용어를 알고 있다고 생각하지만 직접 설명하려면 난감함
- ┣ 개념을 이해한다는 것 → 용어를 정확히 이해하고 설명할 수 있다는 점
- ┗ 만약 용어의 의미를 정확히 설명 못함 → 이해를 못함

## 5.1 값

- `값(value)`은 `식(표현식(expression))`이 `평가(evaluate)`되어
- ┣ 생성된 결과를 뜻함
- ┗ 평가 : 식을 해석해서 값을 생성하거나 참조하는 것

```js
// 10 + 20 은 평가되어 숫자 값 30을 생성
10 + 20; //30
```

- 모든 값을 데이터 타입을 가지게 되며
- ┣ 메모리에 `2진수` → `비트(bit)`의 나열로 저장이 됨
- ┗ 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석 가능

- 변수의 경우 → 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
- ┣ 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- ┗ 고로 변수에 할당되는 것은 `값`

```js
var sum = 10 + 20;
```

- 위의 경우 sum 변수에 할당되는 것은 `10 + 20`이 아닌
- ┣ `10 + 20` 이 평가된 결과인 숫자 값 30
- ┣ 즉, 변수 이름 sum이 기억하는 메모리 공간에 저장된 것은
- ┣ `10 + 20` 이 아닌 → `값 30`
- ┗ 고로 10 + 20의 경우는 할당 이전에 평가되어 값을 생성해야 함

> 값의 경우 다양한 방법으로 생성될 수 있음

    1. 식으로 생성
    2. 기본적인 방법인 리터럴을 이용하는 것

## 5.2 리터럴

- `리터럴(literal)`은 사람이 이해할 수 있는 문자 또는
- ┗ 약속된 기호를 사용해 값을 생성하는 `표기법(notation)`을 말함

```js
3;
```

- 위의 경우 3은 단순한 숫자가 아닌 → `숫자 리터럴`
- ┣ 사람이 이해할 수 있는 아라비아 숫자를 이용해서 숫자 리터럴 3 코드 기술시
- ┗ JS 엔진은 이를 평가해서 `숫자 값 3`을 생성

- 리터럴은 사람이 이해할 수 있는 문자(아라비아, 숫자, 알파벳, 한글)
- ┣ 또는 미리 약속된 기호 `('', "", [], {})`로 표기한 코드
- ┣ JS 엔진은 코드가 실행되는 시점인 `런타임(runtime)`에 리터럴을 평가해서
- ┣ 값을 생성하게 됨
- ┗ 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있음

| 리터럴             | 예시                               | 비고                    |
| ------------------ | ---------------------------------- | ----------------------- |
| 정수 리터럴        | 100                                |                         |
| 부동소수점 리터럴  | 10.5                               |                         |
| 2진수 리터럴       | 0b0100001                          | 0b로 시작               |
| 8진수 리터럴       | 0o101                              | ES6에서 도입, 0o로 시작 |
| 16진수 리터럴      | 0x41                               | ES6에서 도입, 0x로 시작 |
| 문자열 리터럴      | 'Hello' <br/> "World"              |                         |
| 불리언 리터럴      | true <br/> false                   |                         |
| null 리터럴        | null                               |                         |
| undefined 리터럴   | undefined                          |                         |
| 객체 리터럴        | { name : 'Lee', address: 'Seoul' } |                         |
| 배열 리터럴        | [1,2,3]                            |                         |
| 함수 리터럴        | function() {}                      |                         |
| 정규 표현식 리터럴 | /[A-Z]+/g                          |                         |

## 5.3 표현식

- `표현식(expression)`은 값으로 평가될 수 잇는 `문(statement)`임
- ┗ 표현식이 평가되면 → 새로운 값을 생성하거나 기존 값을 참조

- 앞서 살펴본 `리터럴은 값으로 평가` → `리터럴 또한 표현식`임

```js
var score = 100;
```

- 위 예제의 100 → 리터럴
- ┣ 리터럴 100은 JS 엔진에 의해 평가되어 값을 생성하므로
- ┗ 그 자체로 표현식임

```js
var score = 50 + 50;
```

- `50 + 50`은 리터럴과 연산자로 이루어져 있음
- ┣ 그러나 `50 + 50` 또한 평가되어 100을 생성하기 때문에
- ┗ 이 또한 `표현식`임

> score 변수 참조

```js
score;
```

- `변수 식별자를 참조`하면 → `변수 값`으로 `평가`
- ┗ 식별자 참조는 `값을 생성 X` → `값으로 평가` → `표현식`

- 표현식의 경우 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합
- ┣ 다양한 표현식이 존재 하지만 값으로 평가된다는 점에서 동일
- ┗ 값으로 평가될 수 있느 문은 모두 → `표현식`임!!!

```js
// 리터럴 표현식
10;
('Hello');

// 식별자 표현식(선언 이미 존재 가정)
sum;
person.name;
arr[1];

// 연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수, 메서드 호출 표현식(선언 이미 존재 가정)
square();
person.getName();
```

- 표현식 → 값으로 평가
- ┣ 표현식, 표현식이 평가된 값 → 동등한 관계 → `동치(equivalent)`
- ┣ ex) 1 + 2 = 3 에서 1 + 2 는 3과 동치
- ┣ JS 에서도 1 + 2 는 평가되어 → 값 3을 생성하기 때문에 3과 동치
- ┣ 표현식 → 값 처럼 사용될 수 있음
- ┗ 이것은 문법적으로 값이 위치할 수 잇는 자리에는 표현식도 위치할 수 있다는 것을 의미

- ex ) 산술 연산자 +의 좌항, 우항 → 숫자 값이 위치해야 함
- ┗ 이 때 숫자 값으로 평가될 수 있는 표현식이라면 숫자 값 대신 사용 가능

```js
var x = 1 + 2;

// 식별자 표현식 x는 3으로 평가
x + 3;
```

- 위 예제의 x + 3 → 표현식
- ┣ `+` 연산자의 경우 좌항, 우항의 값을 산술 연산하는 연산자
- ┣ 좌항, 우항에는 숫자 값이 위치해야 함
- ┣ x는 할당되어 잇는 숫자 값 3으로 평가됨
- ┗ 따라서 숫자 값이 위치해야 할 자리에는 표현식 x를 사용할 수 있음

> 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있음

## 5.4 문

- 앞으로 JS 설명할 때 `문(statement)`, `표현식(expression)`이라는 용어 자주 등장
- ┣ 문과 표현식을 구별하고 해석 가능 → JS에 대한 심도 높은 이해가 가능
- ┗ 버그를 줄이고 코드 품질 높이는데도 도움을 줌

- 문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위
- ┣ 문의 집합으로 이뤄진 것이 → 프로그램
- ┗ 문을 작성하고 순서에 맞게 나열 → 프로그래밍

- 문은 여러 토큰으로 구성
- ┣ `토큰(token)` : `문법적인 의미`를 가지며, 문법적으로 더 이상 나눌 수 없는 기본 요소
- ┣ `키워드`, `식별자`, `연산자`, `리터럴`, `세미콜론(;)`이나 `마침표(.)` 등의 `특수 기호`들은
- ┗ `문법적인 의미`를 가지며, `문법적으로 더 이상 나눌 수 없는 코드의 기본요소` → 토큰

```js
var sum = 1 + 2;
//t  t  t t t tt
// t → token
```

- 문 → 명령문이라고도 부름
- ┣ 문은 컴퓨터에게 내리는 명령
- ┣ 문이 실행되면 명령이 실행되고 무슨 일인가가 일어남
- ┣ 문은 `선언문`, `할당문`, `조건문`, `반복문` 등으로 구별 가능
- ┣ `변수 선언문`을 실행 → `변수가 선언`
- ┣ `할당문` 실행 → `값이 할당`
- ┣ `조건문` 실행 → `지정한 조건`에 따라 실행할 `코드 블록({...})`
- ┗ 반복문 실행 → 특정 코드 블록이 반복 실행

```js
//변수 선언문
var x;

// 할당문
x = 5;

// 함수 선언문
function foo() {}

// 조건문
if (x > 1) {
	console.log(x);
}

// 반복문
for (var i = 0; i < 2; i++) {
	console.log(i);
}
```

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론(;)은 문의 종료를 나타냄
- ┣ JS는 세미콜론을 이용해 → 문이 종료한 위치를 파악
- ┣ 순차적으로 하나씩 문을 실행
- ┣ 따라서 문을 끝낼 때는 세미콜론을 붙여야 함
- ┣ 단 0개 이상의 문을 중괄호로 묶은 `코드 블록({...})`의 경우
- ┣ 뒤에 세미콜론을 붙이지 않게 됨
- ┗ 코드 블록은 언제나 문의 종료를 의미하는 `자체 종결성(self closing)` 갖는다.

- 문의 끝에 붙이는 세미콜론은 옵션
- ┣ 이말은 세미콜론은 생략 가능
- ┣ JS 엔진이 문의 끝이라고 예측되는 지점에 자동으로
- ┣ 세미콜론 붙여주는
- ┗ `세미콜론 자동 삽입 기능(ASI(automatic semicolon insertion))` 암묵적으로 수행

- 세미콜론 자동 삽입 기능의 동작과 개발자 예측을 잘못해서 오류가 생기는 경우도 존재

```js
function foo() {
	return;
	{
	}
	// ASI 예측 → return; {};
	// 개발자 예측 → return {};
}
console.log(foo()); //undefined

var bar = (function () {})(function () {})();
// ASI → var bar = function () {}(function() {})();
// 개발자 → var bar = function () {}; (function() {})();
// TypeError: (intermediate value)(...) is not a function
```

## 표현식인 문과 표현식이 아닌 문

- 표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있음

```js
// 변수 선언문은 값으로 평가될 수 없기 때문에 표현식이 아님
var x;
// 1, 2, 1+2, x = 1 + 2는 모두 표현식
// x = 1 + 2; 의 경우 표현식이면서 완전한 문이기도 함
x = 1 + 2;
```

- 표현식과 문이 비슷해서 구별하기 어렵다고 느낄 수 있지만
- ┗ 표현식과 문을 구별하는 방법은 의외로 간단

- 문에는 표현식은 문과 표현식이 아닌 문이 존재
- ┣ 표현식인 문 → 값으로 평가될 수 있는 문
- ┗ 표현식이 아닌 문 → 값으로 평가될 수 없는 문

- 변수 선언문은 값으로 평가 X
- ┗ 고로 표현식이 아닌 문

- 할당문의 경우 값을 평가 가능
- ┗ 고로 표현식인 문

- 표현식인 문과 아닌 문을 구별하는 가장 간단하고 명료한 방법은
- ┗ 변수에 할당해 보는 것

- 표현식인 문은 값으로 평가되기 때문에 변수에 할당 가능
- ┗ 그러나 표현식이 아닌 문은 값으로 평가 X → 변수 할당 시 에러

```js
var foo = var x; // Syntax Error
```

> 변수 선언문은 값 처럼 사용 불가

```js
// 변수 선언문은 표현식 아닌 문
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문
// 할당문은 표현식인 문
x = 100;
```

- 이에 반해 위 예제의 `x = 100` 이 자체가 표현식
- ┗ `할당문은 표현식인 문`이기 때문에 값처럼 사용 가능

```js
// 표현식인 문은 값처럼 사용가능
var foo = (x = 100);
console.log(foo); // 100
```

- `할당문을 값처럼 변수에 할당`
- ┣ 표현식인 할당문은 할당된 값으로 평가
- ┣ 즉 x = 100은 x 변수에 할당한 값 100으로 평가
- ┗ 고로 foo 변수에는 100이 할당

> 완료값

    크롬 개발자 도구에서 표현식이 아닌 문을 실행 시
    ┣ 언제나 undefined를 출력
    ┣ 이를 완료 값이라고 함
    ┣ 완료 값은 평가 결과가 아님
    ┗ `고로 변수에 할당할 수도 없고 참조도 불가`

> 정리

    변수 선언문 → 표현식이 아닌 문
    할당 문 → 표현식인 문
    표현식인지 아닌지 확인은 변수에 할당해보기
