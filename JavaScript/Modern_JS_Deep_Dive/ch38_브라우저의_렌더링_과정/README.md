# 38. 브라우저의 렌더링 과정

- 구글의 V8 JS 엔진으로 빌드된
- ┣ `JS 런타임 환경(runtime environment)인`
- ┣ Node.js의 등장으로
- ┣ JS는 웹 브라우저를 벗어난
- ┣ 서버 사이드 애플리케이션 개발에서도
- ┣ 사용이 가능한 범용 개발 언어가 되었음
- ┣ 하지만 가장 많이 사용 되는 분야 :
- ┣ `웹브라우저 환경의 웹페이지/애플리케이션의`
- ┗ `클라이언트 사이드임`

- 대부분의 프로그래밍 언어 :
- ┣ 운영체제(Operating System, OS)나
- ┣ 가상 머신(Virtual Machine, VM) 위에서
- ┣ 실행 되지만
- ┣ 웹 애플리케이션의 `클라이언트 사이드 JS는`
- ┣ `브라우저에서 HTML, CSS와 함께 실행됨`
- ┣ 따라서 → 브라우저 환경을 고려할 때
- ┗ `더 효율적인 클라이언트 사이드 JS 프로그래밍이 가능함`

- 이를 위해서 브라우저가 HTML, CSS, JS로 작성된
- ┣ `텍스트 문서를 어떻게 파싱(해석) 하여`
- ┗ `브라우저에서 렌더링 하는지에 대해서 학습`

## 목차

- [38. 브라우저의 렌더링 과정](#38-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95)
  - [파싱 (parsing)](#%ED%8C%8C%EC%8B%B1-parsing)
  - [렌더링(rendering)](#%EB%A0%8C%EB%8D%94%EB%A7%81rendering)
  - [38.1 요청과 응답](#381-%EC%9A%94%EC%B2%AD%EA%B3%BC-%EC%9D%91%EB%8B%B5)
  - [38.2 HTTP 1.1과 HTTP 2.0](#382-http-11%EA%B3%BC-http-20)
  - [38.3 HTML 파싱과 DOM 생성](#383-html-%ED%8C%8C%EC%8B%B1%EA%B3%BC-dom-%EC%83%9D%EC%84%B1)
  - [38.4 CSS 파싱과 CSSOM 생성](#384-css-%ED%8C%8C%EC%8B%B1%EA%B3%BC-cssom-%EC%83%9D%EC%84%B1)
  - [38.5 렌더 트리 생성](#385-%EB%A0%8C%EB%8D%94-%ED%8A%B8%EB%A6%AC-%EC%83%9D%EC%84%B1)
  - [38.6 자바스크립트 파싱과 실행](#386-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%8C%EC%8B%B1%EA%B3%BC-%EC%8B%A4%ED%96%89)
    - [토크나이징(tokenizing)](#%ED%86%A0%ED%81%AC%EB%82%98%EC%9D%B4%EC%A7%95tokenizing)
    - [파싱(parsing)](#%ED%8C%8C%EC%8B%B1parsing)
    - [바이트코드 생성과 실행](#%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%8B%A4%ED%96%89)
  - [38.7 리플로우와 리페인트](#387-%EB%A6%AC%ED%94%8C%EB%A1%9C%EC%9A%B0%EC%99%80-%EB%A6%AC%ED%8E%98%EC%9D%B8%ED%8A%B8)
  - [38.8 자바스크립트 파싱에 의한 HTML 파싱 중단](#388-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%8C%EC%8B%B1%EC%97%90-%EC%9D%98%ED%95%9C-html-%ED%8C%8C%EC%8B%B1-%EC%A4%91%EB%8B%A8)
  - [38.9 script 태그의 async/defer 어트리뷰트](#389-script-%ED%83%9C%EA%B7%B8%EC%9D%98-asyncdefer-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8)
    - [async 어트리뷰트](#async-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8)
    - [defer 어트리뷰트](#defer-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8)

## 파싱 (parsing)

- `파싱(구문 분석 syntax analysis)` :
- ┣ 프로그래밍 언어의 문법에 맞게 작성된
- ┣ `텍스트 문서를 읽어 들여`
- ┣ 실행하기 위해 텍스트 문서의 문자열을
- ┣ `토큰(token)으로 분해(어휘 분석 lexical analysis)하고`
- ┣ `토큰에 문법적 의미와 구조를 반영하여` →
- ┣ 트리 구조의 자료구조인 `파스 트리`
- ┣ `(parse tree/syntax tree)를 생성하는`
- ┗ 일련의 과정을 말함

- 일반적으로 파싱이 완료된 이후에는
- ┣ 파스 트리를 기반으로 `중간 언어`
- ┣ `(intermediate code)`인
- ┗ `바이트코드(byte code)`를 생성하고 실행함

## 렌더링(rendering)

- 렌더링 :
- ┣ HTML, CSS, JS로 작성된 문서를 파싱하여
- ┗ `브라우저에 시각적으로 출력하는 것을 의미함`

> 브라우저의 렌더링 과정

1. 브라우저는 HTML, CSS, JS, 이미지

- ┣ 폰트 등 렌더링에 필요한 리소스를 요청하고
- ┗ 서버로부터 응답을 받게됨

2. 브라우저의 렌더링 엔진 :

- ┣ 서버로부터 응답된 `HTML, CSS를 파싱하여`
- ┣ `DOM과 CSSOM을 생성`하고
- ┗ 이들을 `결합하여 렌더 트리를 생성함`

3. 브라우저의 JS 엔진 :

- ┣ 서버로부터 응답된 JS를 파싱하여
- ┣ `AST(Abstract Syntax Tree)를 생성하고`
- ┣ `바이트코드로 변환하여 실행함`
- ┣ 이때 JS는 `DOM API를 통해`
- ┣ `DOM이나 CSSOM을 변경`할 수 있음
- ┗ 변경된 `DOM과 CSSOM은 렌더 트리로 결합됨`

4. 렌더 트리를 기반으로 HTML 요소의

- ┣ `레이아웃(위치와 크기)을 계산하고`
- ┗ 브라우저 화면에 HTML 요소를 페인팅함

## 38.1 요청과 응답

- 브라우저의 핵심 기능은
- ┣ 필요한 리소스(HTML, CSS, JS, 이미지, 폰트
- ┣ 등의 정적 파일, 서버가 동적으로 생성한 데이터)를
- ┣ `서버에 요청(request), 서버로부터 응답(response)받아`
- ┗ `브라우저에 시각적으로 렌더링 하는 것임`

- 즉: 렌더링에 필요한 리소스는 모두 서버에 존재하므로
- ┣ 필요한 리소스를 `서버에 요청하고`
- ┗ 서버가 응답한 `리소스를 파싱하여 렌더링함`

- 서버에 요청을 전송하기 위해
- ┣ 브라우저 : 주소창을 제공함
- ┣ `브라우저의 주소창에 URL을 입력하고`
- ┣ `엔터 키를 누르면 URL의 호스트 이름이`
- ┣ `DNS(Domain Name System)을 통해` → `IP로 변환되고`
- ┗ 이 변환된 `IP 주소를 갖는 서버에게 요청을 전송함`

- 예를 들어 브라우저의 주소창에
- ┣ https://google.com을 입력하고 엔터를 누르면
- ┣ `루트 요청(/, 스킴(scheme)과 호스트(host)만으로 구성된 URI에`
- ┣ `의한 요청)이 google.com 서버로 전송됨`
- ┣ 루트 요청에는 `명확히 리소를를 요청하는 내용이 없지만`
- ┣ 일반적으로 서버 : 루트 요청에 대해 암묵적으로
- ┣ `index.html을 응답하고도록 기본 설정이 되어 있음`
- ┗ 즉: https://google.com → https://google.com/index.html과 같음

- 따라서 서버 : 루트 요청에 대해 서버의 루트 폴더에
- ┣ 존재하는 정적 파일인 index.html을 클라이언트(브라우저)로
- ┣ 응답을 하게 됨
- ┣ `만약 index.html이 아닌 다른 정적 파일을 `
- ┣ 서버에 요청하려면 브라우저의 주소창에
- ┣ `https://google.com/assets/data/data.json과 같이`
- ┣ `경로, 파일 이름을 URI의 호스트 뒤의 패스(path)`에 기술하여
- ┗ 서버에 요청하게 됨 → 서버는 이에 대한 request 전송

- `반드시 브라우저의 주소창에 정적 파일만 요청하는`
- ┗ 것은 아님 → 동적 파일도 요청이 가능함

- 요청과 응답 : 개발자 도구의 Network 패널에서 확인 가능
- ┣ 요청을 해보면 index.html 뿐만 아닌
- ┣ CSS, JS, 이미지, 폰트 등의 다른 파일들도
- ┣ 응답된 것을 확인이 가능함
- ┗ `요청 하지 않은 파일 들이 응답된 이유?`

- 이는 브라우저 렌더링 엔진 :
- ┣ HTML(index.html)을 파싱하는 도중에
- ┣ 외부 리소스를 로드하는 태그
- ┣ 즉 : `CSS 파일을 로드하는 → link 태그`
- ┣ `이미지 파일 로드 → img 태그`
- ┣ `JS 로드 → script 태그` 등을 만나면
- ┣ `HTML 파싱을 일시 중단하고`
- ┗ `해당 리소스 파일을 서버로 요청하기 때문임`

## 38.2 HTTP 1.1과 HTTP 2.0

- `HTTP(HyperText Transfer Protocol)` :
- ┣ 웹에서 브라우저와 서버가 통신하기 위한
- ┣ `프로토콜(규약)임`
- ┣ 99년 HTML, URL과 함께 팀 버너리 경이 고안한
- ┣ HTTP는 91년 최초 문서화 되었고
- ┣ 96년 HTTP/1.0
- ┣ 99년 HTTP/1.1
- ┗ 2015년 HTTP/2가 발표됨

> HTTP/1.1과 HTTP/2의 차이점 학습

- HTTP/1.1 :
- ┣ 기본적으로 커넥션(connection)당
- ┣ 하나의 요청과 응답만 처리함
- ┣ 즉 : `여러 개의 요청을 한 번에 전송/응답 불가`
- ┣ 따라서 HTML 문서 내에 포함된 여러개의 리소스 요청
- ┗ 들이 `모두 개별적으로 전송/응답이 이루어짐`

> 요청할 리소스 개수에 비례해

    응답 시간이 증가하는 단점 존재

- 이처럼 : HTTP/1.1은 다중 요청/응답이 불가하다는
- ┣ 단점이 있지만 `HTTP/2 : 다중 요청/응답이 가능함`
- ┗ 1.1에 비해 2가 페이지 로드 속도가 `약 50% 빠름`

## 38.3 HTML 파싱과 DOM 생성

- 브라우저의 요청에 의한 서버가 응답한
- ┣ HTML 문서 : 문자열로 이루어진 순수한 텍스트임
- ┣ 순수한 텍스트인 HTML 문서를 브라우저에 시각적으로
- ┣ 픽셀로 렌더링 하기 위해서는
- ┣ `HTML 문서 → 브라우저가 이해 가능한 자료구조(객체)로`
- ┗ `변환하여 메모리에 저장해야함`

- 예를 들어 서버로부터 index.html 전송 받음
- ┣ `브라우저의 렌더링 엔진` :
- ┣ `응답받은 HTML 문서를 파싱하여`
- ┣ 브라우저가 이해할 수 있는 자료구조인
- ┗ `DOM(Document Object Model)을 생성함`

- 바이트
- ┣ 문자
- ┣ 토큰
- ┣ 노드 : html, head, meta, link, body
- ┗ DOM

1. 서버에 존재하던 HTML 파일 :

- ┣ `브라우저의 요청에 의해 응답됨`
- ┣ 이때 서버는 브라우저가 요청한 HTML 파일을
- ┣ 읽어들여서 `메모리에 저장하고`
- ┣ `다음 메모리에 저장된 바이트(2진수)를 인터넷을`
- ┗ `경유하여 응답함`

2. 브라우저 :

- ┣ `서버가 응답한 HTML 문자를 바이트(2진수) 형태로`
- ┣ 응답을 받게 됨
- ┣ 응답된 바이트 형태의 HTML 문서는
- ┣ `meta 태그의 charset 어트리뷰트에 의해서`
- ┣ `지정된 인코딩 방식(ex : UTF-8)을 기준으로`
- ┗ 문자열로 변환되게 됨

- 참고로 meta 태그의
- ┣ charset 어트리뷰트에 선언된 인코딩 방식 :
- ┣ `content-type: text/html; charset=utf-8`과 같이
- ┣ `응답 헤더(response header)`에 담겨서 응답됨
- ┗ 브라우저는 이를 확인하고 문자열로 변환함

3. 문자열로 변환된 HTML 문서를 읽어 들여

- ┗ `문법적 의미를 갖는 토큰(token)`으로 변환함

4. 각 토큰들은 객체로 변환하여 → `노드(node)`들을 생성함

- ┣ 토큰의 내용에 따라
- ┣ 1. `문서 노드`
- ┣ 2. `요소 노드`
- ┣ 3. `어트리뷰트 노드`
- ┣ 4. `텍스트 노드`가 생성됨
- ┗ 노드는 이후 DOM을 구성하는 기본 요소가 됨

5. HTML 문서 : HTML 요소들의 집합으로 이루어지며

- ┣ HTML 요소는 중첩 관계를 가지게 됨
- ┣ 즉 : HTML 요소의 콘텐츠 영역(시작 태그 종료 태그 사이)
- ┣ 에는 텍스트 뿐만 아닌 다른 HTML 요소도 포함될 수 있음
- ┣ 이때 HTML 요소 간에는 중첩 관계에 의해서
- ┣ 부자 관계가 형성됨
- ┣ 이러한 `HTML 요소 간의 부자 관계를 반영하여`
- ┣ 모든 `노드들을 → 트리 자료구조로 구성함`
- ┗ 이 노드들로 구성된 `트리 자료구조를 DOM(Document Object Model)`

- 즉 : DOM은 HTML 문서를 파싱한 결과물임

## 38.4 CSS 파싱과 CSSOM 생성

- 렌더링 엔진 : HTML을 처음부터 한 줄씩
- ┣ 순차적으로 파싱하여 DOM을 생성해 나감
- ┣ 이처럼 렌더링 엔진 : DOM을 생성해 나가다가
- ┣ CSS를 로드하는 `link 태그나 style 태그를 만나면`
- ┗ `DOM 생성을 일시 중단함`

- link 태그의 `href 어트리뷰트에 지정된`
- ┣ CSS 파일을 서버에 요청하여 로드한
- ┣ CSS 파일이나 style 태그 내의
- ┣ `CSS를 HTML과 동일한 파싱 과정`
- ┣ (바이트 → 문자 → 토큰 → 노드 → CSSOM)을 거치며
- ┣ `해석하여 CSSOM(CSS Object Model)을 생성함`
- ┣ 이후 CSS 파싱을 완료하면 HTML 파싱이 중단된
- ┗ 부분부터 `파싱을 재개하여 DOM 생성을 다시함`

- CSSOM은 : CSS 상속을 반영하여 생성됨
- ┗ `모든 프로퍼티 → 모든 li 요소에 상속됨`

## 38.5 렌더 트리 생성

- `렌더링 엔진` : 서버로부터 응답된
- ┣ `HTML, CSS를 파싱하여`
- ┣ `각각 DOM과 CSSOM를 생성함`
- ┣ 그리고 이들은 렌더링을 위해서
- ┗ `렌더 트리(render tree)로 결합됨`

- 렌더트리 : 렌더링을 위한 트리 구조의 자료 구조
- ┣ 따라서 브라우저 화면에 렌더링되지 않는 노드
- ┣ `(meta 태그, script 태그 등)와 CSS에 의해 비표시`
- ┣ `(display: none)되는 노드들은 포함하지 않음`
- ┣ 다시 말해 : `렌더 트리는 브라우저 화면에 렌더링되는`
- ┗ `노드들로만 구성됨`

- 이후 완성된 렌더 트리 : 각 HTML 요소의
- ┣ 레이아웃(위치와 크기)을 계산하는데 사용되며
- ┣ 브라우저 화면에 픽셀을
- ┗ `렌더링하는 페인팅(painting) 처리에 입력됨`

- 지금까지 살펴본 `브라우저의 렌더링 과정` :
- ┣ `반복해서 실행될 수 있음`
- ┣ 다음과 같은 경우 반복해서
- ┗ 레이아웃 계산과 페인팅이 재차 실행됨

1. `JS`에 의한 `노드 추가 또는 삭제`

2. 브라우저 창의 리사이징에 의한 `뷰포트(viewport) 크기 변경`

3. HTML 요소의 `레이아웃에 변경을 발생`시키는

- ┣ `width/height, margin, padding, border,`
- ┣ `display, position, top/right/bottom/left` 등의
- ┗ `스타일 변경`

- 레이아웃 계산과 페인팅을 다시 실행하는
- ┣ 리렌더링 → 비용이 많이 드는
- ┣ 성능에 악영향을 주는 작업임
- ┗ `가급적인 리렌더링이 빈번하게 발생하지 않도록함`

## 38.6 자바스크립트 파싱과 실행

- HTML 문서를 파싱한 결과물로서
- ┣ 생성된 DOM : HTML 문서의 구조와 정보뿐만 아닌
- ┣ HTML 요소와 스타일 등을 변경할 수 있는
- ┣ 프로그래밍 인터페이스로서 DOM API를 제공함
- ┣ 즉 : `JS 코드에서 DOM API를 사용하면`
- ┗ 이미 생성된 `DOM을 동적으로 조작할 수 있음`

- CSS 파싱 과정과 마찬가지로
- ┣ 렌더링 엔진 : HTML을 한 줄씩 순차적으로
- ┣ 파싱하여 DOM을 생성해 나가다가
- ┣ 1. `JS 파일을 로드하는 script 태그나`
- ┣ 2. `JS 코드를 콘텐츠로 담은 script 태그를 만나면`
- ┗ `DOM 생성을 일시 중단함`

- 그리고 script 태그의 src 어트리뷰트에 정의된
- ┣ JS 파일을 서버에 요청하여 로드한
- ┣ JS 파일이나 script 태그 내의 JS 코드를
- ┣ `파싱하기 위해 JS 엔진에 제어권을 넘김`
- ┣ 이후 JS 파싱과 실행이 종료되면
- ┣ `렌더링 엔진에게 다시 제어권을 넘겨서`
- ┗ HTML 파싱이 중단된 부분 부터 HTML 파싱을 진행함

> DOM 생성을 재개함

- JS 파싱과 실행은 브라우저의 렌더링 엔진이 아닌
- ┣ JS 엔진이 처리함
- ┣ `JS 엔진은 JS 코드를 파싱하여`
- ┣ `CPU가 이해할 수 있는 저수준 언어(low-level language)로`
- ┣ 변환하고 실행하는 역할을 함
- ┗ 모든 `JS 엔진 : ECMAScript 사양을 준수함`

- 렌더링 엔진으로부터 제어권을 넘겨받은
- ┣ JS 엔진 : JS 코드를 파싱하기 시작함
- ┣ 렌더링 엔진이 HTML과 CSS를 파싱하여
- ┣ DOM과 CSSOM을 생성하듯이
- ┣ `JS 엔진 : JS를 해석하여 AST(Abstract Syntax tree)`
- ┣ `추상적 구문 트리를 생성함`
- ┣ 그리고 `AST를 기반으로 인터프리터가 실행할 수 있는`
- ┗ `중간 코드(intermediate code)인 바이트코드를 생성하여 실행함`

### 토크나이징(tokenizing)

- 단순한 문자열인 JS 소스코드를
- ┣ `어휘 분석(lexical analysis)하여`
- ┣ 문법적 의미를 갖는 코드의 최소 단위인
- ┣ `토큰(token)들로 분해함`
- ┣ 이 과정을 `렉싱(lexing)`이라고 하지만
- ┗ 토크나이징과 미묘한 차이가 존재함

### 파싱(parsing)

- 토큰들의 집합을 `구문 분석(syntactic analysis)하여`
- ┣ `AST(Abstract Syntax Tree) 추상적 구문 트리를 생성함`
- ┣ AST : `토큰에 문법적 의미와 구조를 반영한`
- ┣ `트리 구조의 자료구조임`
- ┣ AST는 인터프리터나 컴파일러만이 사용하는 것이 아님
- ┣ `AST를 사용하면 TypeScript, Babel, Prettier 같은`
- ┣ `트랜스파일러(transpiler)를 구현할 수 있음`
- ┣ AST Explore 웹사이트(https://astexplorer.net)에 방문하면
- ┗ 다양한 오픈소스 JS 파럿를 사용하여 AST 생성 가능

### 바이트코드 생성과 실행

- `파싱의 결과물로서 생성된 AST`
- ┣ 인터프리터가 실행할 수 있는
- ┣ 1. `중간 코드인 바이트코드로 변환`되고
- ┣ 2. `인터프리터에 의해 실행됨`
- ┣ 참고로 V8 엔진의 경우 자주 사용되는 코드는
- ┣ `터보팬(TurboFan)`이라 불리는 컴파일러에 의해
- ┣ `최적화된 머신 코드(optimized machine code)로`
- ┣ `컴파일되어 겅능을 최적화 `
- ┗ 사용빈도 down → 디옵티마이징(deOptimizing)

## 38.7 리플로우와 리페인트

- 만약 JS 코드에 `DOM과 CSSOM을 변경하는`
- ┣ `DOM API가 사용된 경우` :
- ┣ `DOM이나 CSSOM이 변경됨`
- ┣ 이때 변경된 DOM과 CSSOM은 다시
- ┣ `렌더 트리로 결합되고 변경된 트리 기반으로`
- ┣ 레이아웃과 페인트 과정을 거쳐 브라우저 화면에 다시 렌더링
- ┗ 이를 `리플로우(reflow), 리페인트(reflow)`라고 함

- 리플로우 : `레이아웃 계산을 다시 하는 것`
- ┣ 1. `노드 추가/삭제`
- ┣ 2. `요소의 크기/위치 변경`
- ┣ 3. `윈도우 리사이징` 등
- ┣ `레이아웃에 영향을 주는 변경이 발생한 경우에`
- ┗ 한하여 실행됨

- 리페인트 : `재결합된 렌더 트리를 기반으로`
- ┗ `다시 페인트를 하는 것을 말함`

> 결론

    리플로우, 리페인트의 경우
    ┣ 순차적으로 동시 처리 개념이 아님
    ┣ 레이아웃에 영향이 없다면
    ┗ 리플로우 없이 리페인트만 실행

## 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단

- 지금까지 살펴본 바와 같이 렌더링 엔진과
- ┣ JS 엔진 : 병렬적으로 파싱으로 파싱을 하는 것이 아닌
- ┗ `직렬적으로 파싱을 진행함`

- 이처럼 브라우저 : `동기적(synchronous)`으로
- ┣ 즉 : 위에서 → 아래 방향으로 순차적으로
- ┣ HTML, CSS, JS를 파싱하고 실행함
- ┣ `이것은 script 태그의 위치에 따라`
- ┣ `HTML 파싱이 블로킹되어 DOM 생성 지연될 수 있음을`
- ┗ 의미함 → 따라서 `script 태그 위치는 중요한 의미를 가짐`

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<link rel="stylesheet" href="style.css" />
		<script src="app.js"></script>
	</head>
	<body>
		<li id="apple">Apple</li>
		<li id="banana">Banana</li>
		<li id="orange">Orange</li>
	</body>
</html>
```

- 위 예제의 경우 app.js 파싱과 실행 이전까지는
- ┣ `DOM의 생성이 일시 중단됨`
- ┣ 이때 JS 코드(app.js)에서
- ┣ `DOM이나 CSSOM을 변경하는 DOM API를 사용하는 경우`
- ┣ `DOM이나 CSSOM이 이미 생성되어 있어야함`
- ┗ 만약 생성 안된 경우 `문제 발생 가능`

> 이러한 문제를 해결하기 위해서

    body 요소의 가장 아래에
    ┣ JS를 위치시키는 것은
    ┗ 좋은 아이디어임

1. DOM이 완성되지 않은 상태에서

- ┗ `DOM을 조작하면 에러가 발생 가능`

2. `JS 로딩/파싱/실행`으로 인해

- ┣ HTML 요소들의 `렌더링에 지장받는 일이 `
- ┗ `발생하지 않아 페이지 로딩 시간이 단축됨`

- JS가 실행되기 이전에 DOM 생성이
- ┣ 완료되어 렌더링 되므로
- ┗ `페이지 로딩 시간이 단축되는 이점도 있음`

## 38.9 script 태그의 async/defer 어트리뷰트

- 앞에서 살펴본 JS 파싱에 의한
- ┣ `DOM 생성이 중단(blocking)되는 문제를`
- ┣ 근본적으로 해결하기 위해서
- ┣ `HTML5 부터 script 태그에`
- ┗ `async/defer 어트리뷰트가 추가됨`

- `async`, `defer` 어트리뷰트 :
- ┣ 다음과 같이 `src 어트리뷰트를 통해`
- ┣ `외부 JS 파일을 로드하는 경우에만`
- ┗ 사용이 가능함

> 즉 : 인라인 JS 코드에서는 사용이 불가함

```html
<script async src="extern.js"></script>
<script defer src="extern.js"></script>
```

- async, defer 어트리뷰트를 사용하면
- ┣ HTML 파싱과
- ┣ 외부 JS 파일 로드가 `비동기적(asynchronous)`
- ┗ 으로 이루어지게 됨

- 하지만 JS의 실행 시점에 차이가 있음

### async 어트리뷰트

- `HTML 파싱과 `
- ┣ `외부 JS 파일의 로드가 비동기적으로`
- ┣ `동시에 진행됨`
- ┣ 단 : `JS 파싱과 실행은`
- ┣ JS 파일의 로드가 `완료된 직후 진행되며`
- ┗ `이때 HTML 파싱이 중단됨`

- 여러 개의 script 태그에 async 어트리뷰트를
- ┣ 지정하면 script 태그의 순서와는 상관없이
- ┣ `로드가 되기 때문에 순서가 보장되지 않음`
- ┣ 따라서 : `순서 보장 async 어트리뷰트 지정 X`
- ┗ async 어트리뷰트 → IE10 부터 지원

### defer 어트리뷰트

- async 어트리뷰트와 마찬가지로
- ┣ HTML 파싱과 외부 JS 파일의 로드가
- ┣ 비동기적으로 실행됨
- ┣ 단 : `JS 파싱과 실행은 HTML 파싱이 완료된 후`
- ┣ 즉 : `DOM 생성이 완료된 직후`
- ┣ `(DOMContentLoaded 이벤트 발생) 진행됨`
- ┣ 따라서 `DOM 생성이 완료된 이후`
- ┣ `실행되어야 할 JS에 유용함`
- ┗ 이 또한 IE10부터 지원
