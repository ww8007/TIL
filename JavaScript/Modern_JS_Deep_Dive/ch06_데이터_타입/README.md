# 데이터 타입

- 데이터 타입(data type)줄여서 → 타입은
- ┣ 값의 종류를 뜻하게 됨
- ┗ JS 모든 값은 데이터 타입을 가짐

- JS(ES6)는 7개의 데이터 타입을 제공
- ┣ 7 개의 데이터 타입은
- ┣ `원시(primitive type)`,
- ┗ `객체(object/reference type)` 으로 분류 가능

| 구분      | 데이터 타입          | 설명                                              |
| --------- | -------------------- | ------------------------------------------------- |
|           | 숫자(number) 타입    | 숫자,정수, 실수 구분 없이 하나의 숫자 타입만 존재 |
|           | 문자열(string) 타입  | 문자열                                            |
| 원시 타입 | 불리언(boolean) 타입 | 논리적 참(true, false)                            |
|           | undefined 타입       | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
|           | null 타입            | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
|           | 심벌(symbol) 타입    | ES6에서 추가된 7번째 타입                         |
| --------- | -------------------- | ------------------------------------------------- |
| 객체 타입 | 객체, 함수, 배열 등  |                                                   |

- 예를 들어 숫자(number) 1, 문자열(string) '1'은 아예 다름
- ┗ 숫자 → 산술, 문자 → 화면 출력의 용도

> 메모리 공간의 크기도 다르고 저장되는 2진수도 다르고 해석하는 방식도 다름

## 목차

- [데이터 타입](#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85)
  - [6.1 숫자 타입](#61-%EC%88%AB%EC%9E%90-%ED%83%80%EC%9E%85)
  - [6.2 문자열 타입](#62-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%83%80%EC%9E%85)
  - [6.3 템플릿 리터럴](#63-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A6%AC%ED%84%B0%EB%9F%B4)
    - [6.3.1 멀티라인 문자열](#631-%EB%A9%80%ED%8B%B0%EB%9D%BC%EC%9D%B8-%EB%AC%B8%EC%9E%90%EC%97%B4)
    - [6.3.2 표현식 삽입](#632-%ED%91%9C%ED%98%84%EC%8B%9D-%EC%82%BD%EC%9E%85)
  - [6.4 불리언 타입](#64-%EB%B6%88%EB%A6%AC%EC%96%B8-%ED%83%80%EC%9E%85)
  - [6.5 undefined 타입](#65-undefined-%ED%83%80%EC%9E%85)
    - [선언(declaration)과 정의(definition)](#%EC%84%A0%EC%96%B8declaration%EA%B3%BC-%EC%A0%95%EC%9D%98definition)
  - [6.6 null 타입](#66-null-%ED%83%80%EC%9E%85)
  - [6.7 심벌 타입](#67-%EC%8B%AC%EB%B2%8C-%ED%83%80%EC%9E%85)
  - [6.8 객체 타입](#68-%EA%B0%9D%EC%B2%B4-%ED%83%80%EC%9E%85)
  - [6.9 데이터 타입의 필요성](#69-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1)
    - [6.9.1](#691)
    - [6.9.2 데이터 타입에 의한 값의 해석](#692-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B0%92%EC%9D%98-%ED%95%B4%EC%84%9D)
  - [6.10 동적 타이핑](#610-%EB%8F%99%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91)
    - [6.10.1 동적 타입 언어와 정적 타입 언어](#6101-%EB%8F%99%EC%A0%81-%ED%83%80%EC%9E%85-%EC%96%B8%EC%96%B4%EC%99%80-%EC%A0%95%EC%A0%81-%ED%83%80%EC%9E%85-%EC%96%B8%EC%96%B4)
    - [6.10.2 동적 타입 언어와 변수](#6102-%EB%8F%99%EC%A0%81-%ED%83%80%EC%9E%85-%EC%96%B8%EC%96%B4%EC%99%80-%EB%B3%80%EC%88%98)%

## 6.1 숫자 타입

- C나 자바의 경우 정수(소수점 이하가 없는 숫자)와 실수(소수점 이하가 있는 숫자)
- ┣ 이를 구분해서 int, long, float, double 같은 다양한 숫자 타입을 제공
- ┗ 그러나 JS에서는 이를 숫자 타입으로 통일

- `ECMAScript` 사양에 따르면 숫자 타입의 값은 배정밀도 64 비트 부동소수점 형식 따름
- ┗ 모든 수를 실수로 처리, 정수만 표현하기 위한 `데이터 타입(integer type)` 존재 X

- JS는 2진수, 8진수, 16진수 표현하기 위한 데이터 타입을 제공 X
- ┗ 그렇기에 모두 10진수로 표현됨

- JS 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리
- ┗ 이는 정수로 표현되더라도 사실 실수라는 의미를 가짐

```js
console.log(1 === 1.0); // true
```

- 숫자 타입은 추가적으로 세 가지 특별한 값도 표현 가능

  1. Infinity : 양의 무한대
  2. -Infinity : 음의 무한대
  3. NaN : 산술 연산 불가(not-a-Number)

- JS의 경우 대소문자를 구별(case-sensitive)하므로
- ┗ NaN 대소문자 구분안하면 → 식별자로 해석하게 된다.

```js
var x = nan; // ReferenceError: nan is not defined
```

## 6.2 문자열 타입

- 문자열(string) 타입은 텍스트 데이터를 나타내는 데 사용
- ┣ 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합
- ┗ 전 세계 대부분의 문자를 표현 가능

- 문자열의 경우 (''), (""), (``) 으로 감싸게 됨
- ┗ JS의 가장 일반적인 표기법은 작은 따옴표를 사용

> 큰 따옴표로 문자열 감싸면 → 작은 따옴표 문자열로 인식
> 반대의 경우도 동일하게 동작

- 만약 따옴표로 문자열을 감싸지 않게 되면
- ┗ 스페이스와 같은 공백 문자도 포함 X

- C는 문자열 타입을 제공하지 않고 문자의 배열로 문자 표현
- JAVA의 경우는 문자열을 객체로 표현함

- JS 경우 문자열은 원시 타입, `변경 불가능한(immutable value) 값`
- ┗ 이것은 문자열이 생성되면 그 문자열을 변경 불가능 하다는 말

## 6.3 템플릿 리터럴

- ES6 부터 템플릿 리터럴(template literal)이라고 하는 새로운 문자열 표기법 도입
- 템플릿 리터럴은
- ┣ 멀티라인 문자열(multi-line string)
- ┣ 표현식 삽입(expression interpolation)
- ┗ 태그드 탬플릿(tagged template)등 편리한 문자열 처리 기능을 제공

> 템플릿 리터럴의 경우 런타임에 일반 문자열로 변환되어 처리

- 템플릿 리터럴은 일반 문자열과 비슷해보이지만 ` 백틱(``) `을 사용하게 됨

### 6.3.1 멀티라인 문자열

- 일반 문자열 내에서는 줄바꿈(개행) 허용X
- ┣ 일반 문자열 내에서 줄바꿈 등의 공백(white space) 표현하기 위해서는
- ┗ `백슬래시(\)`로 시작하는 이스케이스 시퀀스(escape sequence)사용

| 이스케이스 시퀀스 | 의미                                                                     |
| ----------------- | ------------------------------------------------------------------------ |
| \0                | Null                                                                     |
| \b                | 백스페이스                                                               |
| \f                | 폼 피드(Form Feed) 프린터로 출력할 경우 다음 페이지의 시작 시점으로 이동 |
| \n                | 개행 LF Line Feed 다음 행으로 이동                                       |
| \r                | 개행 CR Carriage Return 커서를 처음으로 이동                             |
| \t                | 탭(수평)                                                                 |
| \v                | 탭(수직)                                                                 |
| \uXXX             | 유니코드 ex `\u0041` → A                                                 |
| `\``              | 작은 따옴표                                                              |
| \"                | 큰 따옴표                                                                |
| `\\`              | 백슬래시                                                                 |

> 라인 피드와 캐리지 리턴

    운영체제 별로
    ┣ 윈도우 CR + LF(ASCII 코드 13번과 10번)로 새 줄
    ┣ MAC LF(ASCII 코드 10번)으로 새 줄 표현
    ┗ JS의 경우 \r , \n 의 경우 모두 개행 표현 하지만 \n 라인피드 더 많이 사용

- 일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이스 스퀀스를 사용하지 않고도
- ┗ 줄바꿈이 허용되며 모든 공백도 있는 그대로 적용

### 6.3.2 표현식 삽입

- 문자열은 `문자열 연산자(+)`를 사용해서 연결이 가능
- ┣ + 연산자는 피연산자 중 하나 이상이 문자열인 경우
- ┗ 문자열 연결 연산자로 동작

- 그 외에 경우에는 덧셈 연산자로 동작

- 템플릿 리터럴 내에서는 표현식 삽입(expression interpolation)을 통해 간단히 문자열 삽입 가능
- ┗ 이를 통해 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합 가능

```js
var first = 'Jang';
var last = 'Dong';

console.log(`My name is ${first} ${last}`);
```

> 표현식을 삽입하기 위해서는 `${ }`으로 표현식을 감싸게 됨
>
> > 이 때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 강제 타입 변환!!!

```js
console.log(`1 + 2 = ${1 + 2}`);
```

## 6.4 불리언 타입

- 불리언 타입의 값은 논리적 참, 거짓을 나타내는 true, false 밖에 존재 안함

> 불리언 타입의 경우 참과 거짓으로 구분되는 조건에 의해 프로그램을 제어하는
>
> > 조건문에서 자주 사용

## 6.5 undefined 타입

- `undefined`은 undefined 가 유일

- var 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화
- ┣ 다른 말로 변수 선언에 의해 확보된 메모리 공간을
- ┣ 처음 할당이 이뤄질 때 까지 빈 상태(대부분 비어있지 않고 쓰레기 값)
- ┣ 이 들어 있다면 JS 엔진이 이를 `undefined`로 초기화
- ┗ 변수를 선언하고 값을 할당하지 않은 변수를 참조하면 `undefined` 반환

- 이처럼 `undefined`는 개발자가 의도적으로 할당하기 위한 값이 아닌
- ┣ JS 엔진이 변수를 초기화 할 때 사용하는 값
- ┣ 변수를 참조했을 때 `undefined`가 반환 된다면 참조된 변수가
- ┗ 초기화 되지 않은 변수라는 것을 알 수 있음

- JS이 엔진이 변수를 초기화 하는데 사용하는 `undefined`를
- ┣ 개발자가 의도적으로 `undefined`를 할당하게 된다면
- ┗ 본래 취지에 벗어나고 권장하지 않음

### 선언(declaration)과 정의(definition)

- `undefined`를 직역 시 정의되지 않은임
- ┣ 정의란 래념은 어떤 대상을 명확하게 규정하는 것을 의미
- ┣ JS 경우 `undefined`에서 말하는 정의란 변수에 값을 할당하여
- ┗ 변수의 실체를 명확하게 하는 것을 의미

- C의 경우 선언과 정의는 "실제로 메모리 주소를 할당 하는가"로 구분

- ECMAScript 사양에서 변수는 '선언한다'라고 표현
- ┗ 함수는 '정의한다' 라고 표현

## 6.6 null 타입

- `null` 타입의 값은 `null`이 유일
- ┗ JS는 대소문자 구분 → `Null` 틀림

- 프로그래밍 언어에서 `null`은 변수에 값이 없다는 것을 의도적인 명시
- ┣ 의도적 부재(intensional absence)할 때 사용함
- ┣ 변수에 `null`을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상
- ┗ 참조하지 않겠다는 것을 의미

- 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거
- ┗ `JS 엔진`은 누구도 참조하지 않는 메모리 공간에 대해 `가비지 컬렉션 수행`

```js
var foo = 'Lee';
// 이전 참조를 제거 하지만 유용해 보이지 않음
// 차라리 변수의 스코를 좁게 만들어 빨리 소멸시키는게 더 좋음
```

- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반환하기도 함
- ┣ ex) `HTML` 요소를 검색하는 `document.querySelector` 메서드는 조건에 부합하는
- ┗ `HTML` 요소를 검색할 수 없는 경우 에러 대신 `null`을 반환

## 6.7 심벌 타입

- 심벌 (symbol)은 ES6에 추가된 7번째 타입
- ┣ 변경 불가능한 원시 타입의 값
- ┣ 심벌 값은 다른 값과 중복 되지 않는 유일무이한 값
- ┗ 주로 이름이 충돌할 위험이 없는 `객체의 유일한 프로퍼티 키`를 만들기 위해 사용

- 심벌 이외의 원시 값 → 리터럴을 통해 성성하지만
- ┣ 심벌의 경우 Symbol 함수를 호출해 생성
- ┣ 이 때 생성된 심벌 값은 외부에 노출되지 않으며
- ┗ 다른 값과 절대 중복되지 않는 유일무이한 값

```js
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용
obj[key] = 'value';
console.log(obj[key]); // value;
```

## 6.8 객체 타입

- JS 데이터 타입은 크게 원시 타입, 객체 타입으로 분류
- ┣ 그 이유는 원시 타입과 객체 타입은 근본적으로 다르다는 의미
- ┗ 이에 대해서는 뒤에 설명

- 중요한 것은 JS는 객체 기반의 언어이며
- ┗ `자바스크립트를 이루고 있는 거의 모든 것이 객체`

> 앞에서 다룬 6개의 원시 타입을 제외하면 모두 객체 타입

## 6.9 데이터 타입의 필요성

- 그럼 왜 데이터 타입이 필요할까?

### 6.9.1

- 값은 메모리에 저장하고 참조할 수 있어야 함
- ┣ 메모리에 값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정
- ┣ 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지
- ┗ 알아야 함

```js
var score = 100;
```

- 위 코드가 실행되면 컴퓨터는 숫자 값 100을 저장하기 위해
- ┣ 메모리 공간을 확보한 다음
- ┣ 확보된 메모리에 숫자 값 100을 2진수로 저장
- ┣ 이러한 처리를 하기 위해 숫자 값을 저정할 때
- ┗ `확보해야 할 메모리 공간의 크기를 알아야함`
- JS 엔진은 데이터 타입
- ┣ 즉 값의 종류에 따라 정해진 크기의
- ┣ 메모리 공간을 확보함
- ┣ 변수에 할당되는 값의 `데이터 타입에 따라`
- ┗ 확보해야 할 `메모리 공간의 크기가 결정`

- 위 예제의 경우 JS 엔진은
- ┣ 리터럴 100을 숫자 타입의 값으로 해석
- ┣ 100을 저장하기 위해서 8바이트 메모리 공간 확보
- ┗ 그러고 100을 2진수로 저장

- JS는 숫자 타입의 값을 생성할 때
- ┣ `배정밀도 64비트 부동 소수점 형식`을 사용
- ┗ 따라서 실제로 저장되는 2진수의 값은 다름

> 지금 단계에선 간단하게 양의 정수로 생각

- 데이터 타입에 따라 확보되는 메모리 공간의 크기

- ECMAScript 사양은 문자열과 숫자 타입 외에
- ┣ 데이터 타입의 크기를 명시적으로 규정 X
- ┣ 문자열과 숫자 타입을 제외하고 데이터 타입에 따라
- ┗ 확보되는 메모리 공간의 크기는 엔진 제조사에 구현에 따라 다를 수 있음

- 단 ECMAScript 사양에 숫자 타입은 배정밀도 64비트 부동소수점 형식을 사용
- ┗ 이는 8바이트로 숫자를 표현 → 이 책에서는 숫자 값의 크기를 8바이트로 설명

- 이제 값을 참조하는 경우 생각
- ┣ 셕별자 score를 통해 숫자 타입의 값 100이 저장되어 있는
- ┣ 메모리 공간의 주소를 찾아갈 수 있음
- ┣ 정확하게 말하자면 숫자 값 100 이 저장되어 잇는
- ┗ `메모리 공간의 선두 메모리 셀의 주소를 찾아갈 수 있음`

- 이때 값을 참조하기 위해서는 한 번 읽어 들여야 할 메모리 공간의 크기
- ┣ 즉 메모리 셀의 개수(바이트 수)를 알아야 함
- ┣ score 변수의 경우 저장되어 있는 값이 숫자 타입이므로
- ┣ 8 바이트 단위로 읽어 들이지 않으면 값이 훼손
- ┗ 그렇다면 컴퓨터가 이것을 어떻게 알까?

- score 변수에는 숫자 타입의 값이 할당되어 있으므로
- ┣ JS 엔진은 score 변수를 숫자 타입으로 인식
- ┣ 숫자 타입은 8바이트 단위로 저장
- ┣ score 변수를 참조하면 8 바이트 다뉘로 메모리 공간에 저장된 값을
- ┗ 읽어들이게 됨

> 심벌 테이블

    컴파일러 또는 인터프리터는 심벌 테이블 이라고 불리는 자료 구조를 통해
    식별자로 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프를 관리

### 6.9.2 데이터 타입에 의한 값의 해석

- 아직 문제가 남아 있음 → 메모리에서 읽어들인 2진수의 해석

- 모든 값은 데이터 타입을 가지며
- ┣ 메모리에 2진수 → 즉 비트의 나열로 저장됨
- ┣ 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석 가능
- ┗ ex 0100 0001 숫자 → 65, 문자열 → 'A'

- 앞에서 살펴본 예제의 score 변수에 할당된 값은 숫자 타입의 값
- ┣ score 변수를 참조하면 메모리 공간의 주소에서 읽어 들인 2진수 → 숫자로 해석

- 데이터 타입의 필요 이유
  1. 값을 저장할 때 확보해야 할 메모리 공간의 크기를 결정하기 위해
  2. 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
  3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

- JS의 모든 값은 데이터 타입을 가짐
- ┗ 그러면 왜 변수는 데이터 타입을 가질까

- C나 JAVA같은 정적(static, strong type)언어는 변수를 선얼 할 때
- ┣ 변수에 할당할 수 있는 값의 종류
- ┣ 데이터의 타입을 사전에 선언해야 함
- ┗ 이를 명시적 타입 선언(explicit type declaration)이라 함

- 정적 타입 언어는 변수의 타입을 변경 불가
- ┣ 변수에 선언한 타입에 맞는 값만 할당이 가능
- ┣ 정적 타입 언어는 컴파일 시점에 `타입체크`를 수행
- ┗ 만약 타입체크를 통과하지 못하면 에러 발생, 중지
- JS의 경우 정적 타입 언어와 다르게 변수를 선언할 때
- ┣ 타입을 선언하지 않음
- ┣ 다만 `var`, `let`, `const` 키워드를 사용해 변수를 선언
- ┣ JS 변수는 정적 타입 언어와 같이 미리 선언한 데이터 타입의 값만
- ┗ 설정할 수 있는 것이 아닌 → 모든 데이터 타입의 값을 자유롭게 할당가능

> TypeScript가 이를 막기 위해서 등장

- `typeof` 연산자로 변수를 연산하면 변수의 데이터 타입을 반환
- ┣ 정확하게는 변수의 데이터 타입을 반환하는 것이 아닌
- ┗ 변수에 할당된 값의 데이터 타입을 반환하는 것!!!

- JS 변수에는 어떤 데이터 타입의 값이라도
- ┣ 자유롭게 할당할 수 있기 때문에
- ┣ 정적 타입에서 말하는 데이터 타입과 개념이 다름
- ┣ 정적 타입 : 변수 선언 시점에 변수 타입이 결정
- ┣ JS : 값을 할당하는 시점에 변수의 타입이 동적으로 결정가능하며
- ┗ 이를 자유롭게 변경 가능

> JS 변수는 할당에 의해 타입이 결정(타입 추론(type inference))됨

    재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 잇음
    ┣ 이를 동적 타이핑(dynamic typing)이라고 함
    ┗ JS 경우 이를 정적 타입과 구별하기위해서 동적 타입(dynamic/weak type)이라고 부름

### 6.10.2 동적 타입 언어와 변수

- 동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당가능
- ┗ 편리하지만 위험도 있음

- 모든 소프트웨어 아키텍쳐에는 트레이드오프(trad-off) 존재
- ┣ 두 개의 정책이나 하나를 위해 하나를 포기해야하는 것
- ┗ 모든 조건을 만족할 수는 없다는 것

> 유연성(flexibility)은 높지만 신뢰성(reliability)는 떨어짐

1. 변수는 `꼭 필요한 경우`에 한해 제한적으로 사용
2. 변수의 `유효 범위(스코프)`는 `최대한 좁게` 만들어서 변수의 부작용 억제
3. `전역 변수는 최대한 사용 자제` → 프로그래밍 복잡성 증가 처리 흐름 추적 어려움
4. 변수보다는 `상수`를 사용해 값의 변경 언제
5. 변수의 이름은 목적이나 의미에 맞게 `네이밍`
