# 12 함수

## 목차

- [12 함수](#12-%ED%95%A8%EC%88%98)
  - [12.1 함수란?](#121-%ED%95%A8%EC%88%98%EB%9E%80)
  - [12.2 함수를 사용하는 이유](#122-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)
  - [12.3 함수 리터럴](#123-%ED%95%A8%EC%88%98-%EB%A6%AC%ED%84%B0%EB%9F%B4)
  - [12.4 함수 정의](#124-%ED%95%A8%EC%88%98-%EC%A0%95%EC%9D%98)
    - [12.4.1 함수 선언문](#1241-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EB%AC%B8)
    - [12.4.2 함수 표현식](#1242-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D)
    - [12.4.3 함수 생성 시점과 함수 호이스팅](#1243-%ED%95%A8%EC%88%98-%EC%83%9D%EC%84%B1-%EC%8B%9C%EC%A0%90%EA%B3%BC-%ED%95%A8%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85)
    - [12.4.4 Function 생성자 함수](#1244-function-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98)
    - [12.4.5 화살표 함수](#1245-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98)
  - [12.5 함수 호출](#125-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C)
    - [12.5.1 매개변수와 인수](#1251-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%99%80-%EC%9D%B8%EC%88%98)
    - [12.5.2 인수 확인](#1252-%EC%9D%B8%EC%88%98-%ED%99%95%EC%9D%B8)
    - [12.5.3 매개변수의 최대 개수](#1253-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%9D%98-%EC%B5%9C%EB%8C%80-%EA%B0%9C%EC%88%98)
    - [12.5.4 반환문](#1254-%EB%B0%98%ED%99%98%EB%AC%B8)
  - [12.6 참조에 의한 전달과 외부 상태의 변경](#126-%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%AC%EA%B3%BC-%EC%99%B8%EB%B6%80-%EC%83%81%ED%83%9C%EC%9D%98-%EB%B3%80%EA%B2%BD)
  - [12.7 다양한 함수의 형태](#127-%EB%8B%A4%EC%96%91%ED%95%9C-%ED%95%A8%EC%88%98%EC%9D%98-%ED%98%95%ED%83%9C)
    - [12.7.1 즉시 실행 함수](#1271-%EC%A6%89%EC%8B%9C-%EC%8B%A4%ED%96%89-%ED%95%A8%EC%88%98)
    - [12.7.2 재귀 함수](#1272-%EC%9E%AC%EA%B7%80-%ED%95%A8%EC%88%98)
    - [12.7.3 중첩 함수](#1273-%EC%A4%91%EC%B2%A9-%ED%95%A8%EC%88%98)
    - [12.7.4 콜백 함수](#1274-%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98)
    - [12.7.5 순수 함수와 비순수 함수](#1275-%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EC%99%80-%EB%B9%84%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98)

## 12.1 함수란?

- 함수는 JS에서 가장 중요한 핵심 개념
- ┣ 또 다른 JS 핵심 개념인 스코프, 실행 컨텍스트, 클로저
- ┣ 생성자 함수에 의한 객체생성, 메서드, this.프로토타입, 모듈화
- ┗ 이들 모두가 함수와 관련이 있음

- JS를 정확히 이해하고 사용하기 위해 피해갈 수 없음

```js
function add(x, y) {
	return x + y;
}
```

- 프로그래밍 언어의 함수 : 일련의 과정을 `문(statement)`로 구현하고
- ┣ 코드 블록으로 감싸서 `하나의 실행 단위로 정의`
- ┣ 프로그래밍 언어의 함수도 입력을 받아서 출력을 내보냄
- ┣ 이 때 1. 함수 내부로 입력을 전달받는 변수 : `매개변수(parameter)`
- ┣ 2. 입력 : `인수(argument)`, 3. 출력 : `반환값(return value)`라고 함
- ┗ 함수 : 값 이며, 여러 개 존재 가능 → 식별자인 함수 이름 사용 가능

- 함수 : `함수 정의(function definition)` 통해 생성
- ┣ JS 함수는 다양한 방법으로 정의 가능
- ┗ 함수 선언문을 통해 함수 정의한 예

```js
function add(x, y) {
	return x + y;
}
```

- 함수 정의만으로 함수가 실행되는 것은 아님
- ┣ 수학의 함수처럼 미리 정의된 일련의 과정을 실행하기 위해서
- ┣ 필요한 입력 → 인수(argument)를 매개변수를 통해 함수에 전달
- ┣ 함수의 실행을 명시적으로 지시해야 함
- ┗ 이를 `함수 호출(function call/invoke)`라고 함

> 함수를 호출하면 코드 불록에 담긴 문들이 일괄적으로 실행되고 반환값을 반환

## 12.2 함수를 사용하는 이유

- 함수는 필요할 때 여러 번 호출이 가능하다.
- ┣ 즉 실행 시점을 개발자가 결정할 수 있고
- ┣ `몇 번이든 재사용`이 가능하다.
- ┣ 동일한 작업을 반복적으로 수행해야 한다면
- ┣ 같은 코드를 중복해서 여러 번 작성하는 것이 아닌
- ┣ `정의된 함수를 재사용`하는 것이 효율적임
- ┣ 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용 측면에서
- ┗ 매우 유리하다!

> 코드의 유지보수의 편의성을 높이고 코드의 신뢰성을 높임

- 함수 : 객체 타입의 값
- ┣ 함수 이름 : 변수 이름과 마찬가지로 자신을 잘 설명
- ┣ 적절한 함수 이름 → 가독성을 좋게 해줌
- ┗ 코드는 동작만이 목적이 아닌 개발자를 위한 문서이기도 함

## 12.3 함수 리터럴

- JS 함수 : `객체 타입`의 값
- ┣ 따라서 `숫자 값` → `숫자 리터럴`로 생성
- ┣ `객체` → `객체 리터럴`로 생성하는 것 처럼
- ┣ `함수` → `함수 리터럴`로 생성 가능
- ┗ `함수 리터럴` : `function` 키워드, `함수 이름`, `매개변수 목록`, `함수 몸체` 구성

> 함수 리터럴의 구성 요소

| 구성요소      | 설명                                                                                                                                                                                                                                                                      |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 함수 이름     | 함수 이름은 식별자 → 식별자 네이밍 준수 <br/> 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 <br/> 함수 이름 생략 가능. 이름 존재 : 기명 함수(named function) 없는 함수 : 무명/익명 함수(anonymous function)                                                        |
| 매개변수 목록 | 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분 <br/> 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당 → 순서에 <br/> 의미가 있음 <br/> 매개변수는 함수 몸체 내에서만 변수와 동일하게 취급됨 → 매개변수도 변수와 마찬가지로 <br/> 식별자 네이밍 규칙을 준수 |
| 함수 몸체     | 함수가 호출되었을 때 일괄적으로 실행된 문들을 하나의 실행 단위로 정의한 코드 블럭 <br/> 함수 몸체는 함수 호출에 의해 실행                                                                                                                                                 |

```js
var f = function add(x, y) {
	return x + y;
};
```

- 위 예제에서 `함수 리터럴` → `변수에 할당` 중
- ┣ 5장 리터럴에서 살펴보았듯
- ┣ `리터럴` : `사람이 이해할 수 있는 문자, 기호를 사용해 값을 생성`
- ┗ 리터럴 : `값을 생성하기 위한 표기법`

- `함수 리터럴` 또한 평가되어 `값을 생성`
- ┗ 이 값은 : 객체 → `함수` : `객체`

- `함수`는 `객체`지만 일반 객체와는 다름
- ┣ 일반 객체는 `호출 불가`, but `함수는 호출 가능`
- ┗ 일반 객체에는 없는 `함수 객체만의 고유한 프로퍼티`를 가짐

- 함수가 객체라는 사실은 다른 프로그래밍 언어와 구분되는
- ┣ JS만의 중요한 특징 중 하나
- ┗ 여기서 잘 정리하고 가야함

## 12.4 함수 정의

- 함수 정의란 함수를 호출하기 이전에 인수를 전달받을 1. 매개변수와
- ┣ 2. 실행할 문들, 3. 반환한 값을 지정하는 것을 의미
- ┣ 정의된 함수는 JS 엔진에 평가되어 → 함수 객체가 됨
- ┗ 함수를 정의하는 방법에는 4가지가 존재

1. 함수 선언문

   ```js
   function add(x, y) {
   	return x + y;
   }
   ```

2. 함수 표현식

   ```js
   var add = function (x, y) {
   	return x + y;
   };
   ```

3. Function 생성자 함수

   ```js
   var add = new Function('x', 'y', 'return x+y');
   ```

4. 화살표 함수(ES6)

   ```js
   var add = (x, y) => x + y;
   ```

> 모든 함수 정의 방식은 함수를 정의한다는 면에서는 동일하지만 미묘한 차이 존재

> 변수 선언과 함수정의

    변수 : 선언(declaration)
    함수 : 정의(definition)
    함수 선언문이 평가 → 식별자 암묵적으로 생성되고
    함수 객체가 할당
    ECMAScript 자체에서도 이를 분리함

### 12.4.1 함수 선언문

- 함수 선언문을 사용해 정의하는 방식은 다음과 같음

```js
// 함수 선언문
function add(x, y) {
	return x + y;
}

// 함수 참조
// console.dir 은 함수 객체의 프로퍼티까지 출력
// Node.js 환경에서는 console.log와 똑같이 동작
console.dir(add);

// 호출
console.log(add(2, 5)); // 7
```

- `함수 선언문은 함수 리터럴과 형태가 동일`
- ┣ 단, 함수 리터럴은 함수 이름을 생략할 수 있지만
- ┗ 함수 선언문 : 함수 `이름 생략 불가`

```js
// 함수 선언문에서 함수 이름 생략 불가
function (x,y) {
    return x + y;
}
```

- 함수 선언문은 표현식이 아닌 문
- ┣ 구글 개발자 도구에서 함수 선언문을 실행하면
- ┣ 완료 값 : undefined가 출력됨
- ┣ 함수 선언문이 만약 표현식인 문 이라면
- ┗ 완료 값 : 표현식이 평가되어 생성된 함수가 출력 되어야 함

- 앞 5장에서 표현식인 문, 표현식이 아닌 문에서 보았듯이
- ┣ 표현식이 아닌 문 : 변수에 할당 불가
- ┣ `함수 선언문` : `표현식이 아닌 문`
- ┣ 그렇기에 변수에 할당 불가
- ┗ 하지만 다음을 보면 변수에 할당되는 것 처럼 보임

```js
var add = function add(x, y) {
	return x + y;
};
```

- 이렇게 동작하는 이유는 JS 엔진이 코드의 문맥에 따라
- ┣ 동일한 함수 리터럴을 `표현식이 아닌`
- ┣ 1. 함수 선언문으로 해석하는 경우
- ┣ 2. 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우 존재
- ┣ `함수 선언문` → 함수 이름을 생략할 수 없다는 점만 제외하면
- ┣ `함수 리터럴과 형태가 동일`
- ┣ 이는 함수 이름이 있는 `기명 함수 리터럴`은
- ┗ `함수 선언문`, `함수 리터럴 표현식`으로 해석될 가능성 존재

- 예를 들어 `{ }`은 블록문, 객체 리터럴이라고 생각 가능
- ┣ `JS 엔진`은 이를 어떻게 해석할까?
- ┣ `{ }`처럼 중의적인 코드는 코드의 문맥에 따라 해석이 달라짐
- ┣ `{ }`단독으로 존재하면 `JS 엔진` → `블록문`으로 해석
- ┣ 하지만 `{ }`이 값으로 평가되어야 할 문맥(할당 연산자의 우변)
- ┣ 에서 피연산자로 사용되면 `JS 엔진` → `객체 리터럴`
- ┗ 동일한 코드도 문맥에 따라 해석이 달라질 수 있음

- 기명 함수 리터럴도 중의적인 코드
- ┣ 코드의 문맥에 따라 해석이 달라질 수 있음
- ┣ JS 엔진은 함수 이름이 있는 함수 리터럴을
- ┣ 단독으로 사용 → (값으로 평가되 어야 할 부분에서 리터럴 사용 X)
- ┗ 의 경우에 대해서는 `함수 선언문으로 해석`
- ┣ 리터럴이 값으로 평가되어야 하는 문맥
- ┣ ex) 함수 리터럴을 `1. 변수에 할당`하거나 `2. 피연산자로 사용`
- ┗ `함수 리터럴 표현식으로 해석`

- 함수 선언문이든 함수 리터럴 표현식이든 함수가 생성되는 과정 동일

> 하지만 함수를 생성하는 내부 동작이 차이가 있음

```js
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석
// 함수 선언문에서는 함수 이름 생략 불가
function foo() {
	console.log('foo');
}
// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아닌 리터럴 표현식으로 해석
// 함수 리터럴에서는 함수 이름을 생략 가능함
(function bar() {
	console.log('bar');
});
bar(); // Reference Error
```

- 위 예제에서 단독으로 사용된 `함수 리터럴(foo)` → `함수 선언문`으로 해석
- ┣ 하지만 `그룹 연산자 ()` 내에 있는 `함수 리터럴(bar)`은 함수 선언문이 아닌
- ┣ `함수 리터럴 표현식으로 해석`
- ┣ 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식 이어야 함
- ┗ 표현식이 아닌 함수 선언문 → 피연산자로 사용불가

- 기명 함수 리터럴은 코드의 문맥에 따라 함수 선언문 또는
- ┣ 함수 리터럴 표현식으로 해석됨
- ┣ 함수 선언문, 함수 리터럴 표현식 궁극적 : `함수 객체 생성`
- ┗ 결정적으로 `호출에 차이가 존재`

- 앞에서 12.3 `함수 리터럴` → `함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자`
- ┣ 이는 `함수 몸체 외부`에서는 `함수 이름으로 함수를 참조 불가`
- ┣ 함수 외부에서는 함수 이름으로 함수를 호출 불가
- ┣ 즉 → 함수를 가르키는 식별자가 없다는 의미
- ┗ 위 예제에서 bar 함수는 `호출 불가`

- foo의 경우는 호출이 가능
- ┣ foo는 함수 몸체 내부에서만 유효한 식별자인 함수 이름
- ┣ foo 함수는 호출 할 수 없어야 정상임
- ┣ foo 호출 → foo는 함수 이름이 아닌 함수 객체를 가르키는 식별자
- ┣ 하지만 foo를 선언한 적도 없고 할당한 적도 없음
- ┗ 그럼 foo는 무엇일까?

> foo는 JS 엔진이 암묵적으로 생성한 식별자

- JS 엔진은 `함수 선언문을 해석`해 `함수 객체를 생성`
- ┣ `함수 이름`은 `몸체 내부`에서 `유효한 식별자`이므로
- ┣ `함수 이름`과 별도로 생성된 `함수 객체`를 가르키는 `식별자`가 필요
- ┣ 함수 객체를 가리키는 식별자가 없으면
- ┣ 생성된 함수 객체를 참조 X → 호출도 X
- ┣ 그렇기에 JS 엔진은 생성된 함수를 호출하기 위해
- ┗ `함수 이름과 동일한 이름의 식별자를 암묵적으로 생성` → `함수 객체를 할당`

```js
var add = function add(x, y) {
	return x + y;
};
console.log(add(2, 5));
```

- 함수 : 함수 이름으로 호출하는 것이 아닌
- ┣ 함수 객체를 가리키는 식별자로 호출
- ┣ 함수 선언문으로 생성한 함수를 호출한 것은
- ┣ 함수 이름 add가 아닌 → JS 엔진이 암묵적으로 생성한 식별자 add
- ┣ 함수 이름과 변수 이름이 일치 → 함수 이름으로 호출된거 같음
- ┗ 사실은 식별자로 호출 된 것임

> 함수 이름, 식별자는 별개 이며 식별자를 이용해 함수 객체를 호출

> 결론적으로 JS 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체 생성
> 함수 선언문과 함수 표현식이 정확하게 동일하게 동작하는 것은 아님

### 12.4.2 함수 표현식

- JS 함수는 객체 타입의 값
- ┣ JS 함수 : `1. 값 처럼 변수에 할당 가능`
- ┣ `2. 프로퍼티 값이 될 수 있음`
- ┣ `3. 배열의 요소가 될 수 있음`
- ┣ 이처럼 `값의 성질`을 갖는다 → `일급 객체`
- ┣ JS 함수 : 일급 객체
- ┗ 이 의미는 함수를 값처럼 자유롭게 사용가능하다는 의미

- 함수 : 일급 객체이므로 함수 리터럴로 생성한 함수 객체를
- ┣ `변수에 할당`이 `가능`하다.
- ┣ 이러한 함수 정의 방식 → `함수 표현식(function expression)`
- ┣ 함수 선언문으로 정의한 add 함수를 표현식으로 바꿔서 정의
- ┗ 다음과 같음

```js
var add = function (x, y) {
	return x + y;
};

console.log(add(2, 5));
```

- 함수 리터럴의 함수 이름은 생략 가능!
- ┣ 이러한 함수 : 익명 함수 라고 부름
- ┣ 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이
- ┗ 일반적 이라고 볼 수 있음

- `함수 선언문`에서 살펴본 바와 같이 함수를 호출
- ┣ 함수 이름이 아닌 → `함수 객체를 가리키는 식별자`를 사용
- ┣ `함수 이름` : `함수 몸체 내부`에서만 `유효한 식별자`
- ┗ 함수 이름으로 함수를 호출 불가

```js
var add = function foo(x, y) {
	return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5));

// 함수 이름으로 호출하면서 ReferenceError 발생
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자
console.log(foo(2, 5));
```

- JS 엔진은 `함수 선언문의 함수 이름`으로
- ┣ `식별자를 암묵적으로 생성`
- ┣ 생성된 `함수 객체를 할당` 하므로
- ┣ `함수 표현식과 유사하게 동작`하는 `것 처럼 보임`
- ┗ 하지만 `함수 선언문`과 `함수 표현식`이 `정확히 동일하게 동작은 X`

> 함수 선언문 : 표현식이 아닌 문
> 함수 표현식 : 표현식인 문
> 미묘하지만 중요한 차이점이 존재

### 12.4.3 함수 생성 시점과 함수 호이스팅

```js
//함수 참조
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

//함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
	return x + y;
}

// 함수 표현식
var sub = function (x, y) {
	return x - y;
};
```

- 위 예제와 같이 험수 선언문으로 정의한 함수 :
- ┣ 함수 선언문 이전에 호출이 가능
- ┣ But : 함수 표현식으로 정의한 함수 :
- ┣ 함수 표현식 이전에 호출 불가
- ┣ `함수 선언문 정의`, `함수 표현식으로 정의`한 함수
- ┗ `함수의 생성 시점이 다르기 때문`!!!

- 모든 선언문이 그렇듯 함수 선언문도 코드가 한 줄씩 실행되는
- ┣ 런타임(runtime) 이전에 JS 엔진에 의해서 먼저 실행
- ┣ 함수 선언문으로 함수를 정의 → 런타임 이전에 함수 객체가 먼저 생성
- ┣ JS 엔진은 `1. 함수 이름과 동일한 이름의 식별자 암묵적 생성`
- ┗ `2. 생성된 함수 객체를 할당`

- 코드가 한 줄씩 순차적으로 실행되기 시작하는 → 런타임에는
- ┣ 이미 함수 객체가 생성되어 있고, 함수 이름과 동일한 식별자
- ┣ 할당까지 완료가 된 상태
- ┣ 함수 선언문 이전에 함수를 참조 가능
- ┣ 호출도 가능하다!
- ┣ 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼
- ┗ 동작하는 JS 고유한 특징을 `함수 호이스팅(function hoisting)`

- `함수 호이스팅`과 `변수 호이스팅`은 미묘한 차이가 있음
- ┣ var 키워드를 사용한 변수 선언문과 함수 선언문
- ┗ `JS 엔진`에 의해 먼저 실행되어 `식별자 생성` → 동일
- ┣ But `변수` : `식별자`가 `undefined로` 초기화
- ┣ `함수` : `식별자`가 `함수 객체`로 초기화 됨
- ┣ 따라서 var 키워드를 사용한 변수 선언문 이전에
- ┣ 변수를 참조하면 변수 호이스팅 → undefined
- ┗ 함수 선언문 : 객체로 되어있기 때문에 `함수 호이스팅` 가능

- `함수 표현식` : `변수`에 `할당되는 값`이 `함수 리터럴`인 `문`
- ┣ `함수 표현식`은 `변수 선언문`, `변수 할당문`을 한 번에
- ┣ 기술한 축약 표현과 동일하게 동작
- ┣ `변수 선언` : `런타임 이전`에 실행 → `undefined` 초기화 되지만
- ┣ `변수 할당문의 값` : `할당문이 실행`되는 시점, `런타임`에 평가
- ┣ `함수 표현식의 함수` 리터럴도 할당문이 실행되는 시점에 평가 되어
- ┗ 함수 객체가 됨

> 함수 표현식 으로 함수 정의 → 함수 호이스팅이 아닌 변수 호이스팅 발생

- 함수 표현식 이전에 함수를 참조하면 undefined로 평가
- ┣ 이때 함수를 호출하면 undefined를 호출하는 것과 마찬기지이므로
- ┣ 타입 에러(TypeError)가 발생하게 됨
- ┣ 따라서 함수 표현식으로 정의한 함수는
- ┗ 함수 표현식 이후에 참조 또는 호출을해야 함

- `함수 호이스팅`의 경우 함수를 호출하기 전에 반드시 함수를 선언해야 한다는
- ┣ 당연한 규칙을 무시해 버림
- ┣ 이 같은 문제를 해결하기 위해서
- ┗ `함수 선언문 대신` → `함수 표현식을 사용할 것`을 권장

### 12.4.4 Function 생성자 함수

- JS가 기본적으로 제공하는 `빌트인 함수`인
- ┣ `Function 생성자 함수`에 `매개변수 목록과 함수 몸체`를
- ┣ `문자열로 전달` 하면서, `new 연산자와 함께 호출`하면
- ┣ 함수 객체를 생성해서 → 반환하게 됨
- ┗ 사실 new 연산자 없이 호출해도 결과는 동일

> 생성자 함수(constructor function)

생성자 함수는 객체를 생성하는 함수를 뜻함
객체를 생성하는 방식은 객체 리터럴 이외에 다양한 방법 존재

- Function 생성자 함수로 지금까지 살펴본 add 함수 생성

```js
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```

- Function 생성자 함수로 함수를 생성하는 방식은
- ┣ 일반적이지도 않고 바람직 하지도 않음
- ┣ Function 생성자 함수로 생성한 함수는
- ┣ `클로저(closure)`를 생성하지 않으며
- ┗ `함수 선언문`이나 `함수 표현식`으로 `생성한 함수와 다르게 동작`

### 12.4.5 화살표 함수

- `ES6`에서 도입된 `화살표 함수(arrow function)`는 function 키워드 대신
- ┣ `화살표(lat arrow)`를 사용해 좀 더 간략한 방법으로 함수를 선언 가능
- ┗ 화살표 함수는 `익명 함수`로 정의

```js
// 화살표 함수
const add = (x, y) => x + y;
console.log(add(2, 5));
```

- `화살표 함수`는 기존의 선언문 또는 함수 표현식을
- ┣ 완전하게 대체하기 위해 디자인 된 것은 아님
- ┣ `화살표 함수`는 표현만 간략한 것이 아닌
- ┗ `내부 동작 또한 간략화`가 되어 있음

- 화살표 함수는 `생성자 함수로 사용 불가`
- ┣ 기존 함수와 `this 바인딩 방식이 다르고`
- ┣ `prototype 프로퍼티가 존재 X`
- ┣ `arguments 객체를 생성 X`
- ┗ 화살표 함수에 대해서는 추후에 다시 설명

## 12.5 함수 호출

- 함수 : `함수를 가리키는 식별자와 한 쌍의 소괄호`인
- ┣ `함수 호출 연산자`로 호출
- ┣ 함수 호출 연산자 내에는 0개 이상의 인수를
- ┣ 쉼표로 구분해서 나열
- ┣ 함수를 호출하면 현재의 실행 흐름을 중단하고
- ┗ 실행 흐름을 옮기게 된다.

> 매개변수 인수는 순서대로 할당되며 몸체의 문들이 실행

### 12.5.1 매개변수와 인수

- 함수를 실행하기 위해 필요한 값을 함수 외부 → 내부로 전달할 필요한 경우
- ┣ `매개변수(parameter)`를 통해 `인수(argument)`를 전달하게 됨
- ┣ 인수 : 값으로 평가 될 수 있는 표현식 이어야 함
- ┗ 인수는 함수를 호출 할 때 지정하며, 개수와 타입에 제한이 없음

```js
// 함수 선언문
function add(x, y) {
	return x + y;
}

// 함수 호출
// 인수 1과 2가 매개변수 x와 y에 순서대로 할당되고
// 함수 몸체의 문들이 실행
var result = add(1, 2);
```

- `매개변수` : 함수를 정의할 때 선언
- ┣ 함수 몸체 내부에서 변수와 동일하게 취급
- ┣ 함수가 호출되면 함수 몸체 내에서
- ┣ 암묵적으로 `매개변수가 생성`되고
- ┣ 일반 변수와 마찬가지로 `undefined`로 `초기화`가 됨
- ┣ 이후 인수가 순서대로 할당되게 됨
- ┗ 함수가 호출될 때 마다 매개변수는 이와 같은 단계 거침

- 매개변수 : 함수 몸체 내부에서만 참조가 가능하고
- ┣ 함수 몸체 외부에서는 참조가 불가능 하다.
- ┗ 즉 매개변수 스코프 → 함수 내부

```js
function add(x, y) {
	console.log(x, y);
	return x + y;
}

add(2, 5);

// add 함수의 매개변수는 x, y는 함수 몸체 내부에서만 사용 가능
console.log(x, y);
```

- 함수 : 매개변수의 개수와 인수의 개수가 일치하는 지는 체크 X
- ┣ 함수를 호출할 때 매개변수의 개수 만큼
- ┣ 인수를 전달하는 것이 일반적 이긴 하지만
- ┗ 인수가 부족하다 하더라도 에러는 발생되지 않는다.

> 인수가 부족해서 인수가 할당되지 않은 매개변수는 undefined

```js
function add(x, y) {
	return x + y;
}
console.log(add(2)); // NaN
```

- 위 예제의 경우 매개변수 x에는 전달 되지만
- ┣ y의 경우 전달할 인수가 없으므로 undefined
- ┗ 고로 NaN이 반환

> 매개변수 보다 인수가 많은 경우 인수는 무시

사실 초과된 인수는 그냥 버려지는 것이 아닌
암묵적으로 `arguments` 객체의 프로퍼티로 보관
arguments : 인수

- arguments 객체는 함수를 정의할 때 매개변수 개수를
- ┣ 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게
- ┗ 사용됨

### 12.5.2 인수 확인

```js
function add(x, y) {
	return x + y;
}
```

- 위 함수를 정의한 개발자 의도는 아마도
- ┣ 2개의 숫자 타입 인수를 전달 받아서
- ┣ 그 합계를 반환하려는 의도로 추측
- ┣ 하지만 코드 상으로는 어떤 타입의 인수 전달과
- ┗ 반환값에 대한 명시가 존재하지 않음
- 상황 발생의 이유

1. JS 함수는 매개변수와 인수의 개수가 일치하는지 확인 X

2. JS는 동적 타입 언어임 → JS 함수는 매개변수 타입을 사전에 지정 X

- JS의 경우 함수를 정의할 때 인수가 전달 되었는지 확인 필요 존재

- `arguments` 객체를 통해서 인수 개수 확인 할 수 있으며
- ┗ 인수가 전달되지 않은 경우 `단축 평가`를 통해서 `매개변수 할당 방법`

```js
function add(a, b, c) {
	a = a || 0;
	b = b || 0;
	c = c || 0;
	return a + b + c;
}
console.log(add(1, 2, 3)); // 6
console.log(add()); // 0
```

> ES6에서 도입된 매개변수 기본값 사용시 함수 내에서 수행하던
> 인수 체크 및 초기화를 간소화 할 수 있음

- 매개변수 기본값은 매개변수에 인수를 전달하지 않았을 경우와
- ┗ undefined를 전달한 경우에만 유효

```js
function add(a = 0, b = 0, c = 0) {
	return a + b + c;
}
```

### 12.5.3 매개변수의 최대 개수

- `ECMAScript` 사양에서는 매개변수의 최대 개수에 대해
- ┣ 명시적으로 제한하고 있지 않음
- ┣ JS 엔진마다 제한이 있을 수 있지만 별다른 지시 없음
- ┗ 매개변수의 경우 몇 개까지 사용하는 것이 좋을까?

- `매개변수`는 순서에 의미가 있음
- ┣ 매개변수가 많아지면 함수를 호출할 때 전달해야 할
- ┣ `인수의 순서를 고려`해야 함
- ┣ 함수의 사용법을 이해하기 어렵게 만들고
- ┣ 실수를 발생시킬 가능을 높임
- ┗ `유지 보수성이 나빠짐`

> 함수는 한 가지 일만 해야 하며 가급적 작게

- 매개변수는 최대 3개 이상을 넘지 않는 것은 권장
- ┣ 그 이상의 매개변수가 필요하다며 하나 매개변수 선언하고
- ┣ 객체를 인수로 인수로 전달하는 것이 유리
- ┗ jQuery의 ajax 메서드에 객체를 인수로 전달하는 예

```js
$.ajax({
	method: 'POST',
	url: '/user',
	data: { id: 1, name: 'Lee' },
	cache: false,
});
```

- 객체를 인수로 사용하는 경우 프로퍼티 키만 지정하면
- ┣ 매개변수의 순서를 신경 쓰지 않아도 괜찮음
- ┣ 명시적으로 인수의 의미를 설명하는 프로퍼티 키를
- ┣ 사용하게 할 수 있음
- ┗ 코드가 가독성도 좋아지고 실수도 줄어들음

- 주의할 점은 함수 외부에서 함수 내부로 전달한 객체를
- ┣ 함수 내부에서 변경하면 함수 외부의 객체가 변경되는
- ┗ `부수효과(side effect)`가 발생한다는 점

### 12.5.4 반환문

- 함수는 return 키워드와 표현식(반환값)으로 이뤄진 `반환문`을 사용해
- ┗ 실행 결과를 함수 외부로 반환(return) 가능하다.

```js
function multiply(x, y) {
	return x * y; // 반환문
}
// 함수 호출은 반환값으로 평가된다.
var result = multiply(3, 5);
console.log(result); // 15
```

- `multiply` 함수는 두 개의 인수를 전달받아 모든 값을 반환
- ┣ JS에서 사용 가능한 값을 반환가능
- ┣ `함수 호출` : `표현식`
- ┣ `함수 호출` 표현식은 return 키워드가 반환한 `표현식의 평가 결과`
- ┗ 반환값으로 평가된다.

- `반환문`은 두 가지 역할을 함
- ┗ 1. `반환문은 함수의 실행을 중단`하고 함수 몸체를 `빠져나감`

> 반환문 이후에 다른 문이 존재하면 문은 실행되지 않고 무시

```js
function multiply(x, y) {
	return x * y; //반환문
	console.log('실행 안됨');
}
console.log(multiply(3, 5)); // 15
```

- 2.반환문은 return 키워드 `뒤에 오는 표현식을 평가해서 반환`
- ┣ return 키워드 뒤에 반환값으로 사용할 표현식을 명시적 지정 안하면
- ┗ `undefined`가 반환된다.

```js
function foo() {
	return;
}

console.log(foo()); // undefined
```

- 반환문은 생략 가능하다. 이때 함수는 몸체의 마지막 문까지 실행하고
- ┗ 암묵적으로 `undefined`를 `반환`하게 됨

> 반환문은 생략 가능함, 함수는 함수 몸체의 마지막 문까지 실행하고 암묵적으로 undefined 반환

```js
function foo() {
	// 반환문을 생략하면 undefined 반환
}
console.log(foo());
```

- return 키워드와 반환값으로 사용할 표현식 사이에 `줄바꿈`이 있으면
- ┣ `세미콜론 자동 삽입 기능(ASI)`에 의해
- ┣ 자동 삽입 기능에 의해 세미콜론이 추가되어
- ┗ `의도치 않은 버그`가 나타날 수 있음

```js
function multiply() {
	// return 키워드 반환값 사이에 줄바꿈이 있으면
	return; // 세미콜론 자동 삽입 기능(ASI)에 의해 세미콜론 추가
	x * y;
}
console.log(multiply(3, 5)); // undefined
```

- 반환문은 함수 몸체 내부에서만 사용이 가능
- ┗ 전역에서 반환문을 사용하면 문법 에러가 발생!!!

> Node.js 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 가짐

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 원시 값 : 값에 의한 전달(pass by value)
- ┣ 객체 : 참조에 의한 전달(pass by reference) 방식으로 동작
- ┣ 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급됨
- ┣ 그렇기에 매개변수 또한 타입에 따라서 1. 값에 의한 전달
- ┗ 2. 참조에 의한 전달 방식을 그대로 따르게 됨

```js
// 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달 받음
function changeVal(primitive, obj) {
	primitive += 100;
	obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num);
console.log(person);

// 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달됨
changeVal(name, person);

// 원시 값은 원본을 바꾸지 않음
console.log(num); // 100

// 객체는 원본을 바꿈
console.log(person); // {name: "Kim"}
```

- `changeVal` 함수의 경우 매개변수를 통해 전달받은 원시 타입 인수
- ┣ `함수 몸체에서 변경`
- ┣ 원시 타입 인수를 전달받은 primitive 경우
- ┣ 원시 값 : `변경 불가능한 값(im-mutable value)` 직접 변경할 수 없음
- ┣ 재할당을 통해 할당된 원시 값을 새로운 원시 값으로 교체했음
- ┣ 객체 타입 인수를 전달받은 매개변수 obj의 경우
- ┗ `객체는 변경 가능한 값(mutable value)`이므로 직접 변경할 수 있음

- 원시 타입 인수 : 값 자체가 복사되어 매개변수에 전달되기 때문에
- ┣ 함수 몸체에서 그 값을 변경(재할당을 통한 교체)해도 원본은
- ┣ 훼손되지 않음, 외부 상태 에서의 즉 함수 몸체 내부로 전달한
- ┗ 원시 값의 원본을 변경하는 어떠한 부수 효괄도 발생하지 않음

- 객체 타입 인수는 참조 값이 복사되어 배개변수에 전달하기 때문에
- ┣ 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 바뀜
- ┣ 외부 상태, 즉 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해
- ┗ `원본 객체가 변경되는` `부수 효과`가 발생한다.

- 이처럼 함수가 외부 상태를 변경하면 상태 변화의 추적이 어려워짐
- ┣ 좋은 동작이 아님 → 논리가 간단해야 버그가 없음
- ┣ 이러한 현상은 `객체가 변경할 수 있는 값` 이며
- ┗ `참조에 의한 전달 방식`으로 동작하기 때문에 발생

- 변수가 참조에 의한 전달 방식을 통해 참조 값을 공유하고 있다면
- ┣ 변수들은 언제든지 참조하고 있는 객체를 직접 변경할 수 있음
- ┣ 복잡한 코드에서 의도치 않은 객체의 변경을 추적하는 것은
- ┣ 어려운 일임
- ┣ `객체의 변경을 추적`하려면 `옵저버(Observer)패턴`을 통해
- ┣ `객체를 참조를 공유하는 모든 이들`에게
- ┗ 변경 사실을 통보하고 이를 대처하는 추가 대응이 필요
- 문제 해결 방법 중 하나는 객체를 → `불변 객체(immutable object)`로
- ┣ 만들어서 사용하는 방법이 존재
- ┣ 객체의 복사본을 새롭게 생성하는 비용은 들지만
- ┣ 객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만듬
- ┣ 이를 객체의 상태 변경을 원천봉쇄하고
- ┣ 객체의 상태 변경이 필요한 경우에는
- ┣ `객체의 방어적 복사(defensive copy)`를 통해서
- ┣ 원본 객체를 완전히 복제 → `깊은 복사(deep copy)`를 통해
- ┣ 새로운 객체를 생성하고 재할당을 통해 이를 교체
- ┗ 외부 상태가 변경되는 부수 효과를 없앨 수 있음

> 외부 상태를 변경하지 않고 외부 상태에 의도하지도 않는 함수 → 순수 함수

순수 함수를 통해 부수 효과를 최소화 하여
┣ 오류를 피하고 프로그램의 안정성을 높이는 작업을
┗ 함수형 프로그래밍이라고 부름

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수

- 함수 정의와 동시에 즉시 호출되는 함수
- ┣ 즉시 실행 함수(IIFE : Immediately invoked Function Expression )
- ┗ 이 경우 단 한번만 호출되며 다시 호출 불가

```js
// 익명 즉시 실행 함수
(function () {
	var a = 3;
	var b = 5;
	return a * b;
})();
```

- 즉시 실행 함수는 함수 이름이 없는 익명 함수를 사용하는 것이 일반적
- ┣ 함수 이름이 있는 기명 → 실행 함수도 사용이 가능함
- ┣ 하지만 그룹 연산자 (...) 내의 기명 함수는
- ┣ 함수 선어문이 아닌 → 함수 리터럴로 평가
- ┣ 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자
- ┗ 즉시 실행 함수를 다시 호출할 수 없음

```js
// 기명 즉시 실행 함수
(function foo() {
	var a = 3;
	var b = 5;
	return a * b;
})();

foo();
```

> 즉시 실행 함수의 경우 반드시 그룹 연산자 (...)로 감싸야 함
> 안그러면 오류가 생김

- 에러가 발새하는 이유는 함수 정의 → 함수 선언문의 형식에 맞지 않아서
- ┗ 함수 선언문은 함수 이름을 생략할 수 없음

```js
function foo() {
   // ...
}(); // SyntaxError
```

> 하지만 위와 같은 경우에도 오류가 발생하게됨

    JS 엔진이 암묵적으로 수행하는 ASI 기능
    ┣ 이것 때문에 선언문이 끝나는 위치
    ┣ 코드 블록의 닫는 중괄호 뒤에 ";"이
    ┗ 암묵적으로 추가되기 때문

```js
function foo() {};();
```

- 함수 선언문 뒤의 `()`는 함수 호출 연산자가 아닌
- ┣ 그룹 연산자로 해석이 되고
- ┗ 그룹 연산자에 피연산자가 없기 때문에 에러가 발생

- 그룹 연산자의 `피연산자는 값으로 평가`
- ┣ `기명 또는 무명 함수`를 `그룹 연산자`로 감싸면
- ┗ `함수 리터럴`로 평가되어 → `함수 객체`가 됨

```js
console.log(typeof function f() {}); // function
console.log(typeof function () {}); // function
```

- `그룹 연산자`로 `함수를 묶은 이유`는
- ┣ `함수 리터럴을 평가`해서 → `함수 객체를 생성`하기 위해서
- ┣ `함수 리터럴을 평가`해서 함수 객체를 생성할 수 있따면
- ┗ 그룹 연산자 `이외의 연산자`를 사용해도 됨

```js
(function () ) {
   // ...
}());

(function () {
   // ...
})();

!function() {
   // ...
}();

+function () {
   // ...
}();
```

> 즉시 실행 함수도 일반 함수처럼 값을 반환가능, 인수를 전달도 가능

```js
var res = (function () {
	var a = 3;
	var b = 5;
	return a * b;
})();

console.log(res); // 1

// 즉시 실행 함수에도 일반 함수처럼 인수 전달 가능

res =
	(function (a, b) {
		return a * b;
	},
	(3, 5));

console.log(res); // 15
```

> 즉시 실행 함수 내에 코드를 모아보면 변수나 이름의 충돌 방지 가능

### 12.7.2 재귀 함수

- 함수가 자기 자신을 호출하는 것을 `재귀 호출(recursive)`이라고 함
- ┣ `재귀 함수(recursive function)`는 자기 자신을 호출하는 행위
- ┗ 재귀 호출을 수행하는 함수를 의미

> 재귀 함수는 반복되는 처리를 위해 사용
> 10 부터 0까지 출려갛는 함수

```js
function countdown(n) {
	if (n < 0) return;
	console.log(n);
	countdown(n - 1);
}

countdown(10);
```

- 이처럼 자기 자신을 호출하는 재귀 함수를 사용하면
- ┣ 반복되는 처리를 반복문 없이 구현이 가능하다.
- ┗ 팩토리얼은 재귀 함수로 간단히 구현 가능

```js
function factorial(n) {
	if (n <= 1) return 1;
	// 재귀 호출
	return n * factorial(n - 1);
}
```

- factorial 함수 내부에서 `자기 자신을 호출`할 때 `사용한 식별자`
- ┣ factorial은 `함수 이름`임
- ┣ `함수 이름`은 `함수 몸체 내부에서만 유효`
- ┣ `함수 내부`에서는 `함수 이름을 사용`해
- ┣ `자기 자신을 호출` `가능`
- ┣ `함수 표현식`으로 정의한 `함수 내부`에서는
- ┣ `함수 이름은 물론` 함수를 가르키는 `식별자`로도
- ┗ 자기 `자신의 재귀 호출이 가능`

> 단 함수 외부에서 함수를 호출할 때는 반드시 함수를 가르키는 식별자로 해야함

```js
var factorial = function foo(n) {
	if (n <= 1) return 1;
	return n * factorial(n - 1);
	// 함수 이름으로 자기 자신을 재귀 호출 가능
	console.log(factorial === foo); // true
	// return n * foo(n-1)
};
```

- 재귀 함수는 자신을 무한 재귀 호출
- ┣ 따라서 재귀 호출을 멈출 수 있는 탈출 조건을
- ┣ 반드시 만들어야 함
- ┗ 탈출 조건이 없으면 무한 호출되어 `스택 오버플로(stack overflow)`

- 대부분의 재귀 함수는 for문이나 while문으로 구현 가능

> 재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있다는 장점 존재

    그러나 스택 오버 플로 위험성존재
    반복문보다 재귀함수 이해가 좋을 경우만 사용

### 12.7.3 중첩 함수

- 함수 내부에 정의된 함수 : `중첩 함수(nested function)` 또는 `내부함수(inner function)`
- ┣ `중첩 함수`를 포함하는 함수는 `외부 함수(outer function)` 라고 부름
- ┣ `중첩 함수`는 `외부 함수 내부`에서만 `호출이 가능`
- ┣ 일반적으로 `중첩 함수`는 `자신을 포함하는 외부 함수를 돕는`
- ┗ `헬퍼 함수(helper function)` 역할을 함

```js
function outer() {
	var x = 1;

	//중첩 함수
	function inner() {
		var y = 2;
		// 외부 함수의 변수를 참조 가능
		console.log(x + y);
	}
	inner();
}

outer();
```

- `ES6` 부터 `함수 정의`는 `문이 위할 수 있는 문맥`이라면
- ┣ `어디든지 가능`함
- ┣ 함수 선언문의 경우 `ES6` 이전에는 코드 최상위 또는
- ┣ 다른 함수 내부에서만 정의할 수 있었으나
- ┣ `ES6` 부터는 `if 문이나 ofr 문등의 코드 블록`에서도
- ┗ 정의가 가능하다.

- `호이스팅으로 인해 혼란`이 발생할 수 있으니
- ┣ `if 문이나 for문 등의 코드 블록`에서
- ┣ `함수 선언문`을 통해
- ┣ 함수를 정의하는 것은 `바람직하지 않음`
- ┗ `중첩함수`는 `스코프`와 `클로저`에 깊은 관계 존재

### 12.7.4 콜백 함수

- 어떤 일을 반복하는 repeat 함수

```js
function repeat(n) {
	for (var i = 0; i < n; i++) console.log(i);
}
```

> 만약 repeat 함수 반복문 내에서 다른 일을 하고 싶다면 함수 새로 정의

- 함수의 일부분만 다를 경우 함수를 새로 생성하는 일이 효율적이지 않음
- ┣ 이 문제는 함수를 합성함으로 해결이 가능하다.
- ┣ 함수의 변하지 않는 공통 로직을 짜두고
- ┣ 경우에 따라서 벼경되는 로직은 추상화해서
- ┗ 함수 외부에서 함수 내부로 전달

```js
function repeat(n, f) {
   for (var i =0; i<n; i++){
      f(i); // i를 전달하면서 f를 호출
   }
}
function logAll = function(i) {
   console.log(i);
}

// 반복 호출할 함수를 인수로 전달
repeat(5, logAll);

var logOdds = function (i) {
   if (i % 2) console.log(i);
}

// 반복 호출할 함수를 인수로 전달
repeat(5, logOdds)
```

- repeat 함수는 경우에 따라 변경되는 일을
- ┣ 함수 f로 추상화 했고
- ┣ 이를 외부에서 전달받게 됨
- ┣ JS 함수는 일급 객체이기 때문에
- ┣ 함수의 매개변수로 → 함수를 전달 가능
- ┣ repeat 함수는 더 이상 내부 로직에 강력히 의존 X
- ┣ 외부에서 로직의 일부분을 함수로 전달받아
- ┗ 더욱 유연한 구조를 갖게 됨

- 이렇게 함수의 매개변수를 통해
- ┣ `다른 함수의 내부로 전달되는 함수` : `콜백함수`
- ┣ `매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수` : `고차함수`
- ┣ 매개변수를 통해 `1. 함수를 전달 받거나`, `2. 반환값으로 함수를 반환`하는
- ┗ 함수를 `함수형 프로그래밍 패러다임` 이라고 부름

> 고차 함수에 경우 뒤에 배열 고차 함수에서 자세히 다룸

- `중첩 함수`가 `외부 함수를 돕는 헬퍼 함수`의 역할을 하는 것처럼
- ┣ `콜백 함수`도 `고차 함수에 전달되어 헬퍼 함수의 역할`을 함
- ┣ 단, `중첩 함수`는 `고정`되어 있어서 `교체가 힘들지만`
- ┣ `콜백 함수` : 함수 `외부` → `내부`로 주입하기 때문에 `교체 쉬움`
- ┗ `고차 함수`는 `콜백 함수`를 자신의 `일부분으로 합성`

- `고차 함수`는 `매개변수`를 통해 `전달받은 콜백 함수`의
- ┣ `호출 시점`을 결정해서 호출
- ┣ `콜백 함수`는 `고차 함수`에 의해 호출
- ┣ `고차 함수`는 필요에 따라서 `콜백 함수에 인수를 전달 가능`
- ┣ 고차 함수에 콜백 함수를 전달할 때
- ┗ 콜백 함수를 호출하지 않고 `함수 자체를 전달`

> 콜백 함수가 고차 함수 내부에만 호출 된다면
> 콜백 함수를 익명함수 리터럴로 정의하면서
> 곧바로 고차 함수에 전달하는 것이 일반적

```js
// 익명 함수 리터럴은 콜백 함수로 고차 함수에 전달
// 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 새 객체 생성
repeat(5, function (i) {
	if (i % 2) console.log(i);
});
```

- 이때 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다
- ┣ 평가되어서 함수 객체를 생성
- ┣ 1.콜백 함수를 다른 곳에서 호출하거나
- ┣ 2. 콜백 함수를 전달받는 함수가 자주 호출 된다면
- ┗ 외부에서 콜백 함수를 정의한 후 → 함수 참조를 고차 함수에 전달하는 편이 효율적

```js
// logOdds 함수는 단 한번만 생성
var logOdds = function (i) {
	if (i % 2) console.log(i);
};

// 고차 함수에 함수 참조를 전달
repeat(5, logOdds); // 1 3
```

- 위 예제의 logOdds 함수는 단 한번만 생성
- ┣ 콜백 함수를 익명 함수 리털로 정의 하면서
- ┣ 곧바로 고차 함수에 전달하면 고차 함수 호출 마다
- ┗ 콜백 함수가 생성됨

> 콜백 함수는 함수형 프로그래밍 패러다임 뿐만이 아닌
> 비동기 처리(이벤트 처리, Ajax, 타이머 함수)
> 에서도 사용되는 중요한 패턴

```js
// 콜백 함수를 사용한 이벤트 처리
// myButton 버튼을 클릭하면 콜백 함수를 실행
document.getElementById('myButton').addEventLister('click', function () {
	console.log('bt clicked');
});

// 콜백 함수를 사용한 비동기 처리
// 1초 후에 메시지 출ㄹ력
setTimeout(function () {
	console.log('1초 경과');
}, 1000);
```

- 콜백 함수는 비동기 처리뿐아닌 배열 고차 함수에서도 사용
- ┣ JS에서 배열은 사용 빈도가 매우 높은 자료이고
- ┗ 배열을 다룰 때 배열 고차함수는 매우 중요

```js
//콜백 함수를 사용하는 고차 함수 map
var res = [1, 2, 3].map(function (item) {
	return item * 2;
});

var res = [1, 2, 3].filter(function (item) {
	return item % 2;
});

var res = [1, 2, 3].reduce(function (acc, cur) {
	return acc + cur;
}, 0);
```

### 12.7.5 순수 함수와 비순수 함수

- 함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고
- ┣ 변경하지도 않는 → 부수 효과가 없는 함수를
- ┗ `순수 함수(pure function)`라고 함
- ┣ 반면 외부 상태에 의존, 외부 상태 변경 → 부수 효과
- ┗ `비순수 함수(impure function)`

- `순수 함수`는 `동일한 인수`가 전달되면 언제나 `동일한 값`을
- ┣ `반환`하는 함수
- ┣ `순수 함수`는 어떤 외부 상태에도 의존하지 않고
- ┣ 오로지 `매개변수`를 통해 `함수 내부로 전달된 인수`에게만
- ┣ `의존해서 반환값`을 만들게 됨
- ┣ 함수의 `외부 상태에 의존하는 함수`는 `외부 상태`에 의해
- ┗ `반환값이 달라지게 됨`

```js
var count 0;

// 순수 함수 increase는 동일한 인수가 전달되면 동일한 값 반환
function increase(n) {
   return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); //1

count = increase(count);
console.log(count); //2
```

- 반대로 함수의 외부 상태에 따라 반환값이 달라지는
- ┣ `외부 상태에 의존`하는 함수 → `비순수 함수`
- ┣ 외부 상태를 변경하는 `부수 효과` 존재
- ┗ 비순수 함수는 외부 상태에 의존하거나 외부 상태 변경하는 함수

```js
var count = 0;

// 비순수 함수
function increase() {
	return ++count;
}

// 비순수 함수는 외부 상태를 변경하기 때문에 추적이 어려워짐
count = increase(count);
console.log(count); //1

count = increase(count);
console.log(count); //2
```

- 위 예제와 같이 함수 내부에서 외부 상태를 직접 참조하면
- ┣ 외부 상태에 의존하게 되어
- ┣ 1. 반환값이 변할 수 있고
- ┣ 2. 외부 상태도 변경할 수 있기 때문에
- ┗ 비순수 함수가 됨

- 함수 내부에서 외부 상태를 직접 참조하지 않더라도
- ┗ 매개변수를 통해서 `객체` 전달받으면 → 비순수 함수

- `함수형 프로그래밍`은 `순수 함수`와 `보조 함수`의 `조합`을 통해
- ┣ 외부 상태를 벼경하는 `부수 효과`를 `최소화`해서
- ┣ `불변성(immutable)을 지향하는 프로그래밍 패러다임`
- ┣ 1. 로직 내에 존재하는 `조건문과 반복문을 제거` 하여
- ┣ 복잡성을 해결, 2. `변수 사용을 억제`하거나 `생명주기 최소화`
- ┣ 하여서 상태 변경을 피해 오류를 최소화하는 것을 목표로 함
- ┣ 조건문이나 반복문은 로직의 흐름을 이해하기 어렵기 해서
- ┗ 가독성을 해치고 변수의 값은 누군가에 의해서 언제든지 변경이 가능하기 때문

> 함수형 프로그래밍 : 순수 함수를 통해 부수효과를 억제해서 오류를 피하고
> 프로그램 안정성을 높이려는 노력의 일환
> JS는 멀티 패러다임 언어이므로 객체지향 프로그래밍뿐만 아닌
> 함수형 프로그래밍 적극적 활용
