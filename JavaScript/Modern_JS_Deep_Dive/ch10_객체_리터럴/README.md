# 10 객체 리터럴

## 목차

- [10 객체 리터러](#10-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%AC)
  - [10.1 객체란?](#101-%EA%B0%9D%EC%B2%B4%EB%9E%80)
  - [10.2 객체 리터럴에 의한 객체 생성](#102-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1)
  - [10.3 프로퍼티](#103-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0)
  - [10.4 메서드](#104-%EB%A9%94%EC%84%9C%EB%93%9C)
  - [10.5 프로퍼티 접근](#105-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A0%91%EA%B7%BC)
  - [10.6 프로퍼티 값 갱신](#106-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EA%B0%92-%EA%B0%B1%EC%8B%A0)
  - [10.7 프로퍼티 동적 생성](#107-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%8F%99%EC%A0%81-%EC%83%9D%EC%84%B1)
  - [10.8 프로퍼티 삭제](#108-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%82%AD%EC%A0%9C)
  - [10.9 ES6에서 추가된 객체 리터럴의 확장 기능](#109-es6%EC%97%90%EC%84%9C-%EC%B6%94%EA%B0%80%EB%90%9C-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%9D%98-%ED%99%95%EC%9E%A5-%EA%B8%B0%EB%8A%A5)
    - [10.9.1 프로퍼티 축약 표현](#1091-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%B6%95%EC%95%BD-%ED%91%9C%ED%98%84)
    - [10.9.2 계산된 프로퍼티 이름](#1092-%EA%B3%84%EC%82%B0%EB%90%9C-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%9D%B4%EB%A6%84)
  - [10.9.3 메서드 축약 표현](#1093-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B6%95%EC%95%BD-%ED%91%9C%ED%98%84)

## 10.1 객체란?

- JS는 객체(object) 기반의 프로그래밍 언어
- ┣ JS의 구성하는 것의 모든 것 이라고 해도 무방
- ┗ 원시 값을 제외한 나머지 값 (함수, 배열, 정규 표현식)

- 원시 타입은 단 하나의 값만 나타내지만
- ┣ 객체 타입(object/reference type)은 다양한 타입의 값을
- ┗ 하나의 단위로 구성한 복합적인 `자료구조임(data structure)`

- 원시 타입의 값, 즉 원시 값은 변경 불가능한(immutable value) 이지만
- ┣ 객체는 원시값 적으로 `변경 불가능 한 값(immutable value)`이지만
- ┣ 객체 타입의 값, 즉 객체는 변경 가능 한 값
- ┗ 이에 대한 자세한 내용은 뒤에서 다룸

- 객체는 0개 이상의 프로퍼티로 구성된 집합이며
- ┗ 프로퍼티는 키(key)와 값(value)으로 구성됨

- JS에서 사용될 수 잇는 모든 값은
- ┣ 프로퍼티 값이 될 수 있음
- ┣ JS 함수는 일급 객체이므로 값으로 취급 될 수 있음
- ┗ 고로 함수도 프로퍼티 값으로 사용될 수 잇음

- 프로퍼티 값이 함수 일 경우 일반 함수와 구분하기 위해서
- ┗ `메서드(method)`라고 부르게 됨

- 이처럼 객체는 프로퍼티와 메서드로 구성된 집합체임
- ┣ `프로퍼티` : 객체의 상태를 나타내는 값(data)
- ┗ `메서드` : 프로퍼티(상태 데이터)를 `참조하고 조작`할 수 잇는 `동작(behavior)`

- 이처럼 객체는 객체의 상태를 나타내는 값(프로퍼티)를 참조하고
- ┣ 조작할 수 있는 동작(메서드)를 모두 포함할 수 있기 때문에
- ┗ 상태와 동작을 하나의 단위로 구조화 할 수 있어서 유용

> 객체와 함수

    JS에서 객체는 함수와 밀접한 관계를 가지게됨
    ┣ 함수를 객체를 생성하기도 하며 함수 자체로 객체이기도 함
    ┣ JS에서 함수와 객체는 분리해서 생각할 수 없는 개념
    ┣ 객체를 이해해야 → 함수를 제대로 이해 가능
    ┣ 따라서 객체를 함수를 분리해서 설명하는 것은 옳지 않지만
    ┗ 이 책에서는 따로 설명을 함

- 객체의 집합으로 프로그램을 표현 → 객체지향 프로그래밍

## 10.2 객체 리터럴에 의한 객체 생성

- C나 JAVA와 같은 클래스 기반 객체지향 언어는
- ┣ 클래스를 사전에 정의하고 필요한 시점에 `new 연산자`와 함께
- ┗ `생성자(constructor)`를 호출하여 `인스턴스 생성`하는 방식으로 객체를 생성

- 인스턴스

  - 인스턴스란 클래스에 의해 생성되어 `메모리에 저장된 실체`를 뜻함
  - ┣ 객체지향 프로그래밍에서 객체는 클래스, 인스턴스를 포함한 개념
  - ┣ 클래스는 인스턴스를 생성하기 위한 템플릿의 역할
  - ┣ 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에
  - ┗ 초점을 맞춘 언어

- JS는 프로토타입 기반 → 객체지향 언어로서
- ┗ 클래스 기반 객체 지향 언어와는 달리 다양한 객체 생성 방법 지원

1. 객체 리터럴

2. Object 생성자 함수

3. 생성자 함수

4. Object.create 메서드

5. 클래스(ES6)

- 이러한 객체 생성 방법 중에서 가장 일반적이고 간단한 방법은
- ┣ 객체 리터럴을 사용하는 방법
- ┗ 리터럴 : 사람이 이해할 수 있는 문자 또는 약속된 기호로 값을 생성하는 방법

- 객체 리터럴은 `({...})` 내에 0개 이상의 프로퍼티를 정의
- ┗ 변수에 할당되는 시점에 JS 엔진은 객체 리터럴을 해석해 객체를 생성

```js
var person = {
	name: 'Jang',
	sayHello: function () {
		console.log(`Hi my name is ${this.name}`);
	},
};

console.log(typeof person); // obj
console.log(person); // {name: "Jang", sayHello: f}
```

> 만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성

```js
var empty = {};
console.log(typeof empty); // object
```

- `객체 리터럴의 중괄호`는 `코드 블럭을 의미하지 않음`!!!
- ┣ 코드 블럭의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않음
- ┣ 그러나 객체 리터럴은 `값`으로 평가되는 `표현식`
- ┗ 따라서 객체 리터럴의 `닫는 중괄호` 뒤에는 `세미콜론`을 붙임

- `객체 리터럴`은 JS의 유연함과 강력함을 대표하는 `객체 생성 방식`
- ┣ 객체를 생성하기 위해
- ┣ 1. 클래스를 먼저 정의하고
- ┗ 2. new 연산자와 함께 생성자를 호출하는 방식이 필요 없음

- 숫자 값이나 문자열을 만드는 것과 유사하게
- ┣ 리터럴을 이용해서 → 객체를 생성
- ┣ `객체 리터럴에 프로퍼티를 포함`시켜서
- ┣ 1. `객체를 생성`하는 동시에
- ┣ 2. `프로퍼티(객체의 상태를 나타내는 data)를 만들` 수도 있고
- ┗ 3. 객체를 생성한 이후에 프로퍼티를 `동적 추가`도 가능!

## 10.3 프로퍼티

- `객체`는 `프로퍼티의 집합`이며
- ┗ `프로퍼티는 키와 값`으로 구성됨

```js
var person = {
	// 프로퍼티 키는 name, 프로퍼티 값은 'Lee;
	name: 'Lee',
	// 프로퍼티 키는 age, 프로퍼티 값은 20
	age: 20,
};
```

- 프로퍼티를 나열할 때는 쉼표(,)로 구분하게 됨
- ┣ 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나
- ┗ 사용해도 무관하다.

> 프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값

    `프로퍼티 키` : 빈 문자열을 포함하는 모든 문자열, 심벌 값
    ┗ 프로퍼티 값 : JS에서 사용할 수 있는 모든 값

- `프로퍼티 키`는 프로퍼티 값에 접근할 수 있는 이름으로서
- ┣ 식별자 역할을 하게 됨
- ┣ 하지만 반드시 식별자 네이밍 규칙을 따라야 하는 것은 아님
- ┗ 그러나 식별자 규칙을 따르고 안따르고는 미묘한 차이가 존재

- 심벌 값도 프로퍼티 키로 사용할 수 있음 → 일반적으로 문자열을 사용
- ┣ 이때 프로퍼티 키는 문자열 이므로 `따옴표('...', "...")`를 이용
- ┣ 하지만 식별자 규칙을 준수하는 이름 → JS에서 사용한 유효한 이름인 경우
- ┣ 따옴표를 생략 가능
- ┗ 식별자 네이밍 규칙 따르지 X → 반드시 따옴표를 사용해야 함

- 식별자 네이밍 규칙을 따르지 않는 프로퍼티 키를 사용하면
- ┣ 번거로운 일이 발생
- ┣ 가급적 식별자 네이밍 규칙을 준수하는
- ┗ 프로퍼티 키를 사용할 것을 권고

```js
var person = {
	firstName: 'Jang', // 식별자 네이밍 규칙 준수
	'last-name': 'Hyun', // 식별자 네이밍 규칙 준수 X
};

console.log(person); // {firstName: "Jang", last-name: "Hyun"}
```

- 프로퍼티 키로 사용한 `firstName`은 `식별자 네이밍 규칙을 준수`
- ┣ 따라서 따옴표를 생략할 수 있음
- ┣ 하지만 last-name은 식별자 네이밍 규칙을 준수하지 않음
- ┣ 따라서 따옴표를 생략할 수 없음
- ┣ JS 엔진은 따옴표를 생략한 `last-name`을
- ┗ `-` 연산자가 있는 `표현식`으로 해석

```js
var person = {
    firstName : "Jang",
    last-name: 'Hyun" // SyntaxError
}
```

- 문자열 또는 문자열로 평가할 수 있는 표현식을 사용해
- ┣ 프로퍼티 키를 동적으로 생성할 수도 잇음
- ┗ 이 경우에는 프로퍼티 키로 사용할 표현식을 `대괄호([...])`로 묶어야함

```js
var obj = {};
var key = 'hello';

// ES5 : 프로퍼티 키 동적 생성
obj[key] = 'world';
// ES6 : 계산된 프로퍼티 이름
// var obj = {[key]: 'world'};

console.log(obj);
// {hello: "world"}
```

> 빈 문자열을 프로퍼티 키로 사용해도 에러가 발생하지 않음

    하지만 키로서의 의미를 갖지는 못함!

```js
var foo = {
	'': '', // 빈 문자열도 프로퍼티 키로 사용할 수 있음
};
console.log(foo); // {"":""}
```

- `프로퍼티 키`에 문자열이나 심벌 값 `외의 값`을 사용하면
- ┣ `암묵적 타입 변환`을 통해 `문자열이 됨`
- ┣ 예를 들어 프로퍼티 키로 숫자 리터럴을 사용하면
- ┗ 따옴표는 붙지 않지만 `내부적으로는 문자열로 변환`

> RN에서 외박신청 앱을 만들 때 라이브러리가

    날짜 : 스타일 객체 형식을 사용!
    이를 유의

```js
var foo = {
	0: 1,
	1: 2,
	2: 3,
};
console.log(foo);
// {0: 1, 1: 2, 2: 3}
```

- `var`, `function`과 같은 예약어를 프로퍼티 키로 사용해도 에러가 발생하지 않음
- ┗ 하지만 예상치 못한 에러가 발생할 여지가 있으므로 권장 X

```js
var foo = {
	var: '',
	function: '',
};
console.log(foo);
// {var: "", function: ""}
```

- `이미 존재하는 프로퍼티` 키를 `중복 선언`하면 나중에 선언한 프로퍼티가
- ┗ `선언한 프로퍼티를 덮어쓰게 됨` → 에러는 발생 안함

```js
var foo = {
	name: 'Lee',
	name: 'Kim',
};
console.log(foo); //{name: "Kim"}
```

## 10.4 메서드

- JS에서 사용할 수 잇는 모든 값은 프로퍼티 값으로 사용가능
- ┣ JS `함수`는 `객체(일급 객체)`임
- ┗ 함수는 값으로 취급할 수 있기 때문에 → 프로퍼티 값으로 사용가능

- 프로퍼티 값이 함수일 경우 일반 함수와 비교하기 위해서
- ┗ `메서드`라고 부름 → `메서드` : `객체에 묶여있는 함수`

```js
var circle = {
	radius: 5, // 프로퍼티

	//원의 지름
	getDiameter: function () {
		return 2 * this.radius; // this는 circle을 가리킨다.
	},
};

console.log(circle.getDiameter());
```

- 메서드 내부에서 사용한 `this 키워드`는 `객체 자신(circle 객체)`을
- ┗ 가리키는 `참조 변수`임 → this 22장에서 다루게 됨

## 10.5 프로퍼티 접근

- 프로퍼티 접근하는 방법은 다음과 같이 두 가지

1. `마침표 프로퍼티 접근 연산자(.)` 를 사용하는 `마침표 표기법(dot notation)`

2. `대괄호 프로퍼티 접근 연산자([])` 를 사용하는 `대괄호 표기법(bracket notation)`

- 프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름
- ┣ 즉 JS에서 이용 가능한 유효한 이름일 경우
- ┗ 마침표 표기법과 대괄호 표기법 모두 이용 가능!

- 마침표 프로퍼티 접근 연산자 또는 대괄호 프로퍼티 접근 연산자
- ┣ `우측` : 객체로 평가되는 `표현식`을 기술
- ┗ `좌측` : `프로퍼티 키`를 지정

```js
var person = {
	name: 'Jang',
};

// 마침표 표기법에 의한 프로퍼티 접근
console.log(person.name); // Lee

// 대괄호 표기법에 의한 프로퍼티 접근
console.log(person['name']); // Lee
```

- 대괄호 표기법을 사용하는 경우 `내부로 접근하는 프로퍼티 키`는
- ┣ 무조건 `따옴표로 감싼 문자열이어야 함`
- ┗ 따옴표로 감싸지 않은 이름 사용시 → JS 엔진 이를 식별자로 해석

```js
var person = {
	name: 'Jang',
};
console.log(person[name]); //Reference Error
```

- 위 예제어서 Reference 에러의 이뉴는 대괄호 연산자 내에서
- ┣ 따옴표로 감싸지 않은 이름 → `식별자 name` 찾았지만
- ┗ 찾지 못했기 때문에 에러가 난다.

> 객체에 존재하지 않는 프로퍼티에 접근하면

    `undefined` 반환
    ┗ 이때 `ReferenceError`가 발생하지 않으니 주의

```js
var person = {
	name: 'Jang',
};
console.log(person.age); //undefined
```

- 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는다면
- ┣ 즉 : JS에서 사용 가능한 유효한 이름이 아니라면
- ┣ 반드시 ! 대괄호 표기법을 사용해야 함
- ┣ 단 : `프로퍼티 키가 숫자로 이뤄진 문자열`의 경우는
- ┗ 따옴표를 생략 가능하다.

> 이외의 경우는 모두 따옴표로 감싼 문자열이어야 한다는 점 잊지 말기

> 예제

```js
var person = {
	'last-name': 'Jang',
	1: 10,
};

person.'last-name'; // SyntaxError
person.last-name; // 브라우저 → NaN
                  // Node.js ReferenceError: name is not defined

person[last-name]; //ReferenceError : last is not defined
person['last-name']; // Lee

person.1; // SyntaxError : Unexpected number
person.'1'; // SyntaxError : Unexpected string
person[1]; // 10 : person[1] → person['1']
person['1'] // 10
```

- 여기서 보면 person.last-name의 경우 브라우저와 Node의 실행결과가 다름
- ┣ 그 이유는 JS 엔진은 먼저 person.last를 평가
- ┣ person 객체에는 프로퍼티 키가 last인 프로퍼티가 없음
- ┣ person.last는 undefined로 평가
- ┣ 따라서 `person.last-name` → `undefined-name` 과 같음
- ┗ 다음으로 JS 엔진은 name이라는 식별자를 찾음

> 여기서의 name은 프로퍼티 키가 아닌 식별자로 해석되는 것을 주의

- Node.js 환경에서는 현재 어디에도 name이라는 식별자(변수, 함수 등의 이름)
- ┣ 으로 선언이 없기 때문에 Reference Error가 발생
- ┣ 그러나 브라우저 환경에서는 전역 변수(전역 객체 window)프로퍼티가
- ┣ 암묵적으로 존재하게 됨!!! → name 은 `윈도우 창`을 가르키며 `빈 문자열 의미`
- ┗ 그렇기에 `person.last-name` → `undefined-''` 과 같으므로 `NaN`이 됨

## 10.6 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신

```js
var person = {
	name: 'Lee',
};
// person 객체에 name 프로퍼티가 존재하므로
// name 프로퍼티의 값이 갱신

person.name = 'Jang';

console.log(person);
```

## 10.7 프로퍼티 동적 생성

- `존재하지 않는 프로퍼티에 값을 할당`하면
- ┗ 프로퍼티가 `동적으로 추가`, `할당`이 이루어짐

```js
var person = {
	name: 'Lee',
};

// person 객체에는 age 프로퍼티가 존재하지 않음
// 따라서 person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당

person.age = 20;
console.log(person); // {name: "Lee", age: 20}
```

## 10.8 프로퍼티 삭제

- `delete` 연산자는 객체의 프로퍼티를 삭제
- ┣ 이때 `delete` 연산자의 `프로퍼티 값에 접근 가능`해야 함
- ┗ 만약 존재하지 않는 프로퍼티 삭제 → `아무런 에러 없이 무시`

```js
var person = {
	name: 'Jang',
};
person.age = 20;
// person 객체에 age 프로퍼티 존재
// 고로 delete를 이용해서 삭제도 가능

delete person.age;
```

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

- ES6 에서는 더욱 간편하고 표현력 있는 객체 리터럴의
- ┗ 확장 기능을 제공하게 됨

### 10.9.1 프로퍼티 축약 표현

- 객체 리터럴의 프로퍼티 : 프로퍼티 키, 프로퍼티 값으로 구성
- → 프로퍼티 값은 변수에 할당된 값 → 식별자 표현식일 수 있음

```js
var x = 1,
	y = 2;

var obj = {
	x: x,
	y: y,
};
console.log(obj); // {x: 1, y:2}
```

- ES6에서는 프로퍼티 값으로 변수를 사용하는 경우
- ┣ `변수 이름`과 `프로퍼티 키`가 `동일한 이름`일 때
- ┣ `프로퍼티를 생략(property shorthand)` 가능
- ┗ 프로퍼티 키는 변수 이름으로 자동 생성

```js
// ES6
let x = 1,
	y = 2;

//프로퍼티 축약 표현
const obj = { x, y };

console.log(obj); // {x:1, y:2}
```

### 10.9.2 계산된 프로퍼티 이름

- 문자열 또는 문자열 타입 변환할 수 있는 값으로 평가되는
- ┣ 표현식을 사용해 프로퍼티 키를 동적으로 생성가능
- ┣ 단 프로퍼티 키로 사용할 표현식을 `대괄호([])`로 묶어야 함
- ┗ 이를 계산된 프로퍼티 이름(computed property name)이라고 함

- ES5에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성하기 위해
- ┗ `객체 리터럴 외부`에서 `대괄호([])` 표기법을 사용해야 함

```js
var prefix = 'prop';
var i = 0;

var obj = {};

// 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;

console.log(obj);
// {prop-1: 1, prop-2: 2, prop-3: 3}
```

- ES6 에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로
- ┗ `프로퍼티 키를 동적 생성이 가능!!!`

```js
// ES6
const prefix = 'prop';
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로
// 프로퍼티 키를 동적 생성

const obj = {
	[`${prefix}-${++i}`]: i,
	[`${prefix}-${++i}`]: i,
	[`${prefix}-${++i}`]: i,
};

console.log(ojb);
// {prop-1: 1, prop-2: 2, prop-3: 3}
```

## 10.9.3 메서드 축약 표현

- `ES5에서 메서드를 정의`하기 위해서는
- ┗ `프로퍼티 값으로 함수를 할당`함

```js
// ES5
var obj = {
	name: 'Lee',
	sayHi: function () {
		console.log('Hi!' + this.name);
	},
};
obj.sayHi(); //  Hi! Lee
```

- ES6에서는 메서드를 정의할 때 function 키워드 생략 가능!

```js
//ES6
const obj = {
	name: 'Lee',
	// 메서드 축약 표현
	sayHi() {
		console.log('Hi!' + this.name);
	},
};
obj.sayHi(); //  Hi! Lee
```

- ES6 메서드 축약 표현으로 정의한 메서드(함수)는
- ┗ 프로퍼티에 할당한 함수와 다르게 동작 → 뒤에서 설명
