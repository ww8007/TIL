# 13 스코프

## 목차

- [13 스코프](#13-%EC%8A%A4%EC%BD%94%ED%94%84)
  - [13.1 스코르판?](#131-%EC%8A%A4%EC%BD%94%EB%A5%B4%ED%8C%90)
  - [13.2 스코프의 종류](#132-%EC%8A%A4%EC%BD%94%ED%94%84%EC%9D%98-%EC%A2%85%EB%A5%98)
    - [13.2.2 지역과 지역 스코프](#1322-%EC%A7%80%EC%97%AD%EA%B3%BC-%EC%A7%80%EC%97%AD-%EC%8A%A4%EC%BD%94%ED%94%84)
  - [13.3 스코프 체인](#133-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8)
    - [13.3.1 스코프 체인에 의한 변수 검색](#1331-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8%EC%97%90-%EC%9D%98%ED%95%9C-%EB%B3%80%EC%88%98-%EA%B2%80%EC%83%89)
    - [13.3.2 스코프 체인에 의한 함수 검색](#1332-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8%EC%97%90-%EC%9D%98%ED%95%9C-%ED%95%A8%EC%88%98-%EA%B2%80%EC%83%89)
  - [13.4 함수 레벨 스코프](#134-%ED%95%A8%EC%88%98-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84)
  - [13.5 렉시컬 스코프](#135-%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84)

## 13.1 스코르판?

- 스코프(scope) 유효범위는 JS를 포함한 모든 프로그래밍 언어의
- ┣ 기본적이며 중요한 개념
- ┣ 스코프의 이해가 부족하다면 다른 개념을 이해하기 여려움
- ┣ 다른 언어의 스코프와 구별되는 스코프와 비교되는 개념이 존재
- ┗ 각별하게 주의가 필요

- var 키워드로 선언한 변수와 let 또는 const 키워드로
- ┣ 선언한 변수의 스코프도 다르게 동작
- ┗ 스코프는 변수 그리고 함수와 깊은 관련이 있음

- `스코프를 이미 경험`했음
- ┣ `함수의 매개변수` : `함수 몸체 내부`에서만 `참조가능`
- ┣ 함수 몸체 외부에서 참조 불가
- ┣ 이를 매개변수를 참조할 수 있는 유효범위
- ┗ 매개변수의 스코프가 함수 몸체 내부로 한정되기 때문

- 변수는 코드의 가장 바깥 영역뿐이 아닌 코드 블럭이나
- ┣ 함수 `몸체 내에서도` 선언이 가능함
- ┗ `코드 블럭이나 함수`는 `중첩될 수 있음`

- 변수는 자신이 선언된 위치에 의해
- ┣ 자신이 유효한 범위
- ┣ 다른 코드가 변수 자신을 참조할 수 있는 범위가
- ┣ 결정되게 됨
- ┗ 변수뿐만 아닌 모든 식별자가 동일

- 모든 식별자(변수 이름, 함수 이름, 클래스 이름)
- ┣ 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을
- ┣ 참조할 수 있는 유효 범위가 결정되게 됨
- ┣ 이를 스코프라고 함
- ┗ 스코프는 식별자가 유효한 범위를 뜻함

```js
var x= 'global'

function foo {
    var x = 'local';
    console.log(x);
}

foo();

console.log(x)
```

- 코드의 가장 바깥 영역과 foo 함수 내부에 같은 이름을 갖는
- ┣ 변수 x를 선언했고
- ┣ 1, 2에서 x 변수를 참조하게 됨
- ┣ JS 엔진은 이름이 같은 두 개의 변수 중에서
- ┣ 어떤 변수를 참조해야 할 것 인지를 결정해야 함
- ┣ 이를 `식별자 결정(identifier resolution)`이라고 함
- ┣ JS 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지 결정
- ┗ 스코프는 JS 엔진이 식별자를 검색할 때 사용하는 규칙

- JS 엔진은 코드를 실행할 때 코드의 문맥(context)를 고려
- ┣ 코드가 어디서 실행되며 주변에 어떤 코드가 있는지에 따라
- ┗ 동일한 코드도 다른 결과를 나타내게 됨

> 코드의 문맥과 환경

    코드가 어디서 실행되며 어떤 코드가 있는지
    ┣ 이를 `렉시컬 환경(lexical environment)`라고 함
    ┣ 코드의 문맥(context)은 렉시컬 환경으로 이루어짐
    ┣ 이를 구현한 것이 → 실행 컨텍스트
    ┣ 모든 코드는 실행 컨텍스트에서 평가되고 실행
    ┗ 스코프는 실행 컨텍스트와 깊은 관련

- 위 예제에서 코드의 가장 바깥 영역에서 선언된 x 변수는
- ┣ 어디서든 참조가 가능하다.
- ┗ 식별자 이름이 동일하지만 → 자신이 유효한 범위 스코프가 다른 별개 변수

- 식별자는 어떤 값을 구별할 수 있어야 함 → `유일(unique)`해야 함
- ┣ 식별자인 변수 이름은 중복될 수 없음
- ┗ 하나의 값은 유일한 식별자에 `연결(name binding)`되어야 함

- 프로그래밍 언어에서 `스코프(유효 범위)`를 통해서 식별자인
- ┣ 변수 이름의 `충돌을 방지`하고
- ┣ 같은 이름의 변수를 사용할 수 있게 함
- ┣ 스코프 내에서 식별자는 유일해야 하지만
- ┗ `다른 스코프에서는 사용이 가능`

> 스코프 : 네임스페이스

> var 키워드로 선언된 변수는 같은 스코프내에서 중복 선언 허용
> 이를 방지하기 위해서 let, const 사용

## 13.2 스코프의 종류

- 코드는 전역과 지역으로 구분가능

| 구분 | 설명                  | 스코프      | 변수      |
| ---- | --------------------- | ----------- | --------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부        | 지역 스코프 | 지역 변수 |

- 변수는 자신이 선언된 위치 (전역 또는 지역)에 의해
- ┣ 자신이 유효한 범위인 스코프가 결정
- ┣ 전역에서 선언된 변수 : 전역 스코프를 갖는 전역 변수
- ┗ 지역에서 선언된 변수 : 지역 스코프를 갖는 지역 변수

### 13.2.2 지역과 지역 스코프

- 지역 : 함수 몸체 내부를 뜻함
- ┣ 지역 : 지역 스코프를 만듬
- ┣ 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 됨
- ┣ 지역 변수는 자신이 선언된 지역과 하위 지역(중첩 함수)에서만
- ┗ 참조가 가능하다.

> 지역 변수 : 자신의 지역 스코프와 하위 지역 스코프에서 유효

> JS 엔진은 스코프 체인을 통해 참조할 변수를 검색함
> identifier resolution

## 13.3 스코프 체인

- 함수는 전역에서 정의 가능, 함수 몸체 내부에서 정의 가능
- ┣ `함수 몸체 내부`에서 함수가 `정의`된 것 → `함수의 중첩`
- ┣ `함수 몸체 내부`에서 정의한 함수 → `중첩 함수(nested function)`
- ┗ `중첩 함수를 포함`하는 함수를 → `외부 함수(outer function)`

- 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩이 가능
- ┣ 스코프가 `함수의 중첩에 의해 계층적 구조를 가진다는 것`을 의미
- ┣ `중첩 함수`의 `지역 스코프`는 `중첩 함수`를 포함하는
- ┣ 외부 함수의 지역 스코프와 계층적 구조를 가짐
- ┗ 외부 함수의 지역 스코프를 `중첩 함수`의 상위 스코프라고 함

- 모든 스코프는 하나의 계층적 구조로 연결되며
- ┣ 모든 지역 `스코프`의 최상위 스코프 → 전역 스코프
- ┣ 이렇게 `스코프 연결` : `스코프 체인(scope chain)`
- ┣ 스코프 체인은 최상위 스코프인 `전역 스코프`
- ┣ 전역에서 선언된 outer 함수의 `지역 스코프`,
- ┗ outer 내부의 지역 스코프로 이루어짐

- `스코프 체인`은 `물리적인 실체`로 존재
- ┣ JS 엔진은 코드(전역 코드와 함수 코드)를 실행하기에
- ┣ 앞서서 자료구조인 `렉시컬 환경(Lexical Environment)`를 실제로 생성
- ┣ 1. `변수 선언이 실행`되면 `변수 식별자` → `key로 등록`
- ┣ 2. `변수 할당` 일어나면 `변수 식별자`에 `해당하는 값을 변경`
- ┗ 변수의 검색도 `자료구조 상`에서 이루어짐

> 렉시컬 환경

    스코프 체인은 `실행 컨텍스트`와 `렉시컬 환경`을
    ┣ `단방향으로 연결`한 것임
    ┣ `전역 렉시컬 환경`은 `코드가 로드`되면
    ┣ `곧바로 생`성되고 `함수의 렉시컬 환경`은
    ┣ `함수가 호출되면 곧바로 생성`됨
    ┗ 이를 뒤에 실행 컨텍스트에서 학습

### 13.3.1 스코프 체인에 의한 변수 검색

- `JS 엔진`은 `스코프 체인`을 따라서 변수를 참조하는 코드의
- ┣ 스코프에서 시작해서 `상위 스코프 방향으로 이동`하며
- ┣ `선언된 변수를 검색`하게 됨
- ┣ `절대 하위 스코프`로 내려가면 `검색하는 일은 없음`
- ┣ `상위 스코프`에서 `유효한 변수`는
- ┣ `하위 스코프`에서 자유롭게 `참조 가능` 하지만
- ┗ `하위` → `상위` `불가`

- 스코프 체인으로 연결된 스코프의 계층적 구조는 부자 관계로 이뤄진
- ┣ 상속(inheritance)과 유사
- ┗ 상속을 통해 부모 → 자식 자요롭게 가능하지만 반대 불가

### 13.3.2 스코프 체인에 의한 함수 검색

- 전역에 정의된 foo 함수와 함수 내부에 정의된 foo 함수

```js
// 전역 함수
function foo() {
	console.log('global');
}

function boo() {
	// 중첩 함수
	function foo() {
		console.log('local');
	}
	foo();
}
boo();
```

- `함수 선언문`으로 `함수를 정의` → `런타임 이전`에 `함수 객체가 먼저 생성`
- ┣ `JS 엔진`은 `함수 이름과 동일한` 이름의 `식별자`를 `암묵적으로 선언`
- ┗ `생성된 함수 객체를 할당`

- 모든 함수는 함수 이름과 동일한 이름의 식별자에 할당
- ┣ 함수도 식별자에 해당되기 때문에 스코프를 가짐
- ┣ 사실 함수는 식별자에 함수 객체 할당된 것 빼고는
- ┗ 일반 변수와 다를 바 없음

- 따라서 스코프를 변수를 검색할 때 사용하는 규칙
- ┣ 이라고 표현하기 보다는
- ┣ `식별자를 검색하는 규칙`
- ┗ 이라고 하는 편이 좀 더 적함

## 13.4 함수 레벨 스코프

- `지역` : 함수 몸체 `내부`, `지역` : `지역 스코프`를 만듬
- ┣ `코드 블록이 아닌 함수`에 의해서만
- ┗ `지역 스코프가 생성`된다는 의미

- C나 자바를 비롯한 대부분 언어는
- ┣ 함수 몸체만이 아닌 모든 코드 블록
- ┣ (`if`, `for`, `while`, `try/catch`)이 지역 스코프 만듬
- ┣ 이러한 특성 : `블록 레벨 스코프(block level scope)` 라고 함
- ┣ var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을
- ┗ 지역 스코프로 인정

> 이러한 특성을 함수 레벨 스코프(function level scope)라고 함

```js
var x = 1;
if (true) {
	// var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정
	// 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언 되었다 하더라도
	// 모두 전역 변수!
	// 따라서 x는 전역 변수 이기 때문에 변수 값이 변경되는 부작용 생김
	var x = 10;
}
console.log(x); // 10
```

- 블록 레벨 스코프를 지원하는 프로그래밍 언어에서는
- ┣ `for 문`에서 반복을 위해 선언된 `i 변수`가
- ┣ `for 문의 코드 블록 내`에서만 `유효`한 `지역 변수`
- ┣ for 문 외부에서 사용할 일이 없기 때문
- ┣ 하지만 `var 키워드`로 선언된 변수는 `블록 레벨 X`
- ┗ 중복 선언에 오류가 생김

- `var 키워드`로 선언된 변수는 오로지 `함수 코드 블록`만을
- ┣ `지역 스코프`로 인정하지만
- ┗ `ES6`에서 되입된 `let`, `const`의 경우 `블록 레벨 스코프`를 지원

## 13.5 렉시컬 스코프

- 다음 예제의 실행 결과 예측

```js
var x = 1;
function foo() {
	var x = 10;
	bar();
}
function bar() {
	console.log(x);
}

foo(); // ?
bar(); // ?
```

- 위 예제에서 실행 결과는 bar 함수의
- ┣ 상위 스코프가 무엇인지에 따라 결정됨
- ┗ 두 가지 패턴을 예측 가능

1. 함수를 어디서 호출했는지에 따라서 상위 스코프를 결정
2. 함수를 어디서 정의했는지에 따라 함수의 상위 스코를 결정

- 첫 번째 방식을 `동적 스코프(dynamic scope)`라 함
- ┣ 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없음
- ┣ 함수가 호출되는 시점에 동적으로 상위 스코프를 결정
- ┗ 그래서 동적 스코프라고 부름

- 두 번째 방식을 `렉시컬 스코프(lexical scope)` 또는 `정적 스코프(static)`
- ┣ 라고 부르게 됨
- ┣ 동적 스코프처럼 상위 스코프가 동적으로 변하지 않고
- ┣ `함수 정의가 평가되는 시점`에 `상위 스코프가 정적으로 결정`
- ┣ `정적 스코프`라고 부름
- ┗ `JS`를 비롯한 대부분의 프로그래밍 언어는 `렉시컬 스코프`

- `JS는 렉시컬 스코프`를 따르기 때문에 `함수 정의가 실행`될 때 `정적으로 결정`
- ┣ 함수가 `호출된 위치`는 `상위 스코프 결정에 어떠한 영향도 주지 않음`
- ┗ 함수의 `상위 스코프`는 언제나 `자신이 정의한 스코프`

- ┣ `함수 정의(함수 선언문 또는 표현식)`가 `실행`되어 `생성된 함수 객체`는
- ┣ `결정된 상위 스코프를 기억`하게됨
- ┗ `함수가 호출될 때 마다` 함수의 `상위 스코프를 참조`할 필요가 있기 때문

> 렉시컬 스코프는 클로저와 깊은 관계 이는 뒤에서 학습
