# 42. 비동기 프로그래밍

## 목차

- [42. 비동기 프로그래밍](#42-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
  - [42.1 동기 처리와 비동기 처리](#421-%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC)
  - [42.2 이벤트 루프와 태스크 큐](#422-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%99%80-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90)
    - [브라우저 환경의 setTimeout](#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%ED%99%98%EA%B2%BD%EC%9D%98-settimeout)

## 42.1 동기 처리와 비동기 처리

- 23장 실행컨테스트에서 보았듯
- ┣ 1. `함수를 호출`하면
- ┣ 2. 함수 코드가 `평가`되어
- ┣ 3. `실행 컨텍스트가 생성`됨
- ┣ 4. 생성된 함수 실행 컨테스트 :
- ┣ `실행 컨텍스트 스택(콜 스택)에 푸시되고`
- ┗ 5. `함수 코드가 실행`됨

- 함수 코드 실행 종료 :
- ┣ `실행 컨텍스트 스택에서 팝`
- ┗ `제거됨`

- 다음 예제 foo, bar 함수
- ┣ 호출된 순서대로 스택 자료구조인
- ┣ `실행 컨텍스트 스택에 푸시되어`
- ┗ `실행 됨`

```js
const foo = () => {};
const bar = () => {};

foo();
bar();
```

- 함수가 실행되려면 `함수 코드 평가 과정`에서
- ┣ 생성된 함수 실행 컨텍스트가
- ┣ `실행 컨텍스트 스택에 푸시되어야 함`
- ┣ 다시 말해 : 실행 컨텍스트 스택에
- ┣ 함수 실행 컨텍스트가 푸시되는 것 :
- ┗ `바로 함수 실행을 의미함`

> 함수의 순차적 실행

    함수가 호출된 순서대로
    ┣ 함수 실행 컨텍스트가
    ┣ 실행 컨텍스트 스택에
    ┗ 푸시가 되기 때문임

- JS 엔진 : 단 하나의 실행 컨텍스트를 가짐
- ┣ 이는 동시에 2개 이상의 함수 실행 불가
- ┣ 실행 컨텍스트 스택의 최상위 요소인
- ┣ 실행 중인 실행 컨텍스트를 제외한
- ┣ 모든 실행 컨텍스트 :
- ┣ `실행 대기 중인 테스크임`
- ┣ 1. `현재 실행 중인 실행 컨텍스트가`
- ┣ `팝되어` 2. `실행 컨텍스트 스택에서 제거`되면
- ┗ 3. `비로소 함수가 실행되기 시작함`

- 이처럼 JS 엔진 : 한 번에 하나의 태스크만
- ┣ 실행할 수 있는 `싱글 스레드(single thread)`
- ┣ 방식으로 동작함
- ┣ 싱글 스레드 방식 : 한 번에 하나의 테스크만
- ┣ 실행이 가능하기 때문에 처리에 시간이 걸리는
- ┣ `태스크를 실행하는 경우 블로킹(blocking) 작업중단`
- ┗ `발생함 `

```js
// sleep 함수 : 일정시간이 경과한 이후 콜백 함수 실행
function sleep(func, delay) {
    // Date.now()는 현재 시간을 숫자(ms)로 변환함
    const delayUntil = Date.now() + delay;

    // 현재 시간이 더한 시간보다 작으면
    // 계속 반복함
    while(Date.now() < delayUntil);
    func();
    }
}

function foo() {
    console.log('foo')
}
function bar() {
    console.log('bar')
}

// sleep 함수는 3초 이상 실행됨
sleep(foo, 3 * 1000);

bar();

```

- 이처럼 실행 중인 태스크가
- ┣ 종료할 때까지 다음에 실행될 태스크가
- ┣ 대기하는 방식을 `동기(synchronous) 처리` 라고 함
- ┣ `장점 : 실행 순서 보장`
- ┗ `단점 : 태스크 블로킹`

> 이를 setTimeout를 이용하여 변경

```js
function foo() {
	console.log('foo');
}
function bar() {
	console.log('bar');
}

setTimeout(foo, 3000);

bar();
```

- seTimeout 함수 :
- ┣ `비동기(asynchronous)` 방식으로 동작
- ┗ 태스크를 블로킹하지 않음

- 비동기 처리 처리 수행하는 비동기 함수 :
- ┣ 전통적으로 `콜백 패턴을 사용함`
- ┣ 콜백 패턴 단점 :
- ┣ 1. `콜백 지옥을 발생 시켜 가독성 down`
- ┣ 2. `에러의 예외 처리 곤란`
- ┗ 3. `동시 다발적 비동기 처리`

- `setTimeout, setInterval`
- ┣ `HTTP 요청, 이벤트 핸들러` :
- ┣ 비동기 처리 방식으로 동작
- ┗ `이벤트 루프와 태스크 큐와 깊은 관계`

## 42.2 이벤트 루프와 태스크 큐

- JS의 특징 중 하나는 싱글 스레드로 동작하는 점
- ┣ 앞서 살펴본 바와 같이 싱글 스레드 방식 :
- ┣ `하나의 테스크만 처리할 수 있다는 것을 의미함`
- ┣ 하지만 브라우저가 동작하는 것을 살펴보면
- ┗ `많은 태스크가 동시에 처리되는 것 처럼 느껴짐`

- Ex) HTML 요소가 애니메이션 효과를 통해 움직이면서
- ┣ 이벤트를 처리하기도 하고
- ┣ HTTP 요청을 통해 서버로부터 데이터를 가지고 오면서
- ┣ 렌더링을 진행 하기도 함
- ┣ 이처럼 JS의 `동시성(concurrency)`을 지원하는 것이
- ┗ 바로 `이벤트 루프(event loop)`

- 이벤트 루프 :
- ┣ 브라우저에 내장되어 있는 기능 중 하나임
- ┗ 대부분의 JS 엔진은 크게 2개의 영역으로 구분 가능

1. 콜스택(call stack)

- 23장 실행 컨텍스트에서 보았듯
- ┣ 소스코드(전역 코드나 함수 코드 등) 평과 과정에서
- ┣ 생성된 실행 컨텍스트가 추가되고
- ┣ 제거되는 스택 자료구조인
- ┣ `실행 컨택스트 스택 → 콜 스택임`

- 함수를 호출하면 함수 실행 컨텍스트가
- ┣ `순차적으로 콜 스택에 푸시되어`
- ┣ `순차적으로 실행함`
- ┣ J`S 엔진은 단 하나의 콜 스택을 사용`하기 때문에
- ┣ 최상위 실행 컨텍스트(실행 중인 실행 컨텍스트)가
- ┣ `종료되어 콜 스택에서 제거되기 전까지는 다른`
- ┗ `어떤 태스크도 실행되지 않음`

2. 힙(heap)

- 힙은 객체가 저장되는 메모리 공간임
- ┣ 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된
- ┣ 객체를 참조하게 됨

- 메모리에 값을 저장하기 위해서는 1) 먼저 값을 저장할
- ┣ `메모리 공간의 크기를 결정해야 함`
- ┣ 객체 : 원시 값과는 달리 크기가 정해져 있지 않으므로
- ┣ 할당해야 할 메모리 공간의 크기를
- ┣ `런타입에 결정(동적 할당)해야 함`
- ┣ 따라서 객체가 저장되는 메모리 공간인 힙은
- ┗ `구조화 되어 있지 않다는 것이 특징임`

- 이처럼 콜 스택, 힙으로 구성되어 있는
- ┣ JS 엔진 : 단순히 태스크가 요청되면
- ┣ `콜 스택을 통해 요청된 작업을 순차적으로`
- ┣ `실행할 뿐임`
- ┣ `비동기 처리에서 소스코드의 평과와 실행을`
- ┣ `제외한 모든 처리` : JS 엔진을 구동하는 환경인
- ┗ `브라우저 또는 Node.js 에서 담당함`

- Ex) 비동기 방식으로 동작하는
- ┣ setTimeout 콜백 함수의 평가와 실행은
- ┣ JS 엔진이 담당하지만
- ┣ `호출 스케줄링을 위한 타이머 설정과`
- ┣ `콜백 함수의 등록 : 브라우저, Node.js가 담당함`
- ┣ 이를 위해 브라우저 환경 :
- ┣ 1. `태스크 큐와`
- ┗ 2. `이벤트 루프를 제공함`

1. `태스크 큐(task queue/event queue/callback queue)`

- ┣ setTimeout이나 setInterval 같은 `비동기 함수`의
- ┣ `콜백 함수 또는 이벤트 핸들러가 일시적으로`
- ┣ `보관되는 영역임`
- ┣ 태스크 큐와는 별도로 promise 후속 처리 메서드의
- ┣ `콜백 함수가 일시적으로 보관되는 마이크로태스크`
- ┗ `큐도 존재함`

2. 이벤트 루프(event loop)

- ┣ 이벤트 루프 : 1. `콜 스택에서 실행 중인`
- ┣ `실행 컨텍스트가 있는지`
- ┣ 그리고 2. `태스크 큐에 대기 중인 함수`
- ┣ `(콜백 함수, 이벤트 핸들러 등)가 있는지`
- ┣ `반복해서 확인함`
- ┣ 만약 : `콜 스택이 비어있고 태스크 큐에`
- ┣ `대기 중인 함수가 있다면`
- ┣ 이벤트 루프는 `순차적(FIFO)`으로 테스크 큐에
- ┣ 대기 중인 함수를 콜 스택으로 이동시킴
- ┣ 이때 콜 스택으로 이동한 함수는 실행됨
- ┣ 즉 : `태스크 큐에 일시 보관된 함수들은`
- ┗ `비동기 처리 방식으로 동작함`

### 브라우저 환경의 setTimeout

```js
function foo() {
	console.log('foo');
}
function bar() {
	console.log('bar');
}
setTimeout(foo, 0); // 0초 실제로는 4ms 이후에 foo 함수가 호출됨
bar();
```

1. 전역 코드가 평가되어

- ┣ 전역 실행 컨텍스트가 생성되고
- ┗ 콜 스택에 푸시됨

2. 전역 코드가 실행되기 시작하여

- ┣ setTimeout 함수가 호출됨
- ┣ 이때 setTimeout 함수의
- ┣ 1. `함수 실행 컨텍스트가 생성되고`
- ┣ 2. `콜 스택에 푸시되어 `
- ┣ 3. 현재 `실행중인 실행 컨텍스트가 됨`
- ┣ 브라우저의 Web API(호스트 객체)인 타이머 함수도
- ┗ 함수이므로 → 함수 실행 컨텍스트를 생성함

3. setTimeout 함수가 실행되면 콜백 함수를

- ┣ `함수 스케줄링하고 종료되어 콜 스택에서 팝됨`
- ┣ 이때 `호출 스케줄링` →
- ┣ 즉 : 타이머 설정과 타이머가 만료되면
- ┣ `콜백 함수를 태스크 큐에 푸시하는 것은`
- ┗ `브라우저의 역할임`

4. 브라우저가 수행하는 4-1과

- ┣ JS 엔진이 수행하는 4-2는
- ┗ `병행 처리됨`

4. 1 브라우저는 타이머를 설정하고

- ┣ 타이머의 만료를 기다림
- ┣ 이후 `타이머가 만료되면 콜백 함수 foo가`
- ┣ `태스크 큐에 푸시됨`

- ┣ 위 예제의 경우 지연시간(delay) 0 이지만
- ┣ `지연 시간이 4ms 이하인 경우 최소 지연 시간`
- ┣ `4ms가 지정됨`
- ┣ 따라서 4ms 이후에 콜백 함수 foo가 태스크 큐에
- ┣ 푸시되어 대기하게 됨

- ┣ 이 처리 또한 JS 엔진이 아닌 브라우저가 수행함
- ┣ 이처럼 setTimeout 함수로 호출 스케쥴링한
- ┣ `콜백 함수의 경우 정확히 지연 시간 후에 호출된다는`
- ┣ `보장이 없음`
- ┣ 지연 시간 이후에 `콜백 함수가 태스크 큐에 푸시되어`
- ┣ `대기`하게 되지만 `콜 스택이 비어야 호출되므로`
- ┗ `약간의 시간차가 발생할 수 있기 때문임`

4. 2 bar 함수가 호출되어 bar 함수의

- ┣ 1. `실행 컨텍스트가 생성`되고
- ┣ 2. `콜 스택에 푸시되어 현재 실행 중인`
- ┣ `실행 컨텍스트`가 됨
- ┣ 3. 이후 `bar 함수가 종료되어 콜 스택에서`
- ┣ `팝되게 됨`
- ┣ 이때 브라우저가 타이머를 설정한 후
- ┣ `4ms가 경과했다면 foo 함수는 `
- ┗ `아직 태스크 큐에서 대기 중임`

5. 전역 코드 실행이 종료되고

- ┣ `전역 실행 컨텍스트가 콜 스택에서 팝됨`
- ┣ 이로서 `콜 스택에는 아무런 실행 컨텍스트도`
- ┗ `남아있지 않게 됨`

6. 이벤트 루프에 의해 콜 스택이

- ┣ 비어 있음을 감지하고 태스크 큐에서
- ┣ `대기 중인 콜백 함수 foo가 이벤트 루프에`
- ┣ `의해 콜 스택에 푸시됨`
- ┣ 콜백 함수 1. `foo의 함수 실행 컨텍스트가 생성`되고
- ┣ 2. `콜 스택에 푸시되어 현재 실행중인 실행 컨텍스트`가 됨
- ┗ 3. 이후 `foo 함수가 종료되어 콜 스택에서 팝됨`

- 이처럼 비동기 함수인 setTimeout의
- ┣ 콜백 함수 : `태스크 큐에 푸시`되어
- ┣ 대기하다가 → `콜 스택이 비게 되면`
- ┣ `다시 말해 전역 코드 및 명시적으로`
- ┣ `호출된 함수가 모두 종료되면`
- ┗ `비로소 콜 스택에 푸시되어 실행됨`

- JS : 싱글 스레드 방식으로 동작함
- ┣ 이때 싱글 스레드 방식으로 동작하는 것은
- ┣ 브라우저가 아니면 브라우저에 내장된
- ┣ JS 엔진이라는 것을 유의
- ┣ `만약 모든 JS 코드가 싱글 스레드 방식으로`
- ┣ `동작하게 된다면 JS는 비동기로 동작 불가함`
- ┣ `즉 : JS 엔진은 싱글 스레드`
- ┗ `브라우저 : 멀티 스레드로 동작함`

- 브라우저 : JS 엔진 외에도
- ┣ `렌더링 엔진, Web API`를 제공함
- ┣ `Web API` : E`CMAScript 사양에 정의된게 아닌`
- ┣ `브라우저에서 제공하는 API`이며
- ┣ 1. `DOM API`와 2. `타이머 함수`, 3. `HTTP 요청(Ajax)`
- ┣ 같은 `비동기 처리`를 포함한
- ┣ `브라우저의 Web API인 setTimeout이 호출되면`
- ┗ `JS 엔진의 콜 스택에 푸시되어 실행됨`

- 하지만 setTimeout 함수의 두 가지 기능인
- ┣ 1. `타이머 설정과`
- ┣ 2. `타이머가 만료하면 콜백 함수를`
- ┣ `태스크 큐에 등록하는 처리` :
- ┣ JS 엔진이 아닌 브라우저가 실행함
- ┣ `브라우저가 수행하는 → 4-1`
- ┣ `JS 엔진이 수행하는 → 4-2` : `병행 처리됨`
- ┣ 이처럼 `브라우저와 JS 엔진이 협력`하여
- ┗ `비동기 함수인 setTimeout 함수를 실행함`
