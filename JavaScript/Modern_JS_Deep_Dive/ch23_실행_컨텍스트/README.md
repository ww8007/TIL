# 23. 실행 컨텍스트

- `실행 컨텍스트(execution context)` : JS 동작 원리를 담고 있는 핵심 개념
- ┣ 실행 컨텍스트 바르게 이해 → JS가
- ┣ 1. 식별자와 식별자에 바인딩 값(식별자 바인딩)을 관리하는 방법
- ┣ 2. 호이스팅이 발생하는 이유
- ┣ 3. 클로저의 동작 방식
- ┣ 4. 태스크 큐와 함께 동작하는 이벤트 핸들러
- ┗ 5. 비동기 처리의 동작 방식 이해 가능

## 목차

- [23. 실행 컨텍스트](#23-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8)
  - [소스코드의 타입](#%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C%EC%9D%98-%ED%83%80%EC%9E%85)
  - [23.2 소스코드의 평가와 실행](#232-%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C%EC%9D%98-%ED%8F%89%EA%B0%80%EC%99%80-%EC%8B%A4%ED%96%89)
  - [23.2 실행 컨텍스트의 역할](#232-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%97%AD%ED%95%A0)
    - [1. 전역 코드 평가](#1-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C-%ED%8F%89%EA%B0%80)
    - [2. 전역 코드 실행](#2-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89)
    - [3. 함수 코드 평가](#3-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C-%ED%8F%89%EA%B0%80)
    - [4. 함수 코드 실행](#4-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89)
  - [23.4 실행 컨텍스트 스택](#234-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%83%9D)
    - [1. 전역 코드의 평가와 실행](#1-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C%EC%9D%98-%ED%8F%89%EA%B0%80%EC%99%80-%EC%8B%A4%ED%96%89)
    - [2. foo 함수 코드의 평가와 실행](#2-foo-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C%EC%9D%98-%ED%8F%89%EA%B0%80%EC%99%80-%EC%8B%A4%ED%96%89)
    - [3. bar 함수 코드의 평가와 실행](#3-bar-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C%EC%9D%98-%ED%8F%89%EA%B0%80%EC%99%80-%EC%8B%A4%ED%96%89)
    - [4. foo 함수 코드로 복귀](#4-foo-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%B3%B5%EA%B7%80)
    - [5. 전역 코드로 복귀](#5-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%B3%B5%EA%B7%80)
  - [23.5 렉시컬 환경](#235-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD)
  - [23.6 실행 컨텍스트의 생성과 식별자 검색 과정](#236-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%8B%9D%EB%B3%84%EC%9E%90-%EA%B2%80%EC%83%89-%EA%B3%BC%EC%A0%95)
    - [23.6.1 전역 객체 생성](#2361-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1)
    - [23.6.2 전역 코드 평가](#2362-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C-%ED%8F%89%EA%B0%80)
      - [1. 전역 실행 컨텍스트 생성](#1-%EC%A0%84%EC%97%AD-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%83%9D%EC%84%B1)
      - [2. 전역 렉시컬 환경 생성](#2-%EC%A0%84%EC%97%AD-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD-%EC%83%9D%EC%84%B1)
        - [2.1 전역 환경 레코드 생성](#21-%EC%A0%84%EC%97%AD-%ED%99%98%EA%B2%BD-%EB%A0%88%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1)
          - [객체 환경 레코드 생성](#%EA%B0%9D%EC%B2%B4-%ED%99%98%EA%B2%BD-%EB%A0%88%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1)
          - [2.1.2 선언적 환경 레코드 생성](#212-%EC%84%A0%EC%96%B8%EC%A0%81-%ED%99%98%EA%B2%BD-%EB%A0%88%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1)
          - [2.2 this 바인딩](#22-this-%EB%B0%94%EC%9D%B8%EB%94%A9)
          - [2.3 외부 렉시컬 환경에 대한 참조 결정](#23-%EC%99%B8%EB%B6%80-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B0%B8%EC%A1%B0-%EA%B2%B0%EC%A0%95)
    - [26.6.3 전역 코드 실행](#2663-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89)
    - [23.6.4 foo 함수 코드 평가](#2364-foo-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C-%ED%8F%89%EA%B0%80)
      - [1. 함수 실행 컨텍스트 생성](#1-%ED%95%A8%EC%88%98-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%83%9D%EC%84%B1)
      - [2. 함수 렉시컬 환경 생성](#2-%ED%95%A8%EC%88%98-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD-%EC%83%9D%EC%84%B1)
        - [2.1 함수 환경 레코드 생성](#21-%ED%95%A8%EC%88%98-%ED%99%98%EA%B2%BD-%EB%A0%88%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1)
        - [2.2 this 바인딩](#22-this-%EB%B0%94%EC%9D%B8%EB%94%A9-1)
        - [2.3 외부 렉시컬 환경에 대한 참조 결정](#23-%EC%99%B8%EB%B6%80-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B0%B8%EC%A1%B0-%EA%B2%B0%EC%A0%95-1)
    - [23.6.5 foo 함수 코드 실행](#2365-foo-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89)
    - [26.6.6 bar 함수 코드 평가](#2666-bar-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C-%ED%8F%89%EA%B0%80)
    - [23.6.7 bar 함수 코드 실행](#2367-bar-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89)
      - [1. console 식별자 검색](#1-console-%EC%8B%9D%EB%B3%84%EC%9E%90-%EA%B2%80%EC%83%89)
      - [log 메서드 검색](#log-%EB%A9%94%EC%84%9C%EB%93%9C-%EA%B2%80%EC%83%89)
      - [표현식 a + b + x + y + z 의 평가](#%ED%91%9C%ED%98%84%EC%8B%9D-a--b--x--y--z-%EC%9D%98-%ED%8F%89%EA%B0%80)
      - [console.log 메서드 호출](#consolelog-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%98%B8%EC%B6%9C)
    - [23.6.8 bar 함수 코드 실행 종료](#2368-bar-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89-%EC%A2%85%EB%A3%8C)
    - [23.6.9 foo 함수 코드 실행 종료](#2369-foo-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89-%EC%A2%85%EB%A3%8C)
    - [23.6.10 전역 코드 실행 종료](#23610-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89-%EC%A2%85%EB%A3%8C)
  - [23.7 실행 컨텍스트와 블록 레벨 스코프](#237-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84)

## 소스코드의 타입

- ECMAScript 사양 : 소스코드(ECMAScript code)를 4가지 타입으로 구분
- ┣ 4가지 타입의 소스코드는 실행 컨텍스트를 생성

| 소스코드의 타입          | 설명                                                                                        |
| ------------------------ | ------------------------------------------------------------------------------------------- |
| 전역 코드(global code)   | 전역에 존재하는 소스코드. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함 X                |
| 함수 코드(function code) | 함수 내부에 존재하는 소스코드를 말함. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드 포함 X |
| eval 코드(eval coe)      | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 코드를 말함                         |
| 모듈 코드(module code)   | 모듈 내부에 존재하는 소스코드. 모듈 내부의 함수, 클래스 등의 내부 코드 포함 X               |

- `소스코드(실행 가능한 코드)`를 `4가지 타입으로 구분` 이유 :
- ┣ 소스코드의 타입에 따라 `실행 컨텍스트를 생성하는 과정`과
- ┗ `관리 내용`이 다르기 때문

1. 전역 코드

- `전역 코드` : `전역 변수를 관리`하기 위해 최상위 스코프인 `전역 스코프를 생성`
- ┣ `var 키워드`로 선언된 `전역 변수`, `함수 선언문`으로 정의된 `전역 함수`를
- ┣ `객체의 프로퍼티와 메서드로 바인딩`하고, `참조`하기 위해 `전역 객체와 연결`
- ┗ 이를 위해 `전역 코드가 평가` → `전역 실행 컨텍스트`가 생성

2. 함수 코드

- `함수 코드` : `지역 스코프`를 생성, `지역 변수`, `매개변수`, `arguments 객체를 관리` 해야 함
- ┣ 생성한 지역 스코프 → `전역 스코프에서 시작하는 스코프 체인의 일원`으로 연결
- ┗ 이를 위해 `함수 코드가 실행` → `함수 실행 컨텍스트`가 생성

3. eval 코드

- `eval 코드` : `strict mode`에서 `자신만의 독자적인 스코프`를 생성
- ┗ 이를 위해 `eval 코드 동작` → `eval 실행 컨텍스트`가 생성

4. 모듈 코드

- `모듈 코드`는 `모듈별로 독립적인 모듈 스코프`를 생성
- ┗ 이를 위해 `모듈 코드가 평`가되면 `모듈 실행 컨텍스트 생성`

## 23.2 소스코드의 평가와 실행

- `모든 소스코드` : `실행에 앞서 평가 과정`을 거치며
- ┣ `코드를 실행하기 위한 준비`를 함
- ┣ `JS엔진`은 소스코드를 2개의 과정
- ┣ 1. `소스코드의 평가`
- ┗ 2. `소스코드의 실행` 과정으로 나누어서 처리

- `소스코드 평가` 과정 : 1. `실행 컨텍스트를 생성`
- ┣ 2. 변수, 함수등의 `선언문`만 `먼저 실행` → `생성된 변수`나
- ┣ `함수 식별자`를 `키`로 `실행 컨텍스트가 관리`하는
- ┗ 스코프(`렉시컬 환경 레코드`)에 등록함

- `소스코드 평가 과정 끝`나면
- ┣ 비로소 선언문을 제외한 `소스코드가 순차적으로 실행`
- ┣ 즉 : `런타임`이 `실행`
- ┣ `소스코드 실행`에 `필요한 정보`
- ┣ 즉 : `함수의 참조`를 `실행 컨텍스트가 관리하는 스코프`에서
- ┣ `검색해서 취득`
- ┣ `변수 값의 변경` 등 소스코드의 `실행 결과` → 다시 실행 컨텍스트가
- ┗ `관리하는 스코프에 등록`됨

```js
var x;
x = 1;
```

- 다음과 같은 예제에서 `JS 엔진` :
- ┣ `2개의 과정`으로 나누어 처리
- ┣ 1. `소스코드 평가` 과정 → `변수 선언문` `var x;` 실행
- ┣ 생성된 변수 식별자 x → `실행 컨텍스트가 관리`하는
- ┗ `스코프에 등록` 후 → `undefined로 초기화`

- `소스코드 평가 과정이 끝`나면 → `비로소 소스코드 실행 과정`
- ┣ `변수 선언문` `var x;`는 `소스코드 평가 과정에서 이미 실행 완료`
- ┣ 따라서 → 소스코드 `실행` 과정 → `변수 할당문` `x=1;`만 `실행`
- ┗ `변수에 값을 할당`하려면 `먼저 x 변수가 선언된 변수`인지 `확인`

- 이를 위해 `실행 컨텍스트`가 관리하는 스코프에
- ┣ x 변수가 `등록되어 있는지 확인`
- ┣ 다시 말해 : x 변수가 선언된 변수인지 확인
- ┣ 등록되어 있는 경우 x 변수 : `평가 과정에서 선언문이 실행`되어 등록된 변수
- ┗ x가 선언된 변수라면 : `값을 할당`하고 → `할당 결과를 실행 컨텍스트에 등록, 관리`

> 1. 소스코드 평가 : 선언문 실행 후 스코프 등록
> 2. 소스코드 실행 : 변수 할당문 실행
>    실행 컨텍스트에 등록되어 있는지 확인 후 할당

## 23.2 실행 컨텍스트의 역할

- 다음 예제 : 전역 코드, 함수 코드로 구성
- ┗ JS가 이 예제를 어떻게 평가하고 실행할지 생각

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
	const x = 10;
	const y = 20;

	// 메서드 호출
	console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

### 1. 전역 코드 평가

- 전역 코드 실행에 앞서
- ┣ 먼저 전역 코드 평가 과정을 거치며
- ┣ `전역 코드를 실행`하기 위한 `준비`를 함
- ┣ `소스코드 평가 과정` : `선언문만 먼저 실행`
- ┣ 전역 코드의 `변수 선언문`, `함수 선언문`이 먼저 실행
- ┣ 그 결과 : 생성된 1. `전역 변수`, 2. `전역함수`가
- ┣ `실행 컨턱스트가 관리`하는 → `전역 스코프`에 등록
- ┣ 이때 var 키워드로 선언된 `전역 변수와 함수 선언문`으로
- ┗ 정의된 `전역 함수` : `전역 객체의 프로퍼티와 메서드`가 됨

### 2. 전역 코드 실행

- `전역 코드 평가 과정 끝` →
- ┣ `런타임이 시작`되어 `전역 코드가 순차적으로 실행`
- ┣ `전역 변수에 값이 할당`되고 `함수가 호출`됨
- ┣ `함수가 호출`되면 순차적으로 실행되던
- ┣ 전역 코드의 `실행을 일시 중단`
- ┗ `코드 실행 순서를 변경`하여 `함수 내부로 진입`

### 3. 함수 코드 평가

- 함수 호출에 의해 : `코드 실행 순서가 변경`되어
- ┣ 함수 내부로 진입하면 → 함수 내부의 문들을
- ┣ 실행하기에 앞서 `함수 코드 평가 과정`을 거치며
- ┣ `함수 코드를 실행하기 위한 준비`를 함
- ┗ `매개변수`와 `지역 변수 선언문`이 `먼저 실행`

- 그 결과 : `생성된 매개변수`와 `지역 변수`가
- ┣ `실행 컨텍스트가 관리`하는 `지역 스코프에 등록`
- ┣ 함수 내부에서 `지역 변수처럼 사용할 수 있는`
- ┣ `arguments 객체`가 생성되어
- ┗ `지역 스코프에 등록`, `this 바인딩 결정`

### 4. 함수 코드 실행

- 함수 코드 과정이 끝나면
- ┣ `런타임 시작` → `함수 코드가 순차적으로 실행`됨
- ┣ 이때 `매개변수`와 `지역 변수에 값이 할당`
- ┗ `console.log` `메서드가 호출`

- `console.log` 메서드 호출하기 위해서
- ┣ 먼저 식별자인 console → `스코프 체인을 통해 검색`
- ┣ 이를 위해 함수 코드의 지역 스코프 :
- ┗ `상위 스코프인 전역 스코프와 연결`되어야 함

- ┣ 하지만 console 식별자 :
- ┣ `스코프 체인 등록 X` → `전역 객체 프로퍼티`로 존재
- ┣ 이는 `전역 객체의 프로퍼티가 마치 전역 변수`처럼
- ┗ `전역 스코프를 통해 검색 가능`해야 한다는 것을 의미

- `log 프로퍼티`를 console 객체의 프로토타입 체인을 통해 검색
- ┣ `console.log` 메서드에 인수로 전달된 표현식
- ┣ `a + x + y`가 평가
- ┣ a, x, y 식별자 : 스코프 체인을 통해 검색
- ┣ `console.log` 메서드의 실행이 종료
- ┣ 함수 코드의 실행 과정 종료되고, `함수 호출 이전으로 되돌아가`
- ┗ `전역 코드의 실행을 계속`하게 됨

> 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 관리 필요

1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스)를

   - ┣ 1) `스코프를 구분하여 등록`하고
   - ┣ 2) `상태 변화(식별자에 바인딩된 값의 변화)`를
   - ┗ `지속적으로 관리` 가능해야 함

2. `스코프를 중첩 관계에 의해 스코프 체인`을 형성

   - ┣ 스코프 체인을 통해 → `상위 스코프로 이동`
   - ┗ `식별자를 검색`할 수 있어야 함

3. 현재 실행 중인 코드의 `실행 순서를 변경`
   - ┣ (함수 호출에 의한 실행 순서 변경)
   - ┣ 할 수 있어야 하며
   - ┗ `원상복구도 가능`해야 함

- 이 모든 것을 관리하는 것이 : 실행 컨텍스트

- `실행 컨텍스트` : 소스코드를 실행하는데
- ┣ 1. `필요한 환경을 제공`하고
- ┗ 2. `실행 결과를 실제로 관리`하는 영역

- `구체적으로 실행 컨텍스트` :
- ┣ 1. `식별자(변수, 함수, 클래스)`를 `등록`, `관리`하고
- ┣ 2. `스코프와 코드 실행 순서` 관리를 구현한 `내부 매커니즘`
- ┗ `모든 코드` : `실행 컨텍스트를 통해 실행되고 관리`

- `식별자, 스코프` : `실행 컨텍스트의 렉시컬 환경`으로 관리
- ┗ 코드 `실행 순서` : `실행 컨텍스트 스택`으로 관리

## 23.4 실행 컨텍스트 스택

- 다음 예제

```js
const x = 1;

function foo() {
	const y = 2;

	function bar() {
		const z = 3;
		console.log(x + y + z);
	}
	bar();
}

foo(); // 6
```

- 위 예제 : `소스코드의 타입으로 분류`할 때
- ┣ `전역 코드, 함수 코드`로 이루어져 있음
- ┣ JS엔진 : `먼저 전역 코드를 평가`하여
- ┣ `전역 실행 컨텍스트를 생성`함
- ┣ 함수가 호출되면 `함수 코드를 평가`하여
- ┗ `함수 실행 컨텍스트를 생성`

- 생성된 실행 컨텍스트 : `스택 자료구조로 관리`
- ┣ 이를 → 스택 컨텍스트 스택
- ┣ 코드가 실행되는 시간의 흐름에 따라
- ┗ 실행 컨텍스트에 push, pop 됨

### 1. 전역 코드의 평가와 실행

- `JS엔진` : 먼저 `전역 코드를 평가`하여
- ┣ `전역 실행 컨텍스트를 생성`하고
- ┣ 실행 컨텍스트 스택에 푸시함
- ┣ 전역 변수 x, `전역 함수 foo는 전역 실행 컨텍스트에 등록`
- ┣ `전역 코드가 실행되기 시작`하여
- ┗ 전역 변수 x에 `값이 할당`, `전역 함수` foo가 `호출`

### 2. foo 함수 코드의 평가와 실행

- `전역 함수 foo가 호출` → 전역 코드의 `실행은 일시 중단`
- ┣ `코드의 제어권`이 : `foo 함수 내부로 이동`하게 됨
- ┣ `JS엔진` : `foo 함수 내부의 코드를 평가`하여 →
- ┣ 1. `foo 함수 실행 컨텍스트를 생성`
- ┣ 2. `실행 컨텍스트 스택에 푸시`
- ┣ foo 함수의 지역 변수 y와 중첩 함수 bar가
- ┣ foo 함수 실행 컨텍스트에 등록됨
- ┗ 이후 foo 함수 코드가 실행되기 시작하며 지역 변수 y 할당, 중첩함수 호출

### 3. bar 함수 코드의 평가와 실행

- 중첩 함수 `bar가 호출되면 foo 함수 코드의 실행`은
- ┣ 일시 중단되고, 코드의 제어권이 bar 함수 내부로 이동함
- ┣ `JS엔진` : `bar 함수 내부의 함수 코드를 평가`하여
- ┣ `bar 함수 실행 컨텍스트를 생성`하고
- ┣ `실행 컨텍스트 스택에 푸시`
- ┣ `bar 함수의 지역 변수` z : `bar 함수 실행 컨텍스트`에 등록
- ┣ bar 함수 코드가 실행되기 시작하여
- ┣ 지역 변수 z에 값이 할당, console.log 메서드를 호출한 이후
- ┗ bar 함수는 종료

### 4. foo 함수 코드로 복귀

- bar 함수가 종료되면
- ┣ 코드의 제어권 : 다시 foo 함수로 이동
- ┣ 이때 : JS엔진 → bar 함수 실행 컨텍스트를
- ┣ 실행 컨텍스트 스택에서 팝하여 제거함
- ┗ 결국 foo 함수 더 이상 실행할 코드가 없어서 종료

### 5. 전역 코드로 복귀

- foo 함수가 종료되면
- ┣ 코드의 제어권 : 다시 전역 코드로 이동하게 됨
- ┣ JS 엔진 : foo 함수 실행 컨텍스트 팝하여 제거
- ┗ 결국 실행 컨텍스트 스택에는 아무것도 남아있지 않게됨

## 23.5 렉시컬 환경

- `렉시컬 환경(Lexical Environment)` :
- ┣ 1. `식별자`와 2. `식별자에 바인딩된 값`
- ┣ 그리고 3. `상위 스코프에 대한 참조를 기록하는 자료구조`
- ┣ 실행 컨텍스트를 구성하는 컴포넌트임
- ┣ 실행 컨텍스트 스택 : 코드의 실행 순서를 관리한다면
- ┗ 렉시컬 환경 : 스코프와 식별자를 관리

- `렉시컬 환경` : `키와 값을 갖는 객체 형태의 스코프`
- ┣ (전역, 함수, 블록 스코프)를 생성하여
- ┣ `식별자 → 키로 등록`하고
- ┣ `식별자에 바인딩된 값을 관리`
- ┣ 즉 : 렉시컬 환경은 스코프를 구분하여
- ┗ 식별자를 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체

- 실행 컨텍스트 :
- ┣ 1. `LexicalEnvironment 컴포넌트`
- ┗ 2. `VariableEnvironment 컴포넌트`로 구성됨

- 생성 초기 :
- ┣ `LexicalEnvironment 컴포넌트와 `
- ┣ `VariableEnvironment 컴포넌트`는
- ┗ 하나의 `동일한 렉시컬 환경을 참조`

- `strict mode`, `eval`, `try/catch`문을 `제외`하고
- ┗ 구분하지 않고 같은 렉시컬 환경으로 간략하게 생각하여 설명

1. `환경 레코드(Environment Record)`

- 스코프에 포함된 `식별자를 등록`하고
- ┣ `등록된 식별자에 바인딩된 값을 관리하는 저장소`
- ┣ 환경 레코드 : 소스코드의 타입에 따라
- ┗ 관리하는 내용의 차이가 있음

2. `외부 렉시컬 환경에 대한 참조 (Outer Lexical Environment Reference)`

- 외부 렉시컬 환경에 대한 참조 : 상위 스코프를 가리킴
- ┣ `상위 스코프` : `외부 렉시컬 환경`
- ┣ 실`행 컨텍스트를 생성한 소스코드를 포함`하는
- ┣ 상위 코드의 렉시컬 환경을 말함
- ┣ 외부 렉시컬 환경에 대한 참조를 통해
- ┗ `단방향 링크드 리스트인` → `스코프 체인을 구성`함

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

- 다음 예제를 통해 실행 컨텍스트가 생성되고
- ┣ 코드 실행 결과가 관리되는지
- ┗ 어떻게 실행 컨텍스트를 통해 식별자를 검색하는지 학습

```js
var x = 1;
const y = 2;

function foo(a) {
	var x = 3;
	const y = 4;

	function bar(b) {
		const z = 5;
		console.log(a + b + x + y + z);
	}
	bar(10);
}
foo(20); // 42
```

### 23.6.1 전역 객체 생성

- `전역 객체` : 전역 코드가 `평가되기 이전에 생성`
- ┣ `전역 객체`에는 1. `빌트인 전역 프로퍼티`와
- ┣ 2. `전역함수`, 3. `표준 빌트인 객체가 추가`되어
- ┗ 동작환경에 따라 → 클라이언트 사이드, 호스트 객체를 포함

- 전역 객체도 Object.prototype을 상속받음

> 즉 : 전역 객체도 프로토타입 체인의 일원

```js
// Object.prototype.toString
window.toString(); // [object Window]

window.__proto__.__proto__.__proto__.__proto__ === Object.prototype;
```

### 23.6.2 전역 코드 평가

- 소스코드가 로드되면 `JS 엔진` : `전역 코드를 평가함`
- ┗ 전역 코드 평가는 다음과 같은 순서로 진행

1. 전역 실행 컨텍스트 생성

2. 전역 렉시컬 환경 생성
   - 2.1 전역 환경 레코드 생성
     - 2.1.1 객체 환경 레코드 생성
     - 2.1.2 선언적 환경 레코드 생성
   - 2.2 this 바인딩
   - 2.3 외부 렉시컬 환경에 대한 참조 결정

#### 1. 전역 실행 컨텍스트 생성

- `먼저 비어있는 전역 실행 컨텍스트를 생성`하여
- ┣ `실행 컨텍스트 스택에 푸시`함
- ┣ 이때 전역 실행 컨텍스트 :
- ┣ 실행 컨텍스트 스택의 최상위 → 실행 중인 컨텍스트
- ┗ `(running execution context)`가 됨

#### 2. 전역 렉시컬 환경 생성

- 전역 렉시컬 환경을 생성하고
- ┗ 전역 실행 컨텍스트에 바인딩

> 23.5에서 보았듯 렉시컬 환경은 2개의 컴포넌트
>
> 1. 환경 레코드
> 2. 외부 렉시컬 환경에 대한 참조로 구성

##### 2.1 전역 환경 레코드 생성

- `전역 렉시컬 환경을 구성하는 컴포넌트`인
- ┣ `전역 환경 레코드(Global Environment Record)`는
- ┣ `전역 변수를 관리`하는
- ┣ 1. `전역 스코프`, 2. `전역 객체의 빌트인 전역 프로퍼티`,
- ┗ 3. `빌트인 전역 함수`, 4. `표준 빌트인 객체`를 제공

- 모든 전역 변수가 전역 객체의 프로퍼티가 되는 `ES6 이전`
- ┣ `전역 객체`가 → `전역 환경 레코드의 역할을 수행`
- ┣ 하지만 : `ES6 이후` `let`, `const` 키워드로 선언한 `전역 변수`
- ┣ 전역 객체의 프로퍼티가 되는 것이 아닌
- ┗ `개념적인 블록 내에 존재`하게 됨

- 이처럼 기존의 `var 키워드로 선언한 전역 변수`와
- ┣ `ES6`의 `let, const 키워드`로 선언한 `전역 변수를 구분하여 관리`하기 위해
- ┣ 전역 스코프 역할을 하는 전역 환경 레코드는
- ┣ 1. 객체 환경 레코드(Object Environment Record)
- ┗ 2. 선언적 환경 레코드(Declarative Environment Record)로 구성

- 객체 환경 레코드 : 기존의 전역 객체가 관리하던
- ┣ var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한
- ┣ 1. 전역 함수, 2. 블트인 전역 프로퍼티, 3. 빌트인 전역 함수
- ┗ 4. 표준 빌트인 객체를 관리

- `선언적 환경 레코드` : `let`, `const` `키워드로 선언한 전역 변수를 관리`
- ┣ 전역 환경 레코드의 객체 환경 레코드와 선언적 환경
- ┣ 서로 협력하여 전역 스코프, 전역 객체(전역 변수의 전역 객체 프로퍼티)
- ┗ 관리하게 됨

###### 객체 환경 레코드 생성

- `젼역 환경 레코드를 구성하는 컴포넌트`인
- ┣ 객체 환경 레코드 : `BindingObject`라고 부르는 객체와 연결됨
- ┗ `BindingObject` : 전역 객체 생성에서 생성된 전역 객체

- 전역 코드 평가 과정 : var 키워드로 선언한 전역 변수와,
- ┣ 함수 선언문으로 정의된 → 전역 함수
- ┣ 전역 환경 레코드의 객체 환경 레코드에 연결된
- ┣ BindingObject를 통해 전역 객체의 프로퍼티와, 메서드가 됨
- ┣ 이때 : 등록된 식별자를 전역 환경 레코드의 객체 환경 레코드에서
- ┗ 검색하면 전역 객체의 프로퍼티를 검색하여 반환

- 이것이 `var 키워드로 선언된` → `전역 변수`
- ┣ `함수 선언문으로 정의`된 → `전역 함수`가
- ┣ `전역 객체`의 `프로퍼티`와 `메서드`가 되고
- ┣ `전역 객체`를 → `가리키는 식별자(window) 없이`
- ┣ 전역 객체의 `프로퍼티를 참조`
- ┣ ex) window.alert을 alert 없이 참조
- ┗ 할 수 있게 되는 `메커니즘`

- 위 예제의 `전역 변수 x`, `전역 함수 : foo`
- ┣ `객체 환경 레코드`를 통해
- ┣ 객체 환경 레코드의 `BindingObject에 바인딩`되어 있는
- ┗ `전역 객체의 프로퍼티와 메서드`가 됨

```js
var x = 1;
const y = 2;

function foo(a) {}
```

- `x 변수` : `var 키워드`로 선언한 변수
- ┣ 1. `선언 단계`와, 2. `초기화 단계` 동시에 진행
- ┣ 1. `전역 코드 평가 시점` → `객체 환경 레코드에 바인딩`된
- ┣ `BindingObject`를 통해 `전역 객체에 변수 식별자 키` 등록
- ┗ 2. 암묵적으로 `undefined 바인딩`

- 딸라서 `var 키워드로 선언한 변수` : `코드 실행 단계`에서
- ┣ 변수 선언문 이전에도 참조가 가능
- ┣ 변수 선언문 이전에 참조한 변수의 값 :
- ┣ `언제나 undefined`임
- ┣ var 키워드로 선언한 변수에 할당한 `함수 표현식`도
- ┗ `동일하게 동작`

- 함수 선언문으로 정의한 함수가 평가 →
- ┣ 함수 이름과 동일한 이름의 식별자를
- ┣ 객체 환경 레코드에 바인딩된 BindingObject를 통해
- ┣ 전역 객체에 → 키를 등록 후 생성된 함수 객체를 즉시 할당
- ┗ 이것이 변수 호이스팅 <-> 함수 호이스팅의 차이

> 함수 선언문으로 정의 함수 : 함수 선언문 이전 호출 가능

###### 2.1.2 선언적 환경 레코드 생성

- var 키워드로 선언한 전역 변수와
- ┣ 함수 선언문으로 정의한 전역 함수 이외의 선언
- ┣ 즉 : `let`, `const`로 선언한 `전역 변수` :
- ┗ `선언적 환경 레코드`에 등록되고 관리

> 개념적 블록 : 전역 환경 레코드의 선언적 환경 레코드

- `let`, `const`의 경우 `전역 객체의 프로퍼티가 되지 않음`
- ┣ 당연하게 window로 접근 불가
- ┣ `const 선언` → `선언 단계`, `초기화 단계` `분리`되어 진행
- ┣ `초기화 단계` → `런타임에 실행 흐름이 변수 선언문에 도달하기 전`
- ┣ `일시적 사각지대(Temporal Dead Zone; TDZ)`

- y 변수에 바인딩 되어 있는 `<uninitialized>`는 초기화 단계에
- ┗ 진행되지 않아 → 변수에 접근 불가를 나타냄

- `let`, `const` 키워드 또한 변수 호이스팅이 발생하는 것은
- ┣ `변함이 없음`
- ┣ 단, let const 키워드 선언 변수 : `런타임`에 컨트롤이
- ┣ `변수 선언문에 도달하기 전`까지 `일시적인 사각지대`
- ┗ `참조가 불가`능하다.

```js
let foo = 1; // 전역 변수

{
	// let, const 키워드로 선언한 변수가
	// 호이스팅되지 않는다면 전역 변수를 참조해야함
	// 하지만 let 키워드로 선언한 변수도 여전히 호이스팅 발생
	// 참조 에러가 발생하게 됨
	console.log(foo); // ReferenceError
	let foo = 2; // 지역 변수
}
```

###### 2.2 this 바인딩

- 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에
- ┣ this가 바인딩됨
- ┣ 일반적으로 전역 코드 this → 전역 객체를 가리킴
- ┣ 전역 코드에서 this를 참조하면 전역 환경 레코드의
- ┣ `[[GlobalThisValue]]` `내부 슬롯에 바인딩`되어 있는
- ┗ `객체가 반환`됨

- `전역 환경 레코드를 구성`하는 :
- ┣ 1. `객체 환경 레코드`와
- ┣ 2. `선언적 환경 레코드`에는
- ┗ `this 바인딩이 없음`

- `this 바인딩` : 1. `전역 환경 레코드`와
- ┗ 2. `함수 환경 레코드`에만 존재

###### 2.3 외부 렉시컬 환경에 대한 참조 결정

- `외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)`
- ┣ `현재 평가 중인 소스코드를 포함`하는 `외부 소스코드의 렉시컬 환경`
- ┣ 즉 : `상위 스코프`를 가리킴
- ┗ 이를 통해 `단방향 링크드 리스트`인 : `스코프 체인을 구현`

- 현재 평가중인 소스코드 : `전역 코드`
- ┣ `전역 코드를 포함하는 소스코드는 없음`
- ┣ 전역 렉시컬 환경의` 외부 렉시컬 환경에 대한`
- ┣ `참조에 null이 할당`
- ┗ 전역 렉시컬 환경이 `스코프 체인의 종점에 존재`함 의미

### 26.6.3 전역 코드 실행

- 이제 `전역 코드가 순차적으로 실행`되기 시작
- ┣ `변수 할당문 실행` → 전역 변수 x,y에 값이 할당
- ┗ 그리고 `foo 함수가 호출`

- 변수 할당문 또는 함수 호출문을 실행하려면
- ┣ 먼저 변수 또는 함수 이름이 선언된 식별자인지 확인
- ┗ 선언되지 않은 식별자 : 참조 X → 참조나 호출도 불가

- 식별자 : 스코프가 다르면 같은 이름을 가질 수 잇음
- ┣ 동일한 이름의 식별자가 다른 스코프에 여거래 존재 가능
- ┣ 어느 스코프의 식별자를 참조하면 되는지 결정할 필요 있음
- ┗ 이를 : `식별자 결정(identifier resolution)`

- `식별자 결정을 위한 식별자를 검색` :
- ┣ 실행중인 `실행 컨텍스트에서 식별자를 검색`하기 시작함
- ┣ `선언된 식별자` : `실행 컨텍스트의 렉시컬 환경` →
- ┗ `환경 레코드에 등록`되어 있음

- `현재 실행 중인 실행 컨텍스트` : 전역 실행 컨텍스트
- ┣ `전역 렉시컬 환경`에서 `식별자` x, y,foo를 `검색 시작`
- ┣ 만약 실`행 중인 실행 컨텍스트의 렉시컬 환경`에서
- ┣ `식별자를 검색할 수 없는 경우`
- ┣ `외부 렉시컬 환경`에 대한 참조가 가리키는 →
- ┗ 렉시컬 환경, 즉 : `상위 스코프로 이동하여 식별자 검색`

> 이것이 스코프 체인의 동작 원리

- `전역 렉시컬 환경` : `스코프 체인의 종점`
- ┣ `전역 렉시컬 환경에서 검색할 수 없는 식별자`는
- ┣ 참조 에러(ReferenceError)를 발생
- ┗ 식별자 결정에 실패했기 때문

> 실행 컨텍스트 : 소스코드를 실행하기 위해 필요한 환경을 제공
> 코드의 실행 결과를 실제로 관리하는 영역

### 23.6.4 foo 함수 코드 평가

- 예제 코드
- ┣ 현재 코드 평가를 통해 전역 실행 컨텍스트가 생성
- ┣ 전역 코드를 실행중
- ┗ 현재 진행 상황 : foo 함수 호출 전

```js
var x = 1;
const y = 2;

function foo(a) {
	var x = 3;
	const y = 4;

	function bar(b) {
		const z = 5;
		console.log(a + b + x + y + z);
	}
	bar(10);
}

foo(20); // 호출 직전
```

- `foo 함수가 호출`되면 : 전역 코드의 실행을 `일시 중단`
- ┣ `foo 함수 내부`로 코드의 `제어권이 이동`
- ┣ 함수 코드를 `평가하기 시작`
- ┗ 함수 코드 평가는 다음과 같은 `순서`로 진행

1. 함수 실행 컨텍스트 생성

2. 함수 렉시컬 환경 생성
   - 2.1 함수 환경 레코드 생성
   - 2.2 this 바인딩
   - 2.3 외부 렉시컬 환경에 대한 참조 결정

#### 1. 함수 실행 컨텍스트 생성

- 먼저 foo 함수 `실행 컨텍스트를 생성`
- ┣ `생성된 컨텍스트` : 함수 렉시컬 환경이 완성된 다음
- ┣ `실행 컨텍스트 스택에 푸시`
- ┣ 이때 foo 함수 실행 컨텍스트 : 실행 컨텍스트 스태의
- ┗ 최상위 → `실행 중인 실행 컨텍스트(running execution context)`

#### 2. 함수 렉시컬 환경 생성

- foo 함수 `렉시컬 환경(Function Lexical Environment)`을 `생성`하고
- ┗ foo 함수 `실행 컨텍스트에 바인딩`

- 렉시컬 환경 : 환경 레코드, 외부 렉시컬 환경에 대한 참조로 구성

##### 2.1 함수 환경 레코드 생성

- 함수 렉시컬 환경 구성의 함수 환경 레코드 :
- ┣ 1. `매개변수`, 2. `arguments 객체`, 3. `함수 내부에서 선언한 지역 변수`
- ┗ 4. `중첩 함수를 등록하고 관리`하게됨

##### 2.2 this 바인딩

- 함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에 this 바인딩
- ┣ `[[ThisValue]] 내부 슬롯에 바인딩될 객체`는
- ┗ 함수 호출 방식에 따라 결정됨

- foo 함수 : 일반 함수로 호출되었으므로 this : 전역 객체를 가리킴
- ┣ 함수 환경 레코드 `[[ThisValue]]` 내부 슬롯 → `전역 객체 바인딩`
- ┣ foo 함수 내부에서 this를 참조하면 함수 환경 `[[ThisValue]]`
- ┗ `내부 슬롯에 바인딩되어 있는 객체가 반환`

##### 2.3 외부 렉시컬 환경에 대한 참조 결정

- `외부 렉시컬 환경`에 대한 참조에 `foo 함수 정의가 평가된 시점`
- ┣ 실행 중인 `실행 컨텍스트의 렉시컬 환경`의 참조가 할당
- ┣ `foo 함수` : `전역 코드에 정의`된 `전역 함수`
- ┣ foo 함수 `정의` : `전역 코드 평가 시점`에 `평가`
- ┣ 이 시점의 `실행 중인 실행 컨텍스트` : `전역 실행 컨텍스트`
- ┗ `외부 렉시컬 환경`에 대한 `참조` → `전역 렉시컬 환경의 참조`가 할당

- 렉시컬 스코프에서 JS : 함수를 어디서 호출했는지 x
- ┣ 어디에 정의했는지에 따라 상위 스코프를 결정
- ┣ 또한 함수 객체 → 자신이 정의된 스코프
- ┗ 즉 : 상위 스코프를 기억함

- JS 엔진 : `함수 정의를 평가`하여
- ┣ `함수 객체를 생성`할 때 `현재 실행중인 실행 컨텍스트`의
- ┣ `렉시컬 환경` → 즉 : `상위 스코프를 함수 객체의 내부 슬롯`
- ┣ `[[Environment]]`에 저장하게 됨
- ┣ 함수 `렉시컬 환경의 외부 렉시컬 환경`에 대한 `참조에 할당`
- ┣ 함수의 `상위 스코프를 가리키는` `함수 객체의 내부 슬롯`
- ┣ `[[Environment]]`에 저장된 렉시컬 환경의 참조

> 즉 : 함수 객체의 내부 슬롯 [[Environment]] :
> 렉시컬 스코프를 구현하는 매커니즘
> 이는 클로저를 이해하는 중요한 단서

### 23.6.5 foo 함수 코드 실행

- 런타임이 시작되어 foo 함수의 소스코드가 순차적으로 실행
- ┣ 1. 매개변수에 인수가 할당되고, 2. 변수 할당문이 실행 →
- ┣ 지역 변수에 값이 할당
- ┗ 3. 함수 호출

- 이때 `식별자 결정을 위해` 실행 중인 `실행 컨텍스트`의
- ┣ `렉시컬 환경`에서 `식별자를 검색`하기 시작
- ┣ 현재 `실행 중인 실행 컨텍스트` : foo 함수 실행 컨텍스트
- ┗ foo 함수 `렉시컬 환경`에서 식별자 x,y를 검색하기 시작

- 만약 실행 컨텍스트에서 찾을 수 없으면
- ┣ `외부 렉시컬 환경에 대한 참조`가 가리키는
- ┣ `렉시컬 환경으로 이동`하여 `식별자를 검색`
- ┗ 검색된 식별자에 `값을 바인딩`

### 26.6.6 bar 함수 코드 평가

- 현재 foo 함수 코드 평가를 통해 → foo 함수 실행 컨텍스트 생성
- ┣ foo 함수 코드를 실행하고 있음
- ┗ 현재 : bar 함수를 호출하기 직전

```js
var x = 1;
const y = 2;

function foo(a) {
	var x = 3;
	const y = 4;

	function bar(b) {
		const z = 5;
		console.log(a + b + x + y + z);
	}
	bar(10); // 호출 직전
}
foo(20);
```

- `bar 함수가 호출`되면 → `bar 함수 내부`로 `코드의 제어권이 이동`
- ┣ `bar 함수 코드를 평가하기 시작`함
- ┣ `실행 컨텍스트`와 `렉시컬 환경의 생성 과정` :
- ┗ `foo 함수 코드 평가와 동일`

### 23.6.7 bar 함수 코드 실행

- 런타임 시작 → bar 함수의 소스코드가 순차적으로 실행
- ┣ 1. `매개변수` : `인수 할당`
- ┣ 2. `변수 할당문`이 실행 : `지역 변수` z에 `값이 할당`
- ┗ 3. `console.log(a + b + x + y + z);` 가 실행

> 코드의 실행 순서

#### 1. console 식별자 검색

- 먼저 console 식별자 → `스코프 체인`에서 검색
- ┣ `스코프 체인` : `현재 실행 중`인 실행 컨텍스트의
- ┣ `렉시컬 환경`에서 `시작`하여 `외부 렉시컬 환경에 대한 참조`로
- ┣ 이어지게되는 `렉시컬 환경의 연속`
- ┗ 식별자를 검색 : `언제나 실행 중인` `실행 컨텍스트의 렉시컬 환경` 검색

- 실행 중 실행 컨텍스트 : `bar 함수 실행 컨텍스트`
- ┣ 따라서 : bar 함수 실행 컨텍스트의
- ┣ bar 함수 렉시컬 환경에서 console 식별자 검색 → 하지만 없음
- ┣ 고로 `상위 스코프` → 즉 : `외부 렉시컬 환경에 대한 참조`가 가리키는
- ┗ `foo 함수 렉시컬 환경`에서 검색

- 이곳에도 없기 때문에 `전역 렉시컬 환경으로 이동`하여 식별자 검색

> 전역 렉시컬 환경

    객체 환경 레코드, 선언적 환경 레코드
    ┣ console 식별자 : 객체 환경 레코드
    ┣ BindingObject를 통해 전역 객체에서
    ┗ 찾을 수 있게 됨

#### log 메서드 검색

- `console 식별자에 바인딩`된 객체
- ┣ 즉 : console 객체에서 `log 메서드를 검색`
- ┣ `console 객체`의 `프로토타입 체인`을 통해
- ┣ `메서드를 검색`
- ┣ `log 메서드` : `상속된 프로퍼티가 아닌`
- ┗ console 객체가 `직접 소유하는 프로퍼티`

```js
console.hasOwnProperty('log'); // true
```

#### 표현식 a + b + x + y + z 의 평가

- 이제 `식별자를 검색`하게 됨
- ┣ `식별자` : `스코프 체인`
- ┣ 즉 : `현재 실행 중인 실행 컨텍스트`의
- ┣ `렉시컬 환경에서 시작`하여 → `외부 렉시컬 환경에 대한 참조`
- ┗ `렉시컬 환경의 연속`에서 검색

- a : foo 함수 렉시컬 환경
- b : bar 함수 렉시컬 환경

#### console.log 메서드 호출

- `표현식`이 `평가`되어 생성한 값 42를
- ┗ `console.log 메서드`에 `전달`하여 `호출`

### 23.6.8 bar 함수 코드 실행 종료

- `console.log 메서드가 호출되고 종료`하면
- ┣ 더는 `실행할 코드가 없으므로 bar 함수 코드의 실행이 종료`
- ┣ 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 팝되어 제거
- ┗ foo 실행 컨텍스트가 실행 중인 실행 컨텍스트가 됨

- `실행 컨텍스트 스택`에서 `bar 함수 실행 컨텍스트가 제거` 되었다고 해서
- ┣ `bar 함수 렉시컬 환경`까지 `즉시 소멸하는 것은 아님`
- ┣ `렉시컬 환경`은 `실행 컨텍스트에 의해 참조`되기는 하지만 `독립적인 객체`
- ┣ `객체를 포함한 모든 값` : 누군가에 의해 참조되지 않았을 때
- ┗ 비로소 가비지 컬렉터에 의해 메모리 공간의 확보가 해제되어 소멸

> bar 함수 실행 컨텍스트가 소멸되었다 하더라도
> bar 함수 렉시컬 환경을 누군가 참조하고 있다면
> bar 함수 렉시컬 환경은 소멸하지 않음

### 23.6.9 foo 함수 코드 실행 종료

- `bar 함수가 종료`하면 더 이상 실행할 코드가 없으므로
- ┣ `foo 함수 코드의 실행이 종료`됨
- ┣ 이때 `실행 컨텍스트 스택`에서 foo 함수 `실행 컨텍스트가 팝되어 제거`
- ┗ `실행 컨텍스트가` `실행 중인 실행 컨텍스트가 됨`

### 23.6.10 전역 코드 실행 종료

- `foo 함수가 종료`되면 더는 `실행할 전역 코드가 없으므로`
- ┣ `전역 코드의 실행이 종료`되고 `전역 실행 컨텍스트`도
- ┣ 실행 컨텍스트 스택에서 팝되어 실행 컨텍스트 스택에는
- ┗ 아무것도 남아있지 않게됨

## 23.7 실행 컨텍스트와 블록 레벨 스코프

- `var 키워드로 선언한 변수` : 오로지 `함수의 코드 블록만`
- ┣ 지역 스코프로 인정하는 `함수 레벨 스코프`를 따름
- ┣ 하지만 `let`, `const`로 선언한 변수 : `모든 코드 블록`
- ┣ (`함수`, `if`, `for`, `while`, `try/catch`)을 `지역 스코프로 인정`하는
- ┗ `블록 레벨 스코프`를 따름

```js
let x = 1;

if (true) {
	let x = 10;
	console.log(x); // 10
}

console.log(x); // 1
```

- `if 문의 코드 블록 내`에서
- ┣ `let 키워드로 변수`가 선언
- ┣ 따라서 : `if 문의 코드 블럭이 실행` →
- ┣ if 문의 코드 블록을 위한 `블록 레벨 스코프`를 생성
- ┣ 이를 위해 `선언적 환경 레코드를 갖는 렉시컬 환경`
- ┣ 새롭게 생성하여 `기존의 전역 렉시컬 환경을 교체`
- ┣ 새롭게 생성한 if 문의 코드 블록을 위한 렉시컬 환경의
- ┣ 외부 렉시컬 환경에 대한 참조는 `if문이 실행되기 이전의 전역`
- ┗ `렉시컬 환경`을 가리키게됨

> if 문 코드 블록의 실행이 종료되면 if 문의 코드 블록이 실행되기
> 이전의 렉시컬 환경으로 되돌림

- 이는 if 문 뿐만 아닌 블록 레벨 스코프를 생성하는 모든 블록문 적용

- `for문의 변수 선언문`에 `let 키워드를 사용`한
- ┣ `for 문은 코드 블록이 반복해서 실행`될 때마다
- ┣ 코드 블록을 위한 `새로운 렉시컬 환경을 생성`
- ┣ 만약 `for문의 코드 블록 내에서 정의된 함수`가 있다면
- ┗ 이 `함수의 상위 스코프` → `for 문의 코드 블록`이 생성한 `렉시컬 환경`임

- 이때 `함수의 상위 스코프` : `for 문의 코드 블록이 반복`해서 `실행`
- ┣ 할 때마다 `식별자`(for 문의 변수 선언문 및 for 문의 코드 블록 내에서)
- ┣ 선언된 지역 변수)등의 `값을 유지`해야 함
- ┣ 이를 위해 `for 문의 코드 블록이 반복`해서 `실행`될 때마다
- ┗ `독립적인 렉시컬 환경을 생성`하여 `식별자의 값을 유지`
