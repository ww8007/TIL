# 23. 실행 컨텍스트

- `실행 컨텍스트(execution context)` : JS 동작 원리를 담고 있는 핵심 개념
- ┣ 실행 컨텍스트 바르게 이해 → JS가
- ┣ 1. 식별자와 식별자에 바인딩 값(식별자 바인딩)을 관리하는 방법
- ┣ 2. 호이스팅이 발생하는 이유
- ┣ 3. 클로저의 동작 방식
- ┣ 4. 태스크 큐와 함께 동작하는 이벤트 핸들러
- ┗ 5. 비동기 처리의 동작 방식 이해 가능

## 소스코드의 타입

- ECMAScript 사양 : 소스코드(ECMAScript code)를 4가지 타입으로 구분
- ┣ 4가지 타입의 소스코드는 실행 컨텍스트를 생성

| 소스코드의 타입          | 설명                                                                                        |
| ------------------------ | ------------------------------------------------------------------------------------------- |
| 전역 코드(global code)   | 전역에 존재하는 소스코드. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함 X                |
| 함수 코드(function code) | 함수 내부에 존재하는 소스코드를 말함. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드 포함 X |
| eval 코드(eval coe)      | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 코드를 말함                         |
| 모듈 코드(module code)   | 모듈 내부에 존재하는 소스코드. 모듈 내부의 함수, 클래스 등의 내부 코드 포함 X               |

- `소스코드(실행 가능한 코드)`를 `4가지 타입으로 구분` 이유 :
- ┣ 소스코드의 타입에 따라 `실행 컨텍스트를 생성하는 과정`과
- ┗ `관리 내용`이 다르기 때문

1. 전역 코드

- `전역 코드` : `전역 변수를 관리`하기 위해 최상위 스코프인 `전역 스코프를 생성`
- ┣ `var 키워드`로 선언된 `전역 변수`, `함수 선언문`으로 정의된 `전역 함수`를
- ┣ `객체의 프로퍼티와 메서드로 바인딩`하고, `참조`하기 위해 `전역 객체와 연결`
- ┗ 이를 위해 `전역 코드가 평가` → `전역 실행 컨텍스트`가 생성

2. 함수 코드

- `함수 코드` : `지역 스코프`를 생성, `지역 변수`, `매개변수`, `arguments 객체를 관리` 해야 함
- ┣ 생성한 지역 스코프 → `전역 스코프에서 시작하는 스코프 체인의 일원`으로 연결
- ┗ 이를 위해 `함수 코드가 실행` → `함수 실행 컨텍스트`가 생성

3. eval 코드

- `eval 코드` : `strict mode`에서 `자신만의 독자적인 스코프`를 생성
- ┗ 이를 위해 `eval 코드 동작` → `eval 실행 컨텍스트`가 생성

4. 모듈 코드

- `모듈 코드`는 `모듈별로 독립적인 모듈 스코프`를 생성
- ┗ 이를 위해 `모듈 코드가 평`가되면 `모듈 실행 컨텍스트 생성`

## 23.2 소스코드의 평가와 실행

- `모든 소스코드` : `실행에 앞서 평가 과정`을 거치며
- ┣ `코드를 실행하기 위한 준비`를 함
- ┣ `JS엔진`은 소스코드를 2개의 과정
- ┣ 1. `소스코드의 평가`
- ┗ 2. `소스코드의 실행` 과정으로 나누어서 처리

- `소스코드 평가` 과정 : 1. `실행 컨텍스트를 생성`
- ┣ 2. 변수, 함수등의 `선언문`만 `먼저 실행` → `생성된 변수`나
- ┣ `함수 식별자`를 `키`로 `실행 컨텍스트가 관리`하는
- ┗ 스코프(`렉시컬 환경 레코드`)에 등록함

- `소스코드 평가 과정 끝`나면
- ┣ 비로소 선언문을 제외한 `소스코드가 순차적으로 실행`
- ┣ 즉 : `런타임`이 `실행`
- ┣ `소스코드 실행`에 `필요한 정보`
- ┣ 즉 : `함수의 참조`를 `실행 컨텍스트가 관리하는 스코프`에서
- ┣ `검색해서 취득`
- ┣ `변수 값의 변경` 등 소스코드의 `실행 결과` → 다시 실행 컨텍스트가
- ┗ `관리하는 스코프에 등록`됨

```js
var x;
x = 1;
```

- 다음과 같은 예제에서 `JS 엔진` :
- ┣ `2개의 과정`으로 나누어 처리
- ┣ 1. `소스코드 평가` 과정 → `변수 선언문` `var x;` 실행
- ┣ 생성된 변수 식별자 x → `실행 컨텍스트가 관리`하는
- ┗ `스코프에 등록` 후 → `undefined로 초기화`

- `소스코드 평가 과정이 끝`나면 → `비로소 소스코드 실행 과정`
- ┣ `변수 선언문` `var x;`는 `소스코드 평가 과정에서 이미 실행 완료`
- ┣ 따라서 → 소스코드 `실행` 과정 → `변수 할당문` `x=1;`만 `실행`
- ┗ `변수에 값을 할당`하려면 `먼저 x 변수가 선언된 변수`인지 `확인`

- 이를 위해 `실행 컨텍스트`가 관리하는 스코프에
- ┣ x 변수가 `등록되어 있는지 확인`
- ┣ 다시 말해 : x 변수가 선언된 변수인지 확인
- ┣ 등록되어 있는 경우 x 변수 : `평가 과정에서 선언문이 실행`되어 등록된 변수
- ┗ x가 선언된 변수라면 : `값을 할당`하고 → `할당 결과를 실행 컨텍스트에 등록, 관리`

> 1. 소스코드 평가 : 선언문 실행 후 스코프 등록
> 2. 소스코드 실행 : 변수 할당문 실행
>    실행 컨텍스트에 등록되어 있는지 확인 후 할당

## 23.2 실행 컨텍스트의 역할

- 다음 예제 : 전역 코드, 함수 코드로 구성
- ┗ JS가 이 예제를 어떻게 평가하고 실행할지 생각

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
	const x = 10;
	const y = 20;

	// 메서드 호출
	console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

### 1. 전역 코드 평가

- 전역 코드 실행에 앞서
- ┣ 먼저 전역 코드 평가 과정을 거치며
- ┣ `전역 코드를 실행`하기 위한 `준비`를 함
- ┣ `소스코드 평가 과정` : `선언문만 먼저 실행`
- ┣ 전역 코드의 `변수 선언문`, `함수 선언문`이 먼저 실행
- ┣ 그 결과 : 생성된 1. `전역 변수`, 2. `전역함수`가
- ┣ `실행 컨턱스트가 관리`하는 → `전역 스코프`에 등록
- ┣ 이때 var 키워드로 선언된 `전역 변수와 함수 선언문`으로
- ┗ 정의된 `전역 함수` : `전역 객체의 프로퍼티와 메서드`가 됨

### 2. 전역 코드 실행

- `전역 코드 평가 과정 끝` →
- ┣ `런타임이 시작`되어 `전역 코드가 순차적으로 실행`
- ┣ `전역 변수에 값이 할당`되고 `함수가 호출`됨
- ┣ `함수가 호출`되면 순차적으로 실행되던
- ┣ 전역 코드의 `실행을 일시 중단`
- ┗ `코드 실행 순서를 변경`하여 `함수 내부로 진입`

### 3. 함수 코드 평가

- 함수 호출에 의해 : `코드 실행 순서가 변경`되어
- ┣ 함수 내부로 진입하면 → 함수 내부의 문들을
- ┣ 실행하기에 앞서 `함수 코드 평가 과정`을 거치며
- ┣ `함수 코드를 실행하기 위한 준비`를 함
- ┗ `매개변수`와 `지역 변수 선언문`이 `먼저 실행`

- 그 결과 : `생성된 매개변수`와 `지역 변수`가
- ┣ `실행 컨텍스트가 관리`하는 `지역 스코프에 등록`
- ┣ 함수 내부에서 `지역 변수처럼 사용할 수 있는`
- ┣ `arguments 객체`가 생성되어
- ┗ `지역 스코프에 등록`, `this 바인딩 결정`

### 4. 함수 코드 실행

- 함수 코드 과정이 끝나면
- ┣ `런타임 시작` → `함수 코드가 순차적으로 실행`됨
- ┣ 이때 `매개변수`와 `지역 변수에 값이 할당`
- ┗ `console.log` `메서드가 호출`

- `console.log` 메서드 호출하기 위해서
- ┣ 먼저 식별자인 console → `스코프 체인을 통해 검색`
- ┣ 이를 위해 함수 코드의 지역 스코프 :
- ┗ `상위 스코프인 전역 스코프와 연결`되어야 함

- ┣ 하지만 console 식별자 :
- ┣ `스코프 체인 등록 X` → `전역 객체 프로퍼티`로 존재
- ┣ 이는 `전역 객체의 프로퍼티가 마치 전역 변수`처럼
- ┗ `전역 스코프를 통해 검색 가능`해야 한다는 것을 의미

- `log 프로퍼티`를 console 객체의 프로토타입 체인을 통해 검색
- ┣ `console.log` 메서드에 인수로 전달된 표현식
- ┣ `a + x + y`가 평가
- ┣ a, x, y 식별자 : 스코프 체인을 통해 검색
- ┣ `console.log` 메서드의 실행이 종료
- ┣ 함수 코드의 실행 과정 종료되고, `함수 호출 이전으로 되돌아가`
- ┗ `전역 코드의 실행을 계속`하게 됨

> 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 관리 필요

1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스)를

   - ┣ 1) `스코프를 구분하여 등록`하고
   - ┣ 2) `상태 변화(식별자에 바인딩된 값의 변화)`를
   - ┗ `지속적으로 관리` 가능해야 함

2. `스코프를 중첩 관계에 의해 스코프 체인`을 형성

   - ┣ 스코프 체인을 통해 → `상위 스코프로 이동`
   - ┗ `식별자를 검색`할 수 있어야 함

3. 현재 실행 중인 코드의 `실행 순서를 변경`
   - ┣ (함수 호출에 의한 실행 순서 변경)
   - ┣ 할 수 있어야 하며
   - ┗ `원상복구도 가능`해야 함

- 이 모든 것을 관리하는 것이 : 실행 컨텍스트

- `실행 컨텍스트` : 소스코드를 실행하는데
- ┣ 1. `필요한 환경을 제공`하고
- ┗ 2. `실행 결과를 실제로 관리`하는 영역

- `구체적으로 실행 컨텍스트` :
- ┣ 1. `식별자(변수, 함수, 클래스)`를 `등록`, `관리`하고
- ┣ 2. `스코프와 코드 실행 순서` 관리를 구현한 `내부 매커니즘`
- ┗ `모든 코드` : `실행 컨텍스트를 통해 실행되고 관리`

- `식별자, 스코프` : `실행 컨텍스트의 렉시컬 환경`으로 관리
- ┗ 코드 `실행 순서` : `실행 컨텍스트 스택`으로 관리

## 23.4 실행 컨텍스트 스택

- 다음 예제

```js
const x = 1;

function foo() {
	const y = 2;

	function bar() {
		const z = 3;
		console.log(x + y + z);
	}
	bar();
}

foo(); // 6
```

- 위 예제 : `소스코드의 타입으로 분류`할 때
- ┣ `전역 코드, 함수 코드`로 이루어져 있음
- ┣ JS엔진 : `먼저 전역 코드를 평가`하여
- ┣ `전역 실행 컨텍스트를 생성`함
- ┣ 함수가 호출되면 `함수 코드를 평가`하여
- ┗ `함수 실행 컨텍스트를 생성`

- 생성된 실행 컨텍스트 : `스택 자료구조로 관리`
- ┣ 이를 → 스택 컨텍스트 스택
- ┣ 코드가 실행되는 시간의 흐름에 따라
- ┗ 실행 컨텍스트에 push, pop 됨

### 1. 전역 코드의 평가와 실행

- `JS엔진` : 먼저 `전역 코드를 평가`하여
- ┣ `전역 실행 컨텍스트를 생성`하고
- ┣ 실행 컨텍스트 스택에 푸시함
- ┣ 전역 변수 x, `전역 함수 foo는 전역 실행 컨텍스트에 등록`
- ┣ `전역 코드가 실행되기 시작`하여
- ┗ 전역 변수 x에 `값이 할당`, `전역 함수` foo가 `호출`

### 2. foo 함수 코드의 평가와 실행

- `전역 함수 foo가 호출` → 전역 코드의 `실행은 일시 중단`
- ┣ `코드의 제어권`이 : `foo 함수 내부로 이동`하게 됨
- ┣ `JS엔진` : `foo 함수 내부의 코드를 평가`하여 →
- ┣ 1. `foo 함수 실행 컨텍스트를 생성`
- ┣ 2. `실행 컨텍스트 스택에 푸시`
- ┣ foo 함수의 지역 변수 y와 중첩 함수 bar가
- ┣ foo 함수 실행 컨텍스트에 등록됨
- ┗ 이후 foo 함수 코드가 실행되기 시작하며 지역 변수 y 할당, 중첩함수 호출

### 3. bar 함수 코드의 평가와 실행

- 중첩 함수 `bar가 호출되면 foo 함수 코드의 실행`은
- ┣ 일시 중단되고, 코드의 제어권이 bar 함수 내부로 이동함
- ┣ `JS엔진` : `bar 함수 내부의 함수 코드를 평가`하여
- ┣ `bar 함수 실행 컨텍스트를 생성`하고
- ┣ `실행 컨텍스트 스택에 푸시`
- ┣ `bar 함수의 지역 변수` z : `bar 함수 실행 컨텍스트`에 등록
- ┣ bar 함수 코드가 실행되기 시작하여
- ┣ 지역 변수 z에 값이 할당, console.log 메서드를 호출한 이후
- ┗ bar 함수는 종료

### 4. foo 함수 코드로 복귀

- bar 함수가 종료되면
- ┣ 코드의 제어권 : 다시 foo 함수로 이동
- ┣ 이때 : JS엔진 → bar 함수 실행 컨텍스트를
- ┣ 실행 컨텍스트 스택에서 팝하여 제거함
- ┗ 결국 foo 함수 더 이상 실행할 코드가 없어서 종료

### 5. 전역 코드로 복귀

- foo 함수가 종료되면
- ┣ 코드의 제어권 : 다시 전역 코드로 이동하게 됨
- ┣ JS 엔진 : foo 함수 실행 컨텍스트 팝하여 제거
- ┗ 결국 실행 컨텍스트 스택에는 아무것도 남아있지 않게됨

## 23.5 렉시컬 환경

- `렉시컬 환경(Lexical Environment)` :
- ┣ 1. `식별자`와 2. `식별자에 바인딩된 값`
- ┣ 그리고 3. `상위 스코프에 대한 참조를 기록하는 자료구조`
- ┣ 실행 컨텍스트를 구성하는 컴포넌트임
- ┣ 실행 컨텍스트 스택 : 코드의 실행 순서를 관리한다면
- ┗ 렉시컬 환경 : 스코프와 식별자를 관리

- `렉시컬 환경` : `키와 값을 갖는 객체 형태의 스코프`
- ┣ (전역, 함수, 블록 스코프)를 생성하여
- ┣ `식별자 → 키로 등록`하고
- ┣ `식별자에 바인딩된 값을 관리`
- ┣ 즉 : 렉시컬 환경은 스코프를 구분하여
- ┗ 식별자를 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체

- 실행 컨텍스트 :
- ┣ 1. `LexicalEnvironment 컴포넌트`
- ┗ 2. `VariableEnvironment 컴포넌트`로 구성됨

- 생성 초기 :
- ┣ `LexicalEnvironment 컴포넌트와 `
- ┣ `VariableEnvironment 컴포넌트`는
- ┗ 하나의 `동일한 렉시컬 환경을 참조`

- `strict mode`, `eval`, `try/catch`문을 `제외`하고
- ┗ 구분하지 않고 같은 렉시컬 환경으로 간략하게 생각하여 설명

1. `환경 레코드(Environment Record)`

- 스코프에 포함된 `식별자를 등록`하고
- ┣ `등록된 식별자에 바인딩된 값을 관리하는 저장소`
- ┣ 환경 레코드 : 소스코드의 타입에 따라
- ┗ 관리하는 내용의 차이가 있음

2. `외부 렉시컬 환경에 대한 참조 (Outer Lexical Environment Reference)`

- 외부 렉시컬 환경에 대한 참조 : 상위 스코프를 가리킴
- ┣ `상위 스코프` : `외부 렉시컬 환경`
- ┣ 실`행 컨텍스트를 생성한 소스코드를 포함`하는
- ┣ 상위 코드의 렉시컬 환경을 말함
- ┣ 외부 렉시컬 환경에 대한 참조를 통해
- ┗ `단방향 링크드 리스트인` → `스코프 체인을 구성`함

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

- 다음 예제를 통해 실행 컨텍스트가 생성되고
- ┣ 코드 실행 결과가 관리되는지
- ┗ 어떻게 실행 컨텍스트를 통해 식별자를 검색하는지 학습

```js
var x = 1;
const y = 2;

function foo(a) {
	var x = 3;
	const y = 4;

	function bar(b) {
		const z = 5;
		console.log(a + b + x + y + z);
	}
	bar(10);
}
foo(20); // 42
```

### 23.6.1 전역 객체 생성

- `전역 객체` : 전역 코드가 `평가되기 이전에 생성`
- ┣ `전역 객체`에는 1. `빌트인 전역 프로퍼티`와
- ┣ 2. `전역함수`, 3. `표준 빌트인 객체가 추가`되어
- ┗ 동작환경에 따라 → 클라이언트 사이드, 호스트 객체를 포함

- 전역 객체도 Object.prototype을 상속받음

> 즉 : 전역 객체도 프로토타입 체인의 일원

```js
// Object.prototype.toString
window.toString(); // [object Window]

window.__proto__.__proto__.__proto__.__proto__ === Object.prototype;
```

### 23.6.2 전역 코드 평가

- 소스코드가 로드되면 `JS 엔진` : `전역 코드를 평가함`
- ┗ 전역 코드 평가는 다음과 같은 순서로 진행

1. 전역 실행 컨텍스트 생성

2. 전역 렉시컬 환경 생성
   - 2.1 전역 환경 레코드 생성
     - 2.1.1 객체 환경 레코드 생성
     - 2.1.2 선언적 환경 레코드 생성
   - 2.2 this 바인딩
   - 2.3 외부 렉시컬 환경에 대한 참조 결정

#### 1. 전역 실행 컨텍스트 생성

- `먼저 비어있는 전역 실행 컨텍스트를 생성`하여
- ┣ `실행 컨텍스트 스택에 푸시`함
- ┣ 이때 전역 실행 컨텍스트 :
- ┣ 실행 컨텍스트 스택의 최상위 → 실행 중인 컨텍스트
- ┗ `(running execution context)`가 됨

#### 2. 전역 렉시컬 환경 생성

- 전역 렉시컬 환경을 생성하고
- ┗ 전역 실행 컨텍스트에 바인딩

> 23.5에서 보았듯 렉시컬 환경은 2개의 컴포넌트
>
> 1. 환경 레코드
> 2. 외부 렉시컬 환경에 대한 참조로 구성

##### 2.1 전역 환경 레코드 생성

- `전역 렉시컬 환경을 구성하는 컴포넌트`인
- ┣ `전역 환경 레코드(Global Environment Record)`는
- ┣ `전역 변수를 관리`하는
- ┣ 1. `전역 스코프`, 2. `전역 객체의 빌트인 전역 프로퍼티`,
- ┗ 3. `빌트인 전역 함수`, 4. `표준 빌트인 객체`를 제공

- 모든 전역 변수가 전역 객체의 프로퍼티가 되는 `ES6 이전`
- ┣ `전역 객체`가 → `전역 환경 레코드의 역할을 수행`
- ┣ 하지만 : `ES6 이후` `let`, `const` 키워드로 선언한 `전역 변수`
- ┣ 전역 객체의 프로퍼티가 되는 것이 아닌
- ┗ `개념적인 블록 내에 존재`하게 됨

- 이처럼 기존의 `var 키워드로 선언한 전역 변수`와
- ┣ `ES6`의 `let, const 키워드`로 선언한 `전역 변수를 구분하여 관리`하기 위해
- ┣ 전역 스코프 역할을 하는 전역 환경 레코드는
- ┣ 1. 객체 환경 레코드(Object Environment Record)
- ┗ 2. 선언적 환경 레코드(Declarative Environment Record)로 구성

- 객체 환경 레코드 : 기존의 전역 객체가 관리하던
- ┣ var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한
- ┣ 1. 전역 함수, 2. 블트인 전역 프로퍼티, 3. 빌트인 전역 함수
- ┗ 4. 표준 빌트인 객체를 관리

- `선언적 환경 레코드` : `let`, `const` `키워드로 선언한 전역 변수를 관리`
- ┣ 전역 환경 레코드의 객체 환경 레코드와 선언적 환경
- ┣ 서로 협력하여 전역 스코프, 전역 객체(전역 변수의 전역 객체 프로퍼티)
- ┗ 관리하게 됨
