# 7 연산자

- 연산자(operator)는 하나 이상의 표현식을 대상으로
- ┣ 산술, 할당, 비교, 논리, 타입, 지수 연산(operation)
- ┣ 등을 수행할 하나의 값을 만든다.
- ┣ 이때 연산의 대상을 피연산자(operand)라고 함
- ┣ 피연산자는 값을 평가될 수 있는 표현식이어야 함
- ┗ 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식으로 값으로 평가될 수 있는 표현식

- 피연산자가 "값"이라는 명사의 역할을 한다면 연산자는
- ┣ "피연산자를 연산하여 새로운 값을 만든다" 라는 동사 역할
- ┣ 다시 말해 피연산자는 연산의 대상의 되어야 하므로
- ┣ 값을 평가할 수 있어야 함
- ┗ 연잔자는 값으로 평가된 피연산자를 연산해 새로운 값을 만듬

## 7.1 산술 연산자

- 산술 연산자(arithmetic operator)는 피연산자를 대상으로
- ┣ 수학적 계산을 수행해 새로운 숫자 값을 만듬
- ┣ 산술 연산이 불가능한 경우 NaN을 반환
- ┗ 산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분

### 7.1.1 이항 산술 연산자

- 이항(binary) 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 값을 만듬
- ┣ 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과(slide effect)가 없다.
- ┗ 어떤 산술 연산을 해도 피연자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만듬

| 이항 산술 연산자 | 의미   | 부수효과 |
| ---------------- | ------ | -------- |
| +                | 덧셈   | x        |
| -                | 뺄셈   | x        |
| `*`              | 곱셈   | x        |
| /                | 나눗셈 | x        |
| %                | 나머지 | x        |

### 7.1.2 단항 산술 연산자

- 단항(library) 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만듬

| 단항 산술 연산자 | 의미                                              | 부수 효과 |
| ---------------- | ------------------------------------------------- | --------- |
| ++               | 증가                                              | o         |
| --               | 감소                                              | o         |
| +                | 어떠한 효과도 없음, 음수를 양수로 반전하지도 않음 | X         |
| -                | 양수를 음수로, 음수를 양수로 반전한 값을 반환     | X         |

- 주의할 점은 이항 산술 연산자와는 달리 증가/감소(++/--) 연산자는
- ┣ 피연산자는 값을 변경하는 부수 효과가 있다는 것
- ┣ 다시 말해, 증가/감소 연산을 하면 피연산자 값을 변경하는
- ┗ 암묵적 할당이 이루어짐

> 증가/감소 연산자는 위치에 의미가 있음

- 앞에 위치 : 피연산자의 값을 증가/감소 시킨 후 → 다른 연산을 수행
- 뒤에 위치 : 다른 연산을 먼저 수행한 후 → 피연산자의 값을 감소

- - 단항 연산자는 어떠한 효과도 없음

- 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 `숫자 타입`으로 변환 반환
- ┗ 피연산자를 변경하는 것은 아니고 숫자 타입으로 `변환한 값을 생성해서 반환`

- 단항 연산자는 피연산자의 부호를 반전한 값을 반환
- ┣ + 단항 연산자와 마찬기지로 숫자 타입이 아닌 피연산자에 사용하면
- ┣ 피연산자를 숫자 타입으로 변환하여 반환
- ┣ 피연산자를 변경하는 것은 아니고
- ┗ 부호를 반전한 값을 생성해 반환함

### 7.1.3 문자열 연결 연산자

- `+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작
- ┗ 그 외의 경우는 산술 연산자로 동작

```js
'1' + 2; // → '12'
1 + '1'; // → '12'

// 산술 연산자
1 + 2; // → 3

// true는 1로 타입 변환
1 + true; // → 2

// false는 0으로 타입 변환
1 + false; // → 1

// null은 0으로 타입 변환
1 + null; // → 1

// undefined는 숫자로 타입 변환되지 않음
+undefined; // NaN
1 + undefined; // NaN
```

- 개발자에 의도와는 상관없이 JS 엔진에 의해서 암묵적으로 타입이
- ┣ 자동으로 변환되기 한다는 점
- ┣ 위 의 `true`는 true를 강제 숫자 타입 1로 변환후 연산 수행
- ┣ 이를 `암묵적 타입변환(implicit coercion)` 또는 `강제 변환(type coercion)`이라고 함
- ┗ 앞에서 살펴본 +/- 단항 연산자도 암묵적인 타입 변환이 발생

## 7.2 할당 연산자

- `할당 연산자(assignment operator)`는 우항에 있는 피연자의 평가 결과를
- ┣ `좌항`에 있는 `변수에 할당`
- ┣ 할당 연산자는 좌항의 변수에 값을 할당하므로
- ┗ 변수 `값이 변하는` `부수 효과`가 있음

| 할당 연산자 | 예        | 동일 표현   | 부수 효과 |
| ----------- | --------- | ----------- | --------- |
| =           | x = 5     | x = 5       | o         |
| +=          | x += 5    | x = x +5    | o         |
| -=          | x -= 5    | x = x-5     | o         |
| `*=`        | ` x *= 5` | `x = x * 5` | o         |
| /=          | x /= 5    | x = x / 5   | o         |
| %=          | x %=5     | x = x % 5   | o         |

- 표현식은 값으로 평가될 수 잇는 문
- ┣ 문에는 표현식인 문, 표현식이 아닌 문이 존재
- ┗ 그럼 할당문 ? 표현식 일까 아닐까

```js
var x;

console.log((x = 10)); // 10
```

- 할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것 처럼 보임
- ┣ 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가
- ┣ 할당문 x = 10은 x에 할당된 숫자 값 10으로 평가
- ┣ 할당문을 다른 변수에 할당도 가능
- ┗ 이런 특징을 이용해서 변수에 동일한 값을 연쇄 할당 가능

```js
var a, b, c;

a = b = c = 0;

console.log(a, b, c);
```

## 7.3 비교 연산자

- `비교 연산자(comparison operator)`는 좌항과 우항의 피연산자를 비교한 다음
- ┣ 그 결과를 불리언 값으로 반환
- ┗ 비교 연산자는 `if`, `for` 문과 같은 제어문의 조건식에서 주로 사용

### 7.3.1 동등/일치 비교 연산자

- `동등 비교(loose equality)` 연산자와 `비교(strict equally)연산자`는 좌항과 우항의
- ┣ 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환
- ┣ 비교하는 엄격성의 정도가 다름
- ┣ 동등 비교 연산자는 느슨한 비교를 하지만
- ┗ 일치 비교 연산자는 엄격한 비교를 함

| 비교 연산자 | 의미        | 사례    | 설명                     | 부수 효과 |
| ----------- | ----------- | ------- | ------------------------ | --------- |
| ==          | 동등 비교   | x == y  | x와 y의 값이 같음        | x         |
| ===         | 일치 비교   | x === y | x와 y의 값과 타입이 같음 | x         |
| !=          | 부동등 비교 | x != y  | x와 y의 값이 다름        | x         |
| !==         | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 | x         |

- JS 엔진의 경우 암묵적으로 타입이 자동 변환되기도 함
- ┣ 이를 암묵적 타입 변환이라고 함
- ┣ `동등 비교(==) 연산자`는 좌항, 우항의 피연산자를 비교할 때 먼저
- ┗ 암묵적 타입 변환을 통해 타입을 먼저 일치시킨 후 같은 값인지 비교

- 따라서 `동등 비교 연산자`는 좌항과 우항의 피연산자가
- ┣ 타입은 다르더라도 `암묵적 타입 변환 후에 같은 값`일 수 있다면
- ┗ `true를 반환`

```js
5 == '5'; //true
```

- 동등 비교 연산자는 편리한 경우도 있지만
- ┗ 결과를 예측하기 어렵고 실수하기 쉬움

> 그래서 일치 비교(===) 연산자를 사용하게 됨

- 일치 비교 연산자(===) 좌항과 우항의 피연산자가 타입도 같고
- ┣ 값도 같은 경우에 한해서 true를 반환
- ┗ 암묵적 타입을 반환하지 않고 값을 비교

```js
5 === 5;
```

- 일치 비교 연산자에서 주의사항 → NaN

```js
NaN === NaN; // false
```

> NaN의 경우 자신과 일치하지 않는 유일 한 값

    따라서 숫자가 `NaN`인지 조사하려면
    ┗ 빌트인 함수 `isNaN`을 사용해야 함

> 숫자 0도 조심

    양의 0과 음의 0을 비교해도 true를 반환

```js
0 === -0; // true
```

> Object.is 메서드

    앞의 경우 동등 비교 연산자(==), 일치 비교 연산자(===)는
    ┣ +0과 -0을 동일하다고 평가
    ┣ 또한 동일한 값 NaN, NaN 다르다고 평가
    ┣ ES6에서 도입된 Object.is 메서드는 다음과 같은
    ┣ 예측 가능한 정확한 비교 결과를 반환
    ┗ 그 외에는 일치 비교 연산자와 동일하게 동작

```js
-0 === +0; // true
Object.is(-0, +0); //false
NaN === NaN; // false
Object.is(NaN, NaN); // true
```

- `부동등 비교 연산자(!=)` 비교 연산자(!==)는 각각 동등 비교, 일치 비교와 반대 개념

### 7.3.2 대소 관계 비교 연산자

- 대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환

> 내가 알고 있는 비교와 같으며 부수효과는 없다.

## 7.4 삼항 조건 연산자

- `삼항 조건 연산자(ternary operator)`은 조건식의 평가 결과에 따라
- ┣ 반환할 값을 결정
- ┣ JS의 유일한 삼항 연산자이며
- ┗ 부수효과는 존재하지 않음

```js
조건식 ? 조건식 true일 때 반환 값 : false 일 때 반환 값

var result = score >= 60 ? 'pass' : 'fail'
```

- 삼항 조건 연산자는 첫 번째 연산자 true → 두 번째 피연산자 반환
- ┣ false → 세 번째 피연산자를 반환
- ┗ 즉 삼항 조건 연산자는 두 번째 피연산자 또는 세번째 피연산자로 평가

> if else 문으로 삼항 조건 연산자를 유사하게 처리 가능

    하지만 큰 차이점이 존재
    ┣ 삼항 조건 연산자 표현식은 값처럼 사용 가능하지만
    ┗ if else 문은 값처럼 사용 불가

- if ... else 문은 표현식이 아닌 문임
- ┗ 고로 if ... else 문은 값처럼 사용 불가

- 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문

- 조건을 수행해야 할 문이 하나가 아닌 여러개 일 경우
- ┗ if ...else 문의 가독성이 더 좋음

## 7.5 논리 연산자

- 논리 연산자(logical operator)는 우항과 좌항의 피연자를 논리 연산함

| 논리 연산자 | 의미        | 부수효과 |
| ----------- | ----------- | -------- |
| \\          | 논리합(OR)  | X        |
| &&          | 논리곱(AND) | X        |
| !           | 부정(NOT)   | X        |

- `논리 부정(!)` 연산자는 언제나 불리언 값을 반환
- ┣ 피연산자가 반드시 `불리언 값일 필요는 없음`
- ┗ 피연산자가 불리언 값이 아니면 불리언 타입으로 `암묵적 타입 변환`

```js
// 암묵적 타입 변환
!0; // true;
!'Hello'; //false;
```

- `논리합(||)` 또는 `논리곱(&&)` 연산자 표현식의 평가 결과는
- ┣ 불리언 값이 아닐 수도 있음
- ┣ `논리합(||)` 또는 `논리곱(&&)` 연산자 표현식은 언제나 2개의 피연산자 중
- ┗ 어느 한쪽으로 평가됨

```js
// 단축 평가
'Cat' && 'Dog'; // → 'Dog'
```

> 드 모로르간의 법칙

    논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아
    한눈에 이해하기 어려울 때가 있음
    이러한 경우 드 모르간의 법칙을 이용하면
    복잡한 표현식을 좀 더 가독성 좋게 변환 가능

```js
!(x || y) === (!x && !y);
!(x && y) === (!x || !y);
```

## 7.6 쉼표 연산자

- `쉼표(,)` 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가
- ┗ 마지막 피연자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환

```js
var x, y, z;
(x = 1), (y = 2), (z = 3); //3
```

## 7.7 그룹 연산자

- `소괄호('()')`로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을
- ┣ 가장 먼저 평가하게 됨
- ┣ 따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절 가능
- ┗ 그룹 연산자는 연산자 우선순위가 가장 높음

> 수학 기호에서 사용하는 것과 동일

## 7.8 typeof 연산자

- typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환
- ┣ typeof 연산자는 7가지 문자열 "string", "number", "boolean"
- ┣ "undefined", "symbol", "object", "function" 중 하나를 반환
- ┣ "null"을 반환하는 경우는 없으며 함수의 경우 "function" 을 반환
- ┗ 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치 X

> typeof 연산자로 null 값을 연산해 보면 "null"이 아닌 "object"를 반환

> 또한 선안한지 않은 식별자를 typeof 연산자로 연산해보면

    ReferenceError가 발생하는 것이 아닌 undefined를 반환

## 7.9 지수 연산자

- ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑(base)
- ┗ 우항의 피연산자를 지수(exponent)로 거듭 제곱하여 숫자 값을 반환

```js
2 ** 2; // 4
2 ** 0; // 1
```

- 지수 연산자 도입 전에는 `Math.pow` 메서드를 이용

```js
Math.pow(2, 2); // 4
```

- 지수 연산자는 다음과 같은 경우 Math.pow 보다 가독성이 좋음

```js
Math.pow(Math.pow(2, 2), 2);
```

> 음수를 거듭제곱의 밑으로 사용해 계산하기 위해서는 괄호를 사용

```js
(-5) ** 2;
```

- 다른 산술연산자와 마찬가지로 할당 연산자와 함께 사용 가능

```js
var num = 5;
num **= 2; // 25
```

> 지수 연잔자의 경우 연산자 중 우선순위가 가장 높음

## 7.10 그 외의 연산자

- 다양한 연산자 존재 추후에 학습

| 연산자     | 개요                                                        |
| ---------- | ----------------------------------------------------------- |
| ?.         | 옵셔널 체이닝 연산자                                        |
| ??         | null 병합 연산자                                            |
| delete     | 프로퍼티 삭제                                               |
| new        | 생성자 함수를 호출할 때 사용하여 인스턴스를 생성            |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 |
| in         | 프로퍼티 존재 확인                                          |

## 7.11 연산자의 부수 효과

- 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있음
- ┗ 부수 효과가 잇는 연산자는 `할당 연산자(=)`, `증가/감소 연산자(++/--)`, `delete 연산자`

```js
var x;

// 할당 연산자는 변수 값이 변하는 부수 효과
// 이는 x 변수를 사용하는 다른 코드에 영향을 줌

x = 1;
console.log(x); // 1

// 증가/감소 연산자(++/--)는 피연사나의 값을 변경하는 부수 효과가 존재
// 피연산자 x의 값이 재할당되어 변경
// 이는 x 변수를 사용하는 다른 코드에 영향을 줌

x++;
console.log(x);

var o = { a: 1 };

// delete 연산자는 객체의 프로퍼티를 삭제하는 부수효과 존재
// 이는 o 객체를 사용하는 다른 코드에 영향을 줌
delete o.a;
console.log(o);
```

## 7.12 연산자 우선순위

- 연산자 우선순위는 여러 개의 연산자로 이뤄진 문이
- ┣ 연산자가 실행될 때 연산자가 실행되는 순서를 의미
- ┗ 우선순위가 높을수록 먼저 실행

| 우선순위 | 연산자                                                                                      |
| -------- | ------------------------------------------------------------------------------------------- |
| 1        | `()`                                                                                        |
| 2        | `new(매개변수 존재)`, `.`, `[](프로퍼티 접근)`, `()(함수 호출)`, `?.(옵셔널 체이닝 연산자)` |
| 3        | `new(매개변수 미존재)`                                                                      |
| 4        | `x++`, `x--`                                                                                |
| 5        | `!x`, `+x`, `-x`, `++x`, `--x`, `typeof`, `delete`                                          |
| 6        | `**(이항 연산자 중에서 우선순위가 가장 높다)`                                               |
| 7        | `*`, `/`, `%`                                                                               |
| 8        | `+`, `-`                                                                                    |
| 9        | `<`, `<=`, `>`, `>=`, `in`, `instanceof`                                                    |
| 10       | `==`, `!=`, `===`, `!==`                                                                    |
| 11       | `??(null 병합 연산자)`                                                                      |
| 12       | `&&`                                                                                        |
| 13       | `or 연산자`                                                                                 |
| 14       | `? ...` : `...`                                                                             |
| 15       | 할당 연산자(=, +=, -=, ...)                                                                 |
| 16       | ,                                                                                           |

> 연산자의 경우 종류가 너무 많기 때문에 우선순위를 기억하기 어려움

    그렇기에 우선순위를 명시적으로 조절하는 것을 권장
