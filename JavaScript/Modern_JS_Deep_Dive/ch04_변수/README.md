# 4.변수

## 목차

- [4.변수](#4%EB%B3%80%EC%88%98)
  - [4.1 변수란 무엇인가? 왜 필요한가?](#41-%EB%B3%80%EC%88%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80)
  - [4.2 식별자](#42-%EC%8B%9D%EB%B3%84%EC%9E%90)
  - [4.3 변수 선언](#43-%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8)
    - [설명](#%EC%84%A4%EB%AA%85)
  - [4.4 변수 선언의 실행 시점과 변수 호이스팅](#44-%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8%EC%9D%98-%EC%8B%A4%ED%96%89-%EC%8B%9C%EC%A0%90%EA%B3%BC-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85)
  - [4.5 값의 할당](#45-%EA%B0%92%EC%9D%98-%ED%95%A0%EB%8B%B9)
  - [4.6 값의 재할당](#46-%EA%B0%92%EC%9D%98-%EC%9E%AC%ED%95%A0%EB%8B%B9)
    - [unManaged lan , managed lan 차이](#unmanaged-lan--managed-lan-%EC%B0%A8%EC%9D%B4)
  - [4.7 식별자 네이밍 규칙](#47-%EC%8B%9D%EB%B3%84%EC%9E%90-%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B7%9C%EC%B9%99)

## 4.1 변수란 무엇인가? 왜 필요한가?

- App 에서는 데이터를 다룸
- ┣ 아무리 복잡한 App 이라고 해도 데이터를 입력(input) 받아서
- ┣ 처리하는 결과는 출력(output) 하는 것이 전부이다.
- ┗ 이 장에서는 변수는 왜 필요하고 이를 어디에 사용하는지에 대해서 학습

- 컴퓨터의 경우 사람을 모델로 디자인 되었기 때문에 사람과 유사하게 동작
- ┣ 컴퓨터 즉 자바스크립트를 해석하고 실행하는 JS 엔진도 사람과 유사하게 JS 코드를 실행하게 됨
- ┣ JS 엔진이 코드를 계산(평가 evaluation) 하고 10,20 이라는 기호(리터럴(literal) 연산자(operator))
- ┣ 이들의 의미를 알고 있어야 하고
- ┗ 10 + 20 (식 → 표현식 (expression))이라는 의미도 해석(파싱(passing))할 수 있어야 함

- JS 엔진이 10 + 20 식의 의므를 해석 하면
- ┣ + 연산을 수행하기 위해
- ┣ 먼저 + 연산자의 좌변과 우변의 숫자 값
- ┣ 피연산자(operand)를 기억함
- ┣ 사람의 경우 이를 모두 두뇌에서 처리하게 되지만
- ┣ 컴퓨터의 경우 연산과 기억을 수행하는 부품이 나누어져 있음
- ┗ 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억함

- 메모리(memory)
- ┣ 데이터를 저장할 수 잇는 메모리 셀(memory cell)의 집합체
- ┣ 메모리 셀 하나의 크기는 1바이트(8비트)
- ┣ 컴퓨터는 메모리 셀의 크기, 즉 1 바이트 단위로
- ┗ 데이터를 저장 하거나 읽어 들이게 됨

- 각 셀은 고유의 메모리 주소(memory address)를 가지게 되는데
- ┣ 이 메모리 주소는 메모리 공간의 위치를 나타내며
- ┣ 0 부터 시작해서 메모리의 크기 만큼 정수로 표현됨
- ┣ 예를 들어 4GB 메모리는
- ┗ 0 ~ 4,294,967,295 → (0x00000000 ~ 0xFFFFFFFF) 까지의 메모리 주소를 가지게 됨

- 컴퓨터의 경우 모든 데이터를 2진수로 처리하게 되고
- ┣ 메모리에 저장되는 데이터는 데이터의 종류(숫자, 텍스트, 이미지, 동영상)과 상관없이
- ┗ 모두 2진수로 저장되게 된다.

- 위 예제의 숫자 값 10과 20은 특정 메모리 주소에 저장(기억)되게 되고
- ┣ CPU의 경우 이를 읽어서 연산을 수행하게 된다.
- ┗ 연산 결과로 생성된 숫자 값 30도 메모리 상의 임의의 주소를 가지게됨

> 메모리에 저장되는 모든 값은 2진수로 처리 된다는 것을 기억

- 만약 메모리에 저장된 값을 재사용 하고 싶다면 어떻게 해야할까?
- ┣ 이 경우에 대해서는 주소값에 직접 접근 하여서 이를 사용하여야 한다.
- ┣ 하지만 메모리 주소값에 직접 접근 하는 방식은 매우 위험
- ┣ 실수로 운영체제가 사용하고 있는 값을 변경하게 된다면 큰 오류가 발생 할 수 있다.
- ┗ 그렇기에 JS는 개발자가 이를 메모리에 직접 접근 하도록 허용하지 않는다.

- 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고
- ┣ 저장된 값을 읽어 들여 재사용하기 위해서
- ┗ 변수라는 의미를 사용하여서 이를 사용하게 된다.

- `변수(variable)`는 하나의 값을 저장하기 위해 확보한 `메모리 공간 자체` 또는
- ┗ 메모리 공간을 식별하기 위한 이름을 말함
- 갇단하게 말하자면 변수는 프로그래밍 언어에서 값을 저장하고 참조하는 매커니즘
- ┣ 값의 위치를 가리키는 상징적인 이름
- ┗ 상징적인 이름의 변수는 컴파일러, 인터프리너테 의해서 메모리 공간의 주소로 치환되어 실행

> 변수에 여러개 값을 저장 방법

    ┣ 여러개의 값을 저장하기 위해서는 여러개의 변수를 사용해야 함
    ┗ `배열이나 객체` 같은 자료구조를 사용하면 그룹화 해서 이를 사용가능

```js
var result = 10 + 20;
```

- 위의 코드의 경우 연산을 통해 새로운 값인 30을 생성
- ┣ 그리고 연산을 통해 생성된 값 30은 메모리 공간에 저장됨
- ┣ 이 때 메모리 공간에 저장된 값 30을 다시 읽어 들여 재사용할 수 있도록
- ┗ 메모리 공간에 상징적인 이름을 붙인것이 바로 변수

- 변수에 값을 저장하는 것을 할당(assignment) 이라고 하고
- ┣ 변수에 저장된 값을 읽어 들이는 것을
- ┗ 참조(reference)라고 지칭하게 됨

- 변수 이름은 사람을 위해 사람이 이해할 수 있게 만든 언어로
- ┣ 값이 저장된 메모리 공간에 붙인 상징적인 이름
- ┣ 변수 이름에 참조를 요청하면 JS 엔진은
- ┣ 변수 이름과 매핑된 메모리 주소를 통해
- ┗ 메모리 공간에 접근하게 되어 저장된 값을 반환

## 4.2 식별자

- 변수 이름을 다른 말로 하자면 `식별자(identifier)`라고도 칭함
- ┗ 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말하게 됨

- 값은 메모리 공간에 저장되어 있다.
- ┣ 식별자 : 메모리 메모리 공간에 저장되어 있는 어떤 값을 구별해낼 수 있어야 하고
- ┗ 식별자 : 메모리 주소를 기억할 수 있어야 함!

> 식별자 : 이름 구별과, 주소를 기억할 수 있어야함

    값이 저장되어 있는 메모리 주소와 `매핑 관계`
    이 매핑 정보도 메모리에 저장되어야 함

- 식별자는 값이 아닌 메모리 주소를 기억하고 있어야 함
- ┣ 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해
- ┗ 메모리 공간에 저장된 값에 접근할 수 있다는 의미
- 식별자는 메모리 주소에 붙인 이름이라고 지칭 가능
- 식별자의 용어는 변수에만 해당되는 것이 아닌
- ┣ 변수, 함수, 클래스 등의 이름은 모두 식별자
- ┣ 식별자인 `변수 이름` → 메모리 상에 존재하는 변수 값을 식별
- ┗ `함수 이름` → 메모리 상에 존재하는 함수(JS 에서 함수는 값)를 식별

> 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부름

## 4.3 변수 선언

- 변수 선언(variable declaration)이란 변수를 생성하는 것
- ┣ 값을 저장하기 위한 메모리 `공간 확보(allocate)`
- ┣ 변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release) 되기 전까지
- ┗ 누구도 확보된 메모리 공간을 사용할 수 없도록 보호돠므로 안전하게 사용가능

- 변수를 사용하기 위해서는 반드시 `선언이 필요`
- ┗ var, let, const 키워드를 사용함

- ES6에서 let, const 키워드가 도입되기 이전까지
- ┣ var 키워드는 JS에서 변수를 선언 할 수 있는 유일한 키워드
- ┗ 먼저 var 키워드에 대해서 학습

> ES5 vs ES6

    var 에는 여러 단점들이 존재
    ┣ 대표적인 것은 `블록 레벨 스코프` 지원 X
    ┣ `함수 레펠 스코프 지원 O `
    ┗ 이는 의도치 않게 전역 변수가 선언되어 심각한 부작용 초래 가능

- let,const의 등장 배경은 var가 가지고 있는 한계를 해결하기 위해서임
- ┣ 이를 해결하기 위해서 등장하게 되었고
- ┣ 이해하기 위해서는 `스코프`라는 개념을 정확하게 알고 가야함
- ┣ ES6 에서 let,const가 등장하였다 하더라도 var는 여전히 사용 가능
- ┗ ES6는 ES5 보다 상위 집합이지 둘이 따로 놀게 되는 것은 아님

### 설명

```js
var score; // 변수 선언(변수 선언문)
```

- 다음과 같이 간단한 변수 선언이 있다고 가정
- ┣ 변수를 선언한 후 변수에 값을 할당하지는 않았음
- ┣ 따라서 변수 선언에 의해 확보된 메모리 공간은
- ┣ 비어있을 것으로 생각할 수 있으나
- ┣ 확보된 메모리 공간에는 JS 엔진에 의해 `undefined 값`이
- ┗ 암묵적으로 할당 되어 초기화

> undefined

    undefined는 JS에서 제공하는 `원시 타입 primitive value`

- JS 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행함

  1. 선언 : 이름을 등록해 JS 엔진에 변수의 존재를 알림
  2. 초기화 : 값을 저장하기 위해 메모리 공간을 확보
     - ┗ 암무적으로 undefined를 할당해 초기화

- 변수 이름의 저장
- ┣ 변수 이름을 비롯한 모든 식별자 : `실행 컨텍스트에 등록`
- ┣ 실행 컨텍스트(execution context) : JS 엔진이 소스코드를 평가하고
- ┣ 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를
- ┣ 실제로 관리하는 영역
- ┗ JS 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리

- `변수의 이름`과 `변수 값`은 실행 컨텍스트 내에
- ┣ `키(key)`, `값(value)` 형식의 객체로 등록되어 관리됨.
- ┣ JS 엔진이 변수를 관리하는 매커니즘은 뒤에서 학습
- ┗ 지금은 단순히 JS 엔진이 변수를 관리 할 수 있도록 변수의 존재를 알린다는 것만 학습

- 일반적으로 초기화(initialize)의 경우 변수가 선언된 이후 최초로 값을
- ┣ 할당하는 것을 말하게 됨
- ┣ var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행
- ┗ `var : 어떠한 값도 할당하지 않아도 자동으로 undefined`

- 초기화 단계를 거치지 않는다면 확보된 메모리 공간에는
- ┣ 이전에 다른 App이 사요했던 값이 남아 있을 수 있음
- ┣ 이러한 값을 쓰레기 값 (garbage value)라고 지칭
- ┣ 메모리의 공간을 확보하고
- ┣ 값을 할당하지 않은 상태에서 변수 참조 → 쓰레기 값
- ┗ var 키워드는 암무적으로 초기화를 수행하므로 위험에서 안전

> var가 선언과 동시에 undefined가 설정되는 것

    JS만의 독특한 특색이며
    초기화가 바로 실행되기 때문에 안전하다고 할 수 있다.

- 당연한 말 이지만 변수를 선언하지 않고 참조할 경우 오류가 발생

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```js
console.log(score);

var score; // 변수 선언문
```

- 다음의 경우 `선언문` 보다 `변수를 참조(console.log)` 하는 코드가 앞에 존재
- ┣ 인터프리터에 의해 한 줄씩 실행 되므로
- ┣ console.log() 실행 후 → 선언문이 선언됨
- ┣ 이 시점의 경우 score 변수의 실행되지 않았으므로
- ┗ `에러 Reference Error`r가 발생한 것 처럼 보이게 됨

> 그러나 생각과는 별개로 오류는 발생하지 않게 된다.

- 이유는 변수 선언이 소스코드가 한 줄씩 실행되는 시점이 아닌
- ┗ 즉 런타임이 아닌 → 그 전에 실행 되기 때문

- JS 엔진의 경우 소스코드를 한 줄씩 순차적으로 실행하기 앞서
- ┣ 먼저 소스코드의 평가 과정을 거치면서
- ┣ 소스코드를 실행하기 위한 준비를 함
- ┣ 이 때 실행을 위한 준비 단계인 소스코드의 평가 과정에서
- ┣ JS 엔진은 변수 선언을 포함한 모든 선언문(변수 선언, 함수 선언)을
- ┣ 소스코드에서 찾아내서 먼저 실행하게 됨
- ┗ 그리고 소스코드의 평가 과정이 끝나게 되면 소스코드를 한 줄씩 실행

> 먼저 모든 선언문을 선언 시키고 소스코드를 인터프리터 방식으로 실행시킨다고 보면 됨

- 변수 선언의 경우 소스 코드의 어디에 존재하든
- ┣ 다른 코드보다 먼저 실행되게 됨
- ┣ 따라서 변수 선언이 소스코드의 어디에 위치하는지 상관없이
- ┗ 변수를 참조할 수 있음

- 변수 선언이 코드의 선두에 끌어올려진 것 처럼 동작하는
- ┗ JS의 특징을 이를 `변수 호이스팅(variable hoisting)` 이라고 부름!

- 변수 선언 뿐만 아닌 `var`, `let`, `const`, `function`, `function*` `class`
- ┣ 키워드를 사용하더라도
- ┗ 모든 경우 이는 통용되기 때문에 걱정하지 않아도 됨

## 4.5 값의 할당

- 변수에 값을 할당(assignment) 할 때는
- ┣ `할당 연산자(=)`를 사용하게 됨
- ┗ `우변의 값`을 `좌변의 변수`에 할당!

```js
var score;
score = 80;
```

- 변수의 선언과 할당은 다음과 같이 한 줄에 단축이 가능하다.

```js
var score = 80;
```

- 주의점
- ┣ `변수 선언` → `코드가 실행되는 시점`인 → `런타임 이전`에 실행
- ┗ `값의 할당` → `코드가 순차적`으로 실행되는 `런타임 시점`

> Example

```js
console.log(score); // undefined

var score = 80;
console.log(score); // 80
```

> 변수의 선언과 값의 할당을 하나의 문장으로 단축표현 하더라도
> JS 엔진은 이를 2개의 문으로 나누어서 각각 실행

    변수에 undefined가 할당되어 초기화 되는 것은 변함 없음

- 중요 사실
- ┣ 값을 할당 할 때는 초기에 undefined가 저장되어 있는
- ┣ 메모리 공간을 지우고 → 할당하는 개념이 아님!!!
- ┗ `새로운 메모리 공간을 확보 후 → 그곳에 값을 저장`

> allocate Example

```js
console.log(score); // undefined

score = 80;
var score;

console.log(score); // 80이 출력됨
```

## 4.6 값의 재할당

- score 변수에 새로운 값을 재할당
- ┣ 재할당이란 이미 값이 할당되어 있는 변수에
- ┗ 새로운 값을 또다시 할당하는 것을 말함

```js
var score = 80;
score = 90;
```

> var로 선언한 변수 같은 경우는 재할당이 가능

    하지만 엄밀히 말하자면 처음에 80을 선언해도
    ┗ 이는 undefined로 초기화 되고 → 80 값을 재할당이라고 할 수 있음

- 재할당은 변수에 저장된 값을 다른 값으로 변경
- ┣ 그래서 변수라고 지칭함
- ┣ 만약 값을 재할당 불가능 하다?
- ┗ `상수(constant)`라고 부름

> const 키워드

    값을 재할당 할 수 없도록 만들어짐
    ┗ 하지만 꼭 재할당을 막기 위해서만 만들어진 것은 아님

- 재할당을 하게 되면 이전 값들은 어떤 식별자와도 연결되지 않게됨
- ┣ `(ex : undefined, 80)`
- ┣ 이런 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제
- ┗ 그러나 해제 시점은 예측 불가하다.

> 가비지 콜렉터(garbage collector)

    App이 할당(allocate) 한 메모리 공간을 주기적으로 검사
    ┣ 사용되지 않는 메모리 해제(release) 하는 기능 의미
    ┣ 재할당 하게 되면 이전 값들을 사용하지 않기 때문에
    ┣ JS는 가비지 콜렉터를 내장 → 매니지드 언어
    ┗ 가비지 콜렉터 이용해 메모리 누수(memory leak)방지

### unManaged lan , managed lan 차이

- 프로그래밍 언어 메모리 관리 방식에 따라서
- ┣ unManaged lan , managed lan 방식으로 구분 가능
- ┣ C 언어 같은 unManaged 언어는 개발자가 명시적으로
- ┗ `malloc()`, `free()`와 같은 `저수준(low-level)` 메모리 제어 기능 제공

- unManged의 경우 개발자에게 그 권한을 쥐어주어
- ┗ 최저의 성능을 확보할 수 있는 반면 → 심각한 오류도 발생 가능

- JS와 같은 managed 언어는 메모리 할당 및 해제를 위한
- ┣ 메모리 관리 기능을 언어 차원에서 담당하고
- ┣ 개발자의 직접적인 메모리 제어는 허용 X
- ┣ 개발자가 명시적으로 메모리를 할당 헤제가 불가능 하다.
- ┣ 더 이상 사용하지 않는 메모리는 자동으로 가비지 콜렉터가 해제
- ┗ 매니지드 언어는 개발자의 메모리 부담이 줄어들지만 손실 효율은 무시 할 수 없음

> unManged → 개발자 직접 메모리 관리

    효율적 관리, but 치명적 오류 가능

> managed → 프로그램이 직접 관리

    개발자 친화적, but 성능 손실

## 4.7 식별자 네이밍 규칙

- 식별자(identifier)는 어떤 값을 구별해서 식별해낼 수 있는
- ┣ 고유한 이름을 말함
- ┗ 식별자는 다음과 같은 규칙을 준수해야함

- 식별자는 `특수문자를 제외`한 `문자`, `숫자`, `언더스코어(_)`, `달러기호($)`를 포함할 수 있음
- 단, 식별자는 `특수문자를 제외`한 `문자`, `언더스코어(_)`, `달러기호($)`로 시작해야 함
- ┗ `숫자`로 시작하는 것은 허용하지 않음
- 예약어는 식별자로 사용할 수 없다.

> 예약어

| await        | break     | case          | catch    | class      | const      |
| ------------ | --------- | ------------- | -------- | ---------- | ---------- |
| continue     | debugger  | default       | delete   | do         | else       |
| enum         | export    | extends       | false    | finally    | for        |
| function     | if        | `implements*` | import   | in         | instanceof |
| `interface*` | `let*`    | new           | null     | `package*` | `private*` |
| `protected*` | `public*` | return        | super    | `static*`  | switch     |
| this         | throw     | true          | try      | typeof     | var        |
| void         | while     | with          | `yield*` |            |            |

- 변수 이름도 식별자이므로 위 네이밍 규칙을 따라야 함
- ┣ 예를 들어서 다음과 같은 식별자는 변수 이름으로 사용할 수 있음
- ┣ 변수의 경우 쉼포(,)로 구분해 하나의 문에서 여러 개를 한번에 선선할 수 있다.
- ┗ 하지만 가독성이 안좋아 지기 때문에 추천하는 방법은 아니다.

```js
var person, $elem, _name, first_name, val1;
```

- ES5부터 식별자를 만들 때 유니코드 문자를 허용하므로 알파벳 외의 한글이나
- ┣ 일본어 식별자도 가능하다.
- ┗ 알파벳 외의 유니코드 문자로 명명된 식별자를 사용하는 것은 바람직 하지 않는다.

> 유니코드 문자로 명명된 식별자를 사용하는 바람직하지 않음

```js
var 이름, 주소지;
```

> 명명 규칙에 위배되는 변수 이름

```js
var first-name;
var 1st;
var this;
```

> 대소문자를 구별하므로 다음 변수는 각각 별개의 변수다.

```js
var firstname;
var firstName;
var FIRTSTNAME;
```

> 변수의 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현

```js
var x = 3;
var score = 100;
```

- 변수 선언에 별도의 주석이 필요한 경우 변수의 존재 이유가 모호해짐

- 네이밍 컨벤션(naming convention)은 하나 이상의 영어 단어로 구성된
- ┣ 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한
- ┣ 명명규칙임
- ┣ 네이밍 컨벤션을 잘 지키면 좋은 이름을 만들어 낼 수 있음
- ┗ 4가지의 네이밍 컨벤션이 자주 이용됨

```js
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click');
```

- 일관성을 유지한다면 어떤 네이밍 컨벤션을 사용해도 좋지만 JS 에서는
- ┣ 변수, 함수 : 카멜 케이스
- ┣ 클래스의 이름 : 파스칼 케이스
- ┗ 전체 코드의 가독성을 높이기 위해서는 카멜, 파스칼 섞어서 잘 사용
