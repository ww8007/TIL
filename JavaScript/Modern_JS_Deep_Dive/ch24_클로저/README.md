# 24. 클로저

- `클로저(closure)` : 난해하기로 유명한 JS 개념 중 하나
- ┗ 실행 컨텍스트에 대한 개념이 없다면 이해하기 어려움

- JS의 고유 개념은 아니고 함수를 일급 객체로 취급하는
- ┣ 함수형 프로그래밍 언어에서 사용되는 중요한 특성
- ┗ 고유 개념이 아니므로 ECMAScript 사양에 등장하지 않음

- MDN 정의 :
- ┗ `클로저`는 `함수와 그 함수가 선언한 렉시컬 환경과의 조합`

> 핵심 키워드 : 함수가 선언된 렉시컬 환경

```js
const x = 1;

function outerFunc() {
	const x = 10;
	function innerFunc() {
		console.log(x); // 10
	}

	innerFunc();
}

outerFunc();
```

- outerFunc 함수 내부 : `중첩 함수 innerFunc가 정의되고 호출`
- ┣ 중첩 함수 innerFunc의 상위 스코프 → 외부 함수 outerFunc 스코프
- ┣ 중첩 함수 `innerFunc 내부에서 자신을 포함하고 있는 외부 함수`
- ┗ `x에 접근`이 가능함

- 만약 중첩 함수가 아니라면 innerFunc 함수를
- ┣ outerFunc 함수의 내부에서 호출한다 하더라도 outerFunc 함수의 변수에
- ┗ 접근이 불가능함

```js
const x = 1;

function outerFunc() {
	const x = 10;
	innerFunc();
}

function innerFunc() {
	console.log(x); // 1
}

outerFunc();
```

> 위와 같은 이유 : JS가 렉시컬 스코르를 따르는 프로그래밍 언어

## 24.1 렉시컬 스코프

- JS엔진 : 함수를 어디서 호출이 아닌 → 함수를 어디에 정의했는지에 따라
- ┣ 상위 스코프를 결정하게 됨
- ┗ 이를 렉시컬 스코프(정적 스코프)라고 하게 됨

```js
const x = 1;

function foo() {
	const x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo(); // ?
bar(); // ?
```

- foo, bar 함수는 모두 전역에서 정의된 전역 함수
- ┣ 함수의 상위 스코프 : 함수를 어디서 정의 했느냐에 따라 달라지므로
- ┣ foo 함수와 bar 함수의 상위 스코프 : 전역
- ┗ 함수를 어디서 호출하는지는 함수의 상위 스코프 결정에 어떠한 영향도 못줌

- ┣ 즉 : `함수의 상위 스코프` : 함수를 `정의한 위치`에 의해 `정적으로 결정`되고
- ┗ `변하지 않음`

- 스코프의 실체 : 실행 컨텍스트의 렉시컬 환경
- ┣ 렉시컬 환경 : 자신의 외부 렉시컬 환경에 대한 참조에 저장할 참조값이
- ┗ 바로 상위 렉시컬 환경에 대한 참조 → 이것이 상위 스코프

- 렉시컬 환경의 `외부 렉시컬 환경에 대한 참조에 저장할 참조값`
- ┣ 즉 : `상위 스코프에 대한 참조` : `함수 정의가 평가되는 시점`에
- ┣ 함수가 정의된 환경에 의해 결정됨
- ┗ 이것을 `렉시컬 스코프라고 부름!`

## 24.2 함수 객체의 내부 슬롯 [[Environment]]

- 함수가 정의된 환경(위치), 호출되는 환경(위치)은 다를 수 있음
- ┣ 렉시컬 스코프가 가능하기 위해서는 함수 → 자신이 호출되는 환경과 무관하게
- ┣ 상관없이 자신이 정의된 환경, 즉 : 상위 스코프(함수 정의가 위치하는 스코프가
- ┗ 바로 상위 스코프다)라는 것을 기억해야 함

- 함수 : 자신의 `내부 슬롯 [[Environment]]`에 자신이 정의된 환경
- ┗ → `상위 스코프의 참조를 저장`하게 됨

- 함수 정의가 평가되어 `함수 객체를 생성` :
- ┣ 자신이 정의된 환경(위치)에 의해 결정된 `상위 스코프의 참조`를
- ┣ 함수 객체 자신의 `내부 슬롯 [[Environment]]에 저장`
- ┣ 자신의 내부 슬롯 [[Environment]]에 저장된 상위 스코프의 참조 :
- ┗ 현재 실행 중인 실행 `컨텍스트의 렉시컬 환경`을 가리킴

- 함수 정의가 평가되어 함수 객체 생성 시점 :
- ┣ 함수가 정의된 환경 → `1. 상위 함수(또는 전역 코드)가 평가` 또는
- ┣ 2. `실행되고 있는 시점`
- ┣ 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킴
- ┗ 실행 컨텍스트 : 상위 함수(또는 전역 코드)의 실행 컨텍스트이기 때문

- ex ) `전역에서 정의된 함수 선언문` : `전역 코드가 평가되는 시점`에
- ┣ `평가되어 함수 객체를 생성`함
- ┣ 생성된 함수 객체의 내부 슬롯 [[Environment]]에는 함수 정의가 평가되는 시점
- ┣ 전역 코드 평가 시점에 실행 중인 실행 컨텍스트의 `렉시컬 환경인 전역`
- ┗ 렉시컬 환경의 참조가 저장됨
- 따라서 : `함수 객체의 내부 슬롯 [[Environment]]에 저장`된
- ┣ 현재 실행 중인 → `실행 컨텍스트의 렉시컬 환경의 참조` : 상위 스코프
- ┣ 또는 : `자신이 호출되었을 때 생성될 렉시컬 환경`의 →
- ┣ 외부 렉시컬 환경에 대한 참조에 저장될 참조값
- ┣ 함수 객체 : 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조
- ┗ 즉 → 상위 스코프를 자신이 존재하는 한 기억

```js
const x = 1;

function foo() {
	const x = 10;

	// 상위 스코프 : 함수 정의 환경(위치)에 따라 결정됨
	// 함수 호출 위치와 상위 스코프 : 아무런 관계 없음
	bar();
}

// 함수 bar는 자신의 상위 스코프, 즉 : 렉시컬 환경을
// [[Environment]]에 저장하여 기억하게 됨
function bar() {
	console.log(x);
}

foo();
bar();
```

- foo 함수, bar 함수 : 모두 `전역에서 함수 선언문`으로 정의
- ┣ 따라서 : foo 함수, bar 함수는 모두 `전역 코드가 평가되는 시점`에 평가
- ┗ `함수 객체를 생성` → `전역 객체 window의 메서드`가 됨

- 이때 생성된 함수 객체의 내부 슬롯 : [[Environment]]에는
- ┣ 함수 정의가 평가된 시점, 즉 → 전역 코드 평가 시점에 실행 중인
- ┗ 실행 컨텍스트의 렉시컬 환경인 전역 렉시컬 환경의 참조가 저장

- 함수 호출 : 함수 내부 코드로 코드의 제어권이 이동
- ┣ 함수 코드를 평가하기 시작
- ┗ 코드 평가의 순서

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
   - 2.1 함수 환경 레코드 생성
   - 2.2 this 바인딩
   - 2.3 외부 렉시컬 호나경에 대한 참조 결정

- `외부 렉시컬 환경에 대한 참조` : `함수 객체의 내부 슬롯`
- ┣ [[Environment]]에 `저장된 렉시컬 환경의 참조가 할당`
- ┣ 즉 : 함수 객체의 내부 슬롯 [[Environment]]에 저장된 `렉시컬 환경의 참조` :
- ┗ `함수의 상위 스코프를 의미`

> 함수 결정의 위치에 따라 상위 스코프를 결저앟는
> 렉시컬 스코프의 실체

## 24.3 클로저와 렉시컬 환경

```js
const x = 1;

// 1
function outer() {
	const x = 10;
	const inner = function () {
		console.log(x);
	}; // 2
	return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환
// 그리고 outer 함수의 실행 컨텍스트 : 실행 컨텍스트 스택에서
// 팝되어 제거됨
const innerFunc = outer(); // 3
innerFunc(); // 4
```

- outer 함수를 호출(3)하면 → outer 함수는 중첩 함수 inner를 반환하고
- ┣ 생명 주기(life cycle)를 마감
- ┣ outer 함수의 실행이 종료되면 → outer 함수의 실행 컨텍스트 :
- ┣ 실행 컨텍스트 스택에서 제거되게 됨
- ┣ outer 함수의 실행 컨텍스트 제거 →
- ┣ outer 함수의 지역 변수 x 또한 생명 주기를 마감
- ┗ outer 함수의 지역 변수 x 더이상 유효하지 않게 보임

> 하지만 4번에서 보면 잘 동작함

- `외부 함수보다 중첩 함수가 더 오래 유지`되는 경우 :
- ┣ 중첩 함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조 가능
- ┗ 이를 `클로저(closure)`라고 부름

- `클로저` : `함수`와 그 `함수가 선언된 렉시컬 환경`과의 조합
- ┣ 함수가 정의된 `렉시컬 환경` → `함수가 정의된 위치의 스코프`
- ┗ 즉 : 상위 스코프를 의미하는 실행 컨텍스트의 렉시컬 환경을 말함

- JS의 모든 함수 : `자신의 상위 스코프를 기억`함
- ┣ 모든 함수가 기억하는 상위 스코프 : `함수를 어디서 호출하든 상관없이 유지`
- ┣ 함수를 어디서 호출하든 상관없이 함수 → 언제나 자신이 기억하는
- ┗ 1. `식별자를 참조`할 수 있으며 2. `식별자에 바인딩된 값을 변경`할 수 있음

- inner 함수 : 자신이 평가될 때 자신이 정의된 위치에 의해 결정된
- ┣ 상위 스코프 → [[Environment]] 내부 슬롯에 저장함
- ┗ 이때 저장된 상위 스코프 : 함수가 존재하는 한 유지

- ex ) outer 함수가 평가되어 → 함수 객체를 생성할 때 - 1
- ┣ 현재 실행 중인 실행 컨텍스트의 렉시컬 환경
- ┣ 즉 : 전역 렉시컬 환경 → outer 함수 객체의 [[Environment]] 내부 슬롯에
- ┗ 상위 스코프로서 저장하게 됨

- outer 함수를 호출 → outer 함수의 렉시컬 환경이 생성되고 앞서
- ┣ 함수 객체의 [[Environment]] 내부 슬롯에 저장된 전역 렉시컬 환경
- ┗ outer 함수 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 할당

- 그리고 중첩 함수가 평가 → inner의 경우 함수 표현식으로 정의 :
- ┣ 런타임에 평가가 이루어지게 됨
- ┣ 이때 : 중첩 함수 inner : 자신의 [[Environment]] 내부 슬롯에
- ┣ 현재 실행 중인 실행 컨텍스트 렉시컬 환경
- ┗ 즉 : outer 함수의 렉시컬 환경을 상위 스코프로서 저장

- outer 함수의 실행이 종료 : `inner 함수를 반환`
- ┣ outer 함수의 생명 주기가 종료
- ┣ outer 함수의 실행 컨텍스트 : `실행 컨테스트 스택에서 제거`되지만
- ┗ `outer 함수의 렉시컬 환경까지 소멸되는 것은 아님`

- outer 환경의 렉시컬 환경 :
- ┣ 1. inner 함수의 [[Environment]] 내부 슬롯에 의해 참조,
- ┣ 2. 전역 변수 innerFunc에 의해 참조되고 있음
- ┣ → 고로 가비지 컬렉션의 대상이 되지 않음
- ┗ `가비지 컬렉터는 누군가가 참조하고 있는 메모리 공간 해제 X`

> 가비지 컬렉터 : 누군가 참조 → 메모리 공간 해제 X

- outer 함수가 반환한 inner 함수를 호출하면 :
- ┣ 1. inner 함수의 실행 컨텍스트가 생성
- ┣ 2. 실행 컨텍스트 스택에 푸시됨
- ┣ 3. 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에는
- ┣ inner 함수 객체의 [[Environment]] 내부 슬롯에 저장되어 잇는
- ┗ 참조값이 할당됨

- 중첩 함수 inner : 외부 함수 outer보다 더 오래 생존
- ┣ 외부 함수보다 더 오래 생존한 중첩 함수 :
- ┣ `외부 함수의 생존 여부(실행 컨텍스트의 생존)와 관계없이`
- ┣ 자신이 `정의된 위치에 의해` `결정된 상위 스코프를 기억`함
- ┣ `중첩 함수` inner `내부`에서 `상위 스코프를 참조`할 수 있으므로
- ┣ `상위 스코프의 식별자를 참조`할 수 있고
- ┗ `식별자의 값을 변경` 가능

- JS의 모든 함수 : 상위 스코프를 기억하게 되므로
- ┣ 이론적으로 모두 클로저이다!
- ┗ 하지만 모든 함수를 클로저라고 부르지는 않는다.

> 상위 스코프의 어떤 식별자도 참조하지 않는 함수는
> 클로저가 아님!

- `상위 스코프의 어떤 식별자도 참조하지 않는 경우` :
- ┣ 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억 안함
- ┗ `참조하지도 않는 식별자를 기억하는 것은 낭비`

```js
function foo() {
	const x = 1;

	// bar 함수는 클로저였지만 곧바로 소멸
	// 이러한 함수 일반적으로 클로저라고 하지 않음
	function bar() {
		debugger;
		// 상위 스코프의 식별자를 참조
		console.log(x);
	}
	bar();
}
foo();
```

- 위 예제의 중첩 함수 bar : 상위 스코프의 식별자를 참조
- ┣ 즉 : 클로저의 목적에 부함
- ┣ 그러나 → 외부 함수 foo의 외부로 중첩 함수가 bar가 `반환되지 않음`
- ┣ 즉 : `외부 함수 foo보다 중첩 함수 bar 생명 주기가 짧음`
- ┣ 이런 경우 중첩 함수 bar : 클로저였지만 외부 함수보다 일찍 소멸됨
- ┣ 그렇기에 `[생명 주기가 종료된 외부 함수의 식별자를 참조 가능함]`의
- ┗ `클로저의 본질에 부합하지 않음`

```js
function foo() {
	const x = 1;
	const y = 2;

	// 클로저
	// 중첩 함수 bar : 외부 함수보다 더 오래 유지되며
	// 상위 스코프의 식별자를 참조
	function bar() {
		debugger;
		console.log(x);
	}
	return bar;
}

const bar = foo();
bar();
```

- 중첩 함수 bar : 상위 스코프의 식별자를 참조하고 있음
- ┣ 고로 클로저임
- ┗ 또한 : 외부 함수의 외부로 반환 → 외부 함수보다 오래 살아남음

- 이처럼 외부 함수보다 중첩 함수가 더 오래 유지되는 경우
- ┣ 중첩 함수 : 이미 생명 주기가 종료된 외부 함수의 변수를 참조 가능
- ┗ 이러한 중첩 함수 : 클로저라고 부름

- ┣ 클로저 : 1. `중첩 함수가 상위 스코프의 식별자를 참조`하고 있고
- ┗ 2. `중첩 함수가 외부 함수보다 더 오래 유지되는 경우`에 한정하는 것이 일반적

> 위 예제 처럼 상위 스코프 식별자 중 하나만 참조하게 될 경우
> 최적화를 위해서 클로저가 참조하고 있는 식별자만 기억하게 됨

- 클로저에 의해 참조되는 상위 스코프의 변수 (위에서 x)를
- ┣ `자유 변수(free variable)`이라고 부름
- ┣ `클로저(closure)` : 함수가 자유변수에 대해 닫혀 있다는 의미
- ┗ 해석 : 자유 변수에 묶여있는 함수

- 이론적으로 상위 스코프를 기억한다는 점이 불필요한 메모리의 점유를 걱정 가능
- ┗ 하지만 필요한 것만 JS엔진이 알아서 기억하기 때문에 걱정 X

## 24.4 클로저의 활용

- 클로저 : 1. `상태(state)를 안전하게 변경`하고
- ┣ 2. `유지하기 위해서 사용`
- ┣ 고로 상태가 의도치 않게 변경되지 않도록
- ┣ `상태를 안전하게 은닉(information hiding`)하고
- ┗ `특정 함수에게만 상태 변경을 허용` 위해 사용

> 함수가 호출될 때마다 호출된 횟수를 누적하여 출력하는 카운터

```js
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function () {
	// 카운트 상태를 1만크 ㅁ증가
	return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- 코드는 잘 동작하지만 문제가 생길 여지가 있음

1. 카운트 상태(num 변수의 값)는 increase 함수가 호출되기 전까지

   - ┗ 변경되지 않고 유지되어야 함

2. 이를 위해 카운트 상태(num 변수의 값)는 increase 함수만이
   - ┗ 변경할 수 있어야 함

- 카운트 상태 : 전역 변수를 통해 관리되고 있기 때문에
- ┣ 언제든지 누구나 접근할 수 잇고 변경할수 있음(암묵적 결합)
- ┗ 이로 인해서 의도치 않게 상태가 변경될 수 있음

- 이를 안전하게 이용하기 위해서는
- ┗ increase 함수만이 num 변수를 참조하고 변경 할 수 있게 하는 것이 바람직

```js
// 카운트 상태 변경 함수
const increase = function () {
	// 카운트 상태 변수
	let num = 0;

	// 카운트 상태를 1만큼 증가
	return ++num;
};
```

> 하지만 위의 경우 상태 변경은 방지 했지만
> 지역 변수로 동작하여서 원하는 대로 동작하지 않음

> 고로 클로저를 사용

```js
// 카운트 상태 변경 함수
const increase = (function () {
	// 카운트 상태 변수
	let num = 0;

	// 클로저
	return function () {
		// 카운트 상태를 1만큼 증가시킴
		return ++num;
	};
})();

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- 위 코드를 실행 하게 되면
- ┣ 1. `즉시 실행 함수가 호출`되고
- ┣ 2. `즉시 실행 함수가 반환한 함수가 increase 변수에 할당`
- ┣ increase 변수에 할당된 함수 : `자신이 정의된 위치`에 의해
- ┗ 결정된 상위 스코프인 → `실행 함수의 렉시컬 환경을 기억하는 클로저`

- `즉시 실행 함수` : `호출된 이후 소멸`
- ┣ 실행 함수가 반환한 클로저 : increase 변수에 할당되어 호출
- ┣ 이때 즉시 실행 함수가 반환된 클로저 : `자신이 정의된 위치`에 의해
- ┣ 결정된 `상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억`
- ┣ 즉시 실행 함수가 반환한 클로저 : 카운터 상태를 유지하기 위해서
- ┗ `자유 변수` num을 언제 어디서든지 `호출, 참조, 변경 가능`

- 즉시 실행 함수는 한 번만 실행되기 때문에
- ┣ increase가 호출될 때마다 num 변수가
- ┣ `재차 초기화 되는일은 없음`
- ┣ 또한 : num 변수는 `외부에서 직접 접근할 수 없는`
- ┣ `은닉화된 private 변수`이므로
- ┣ 전역 변수를 사용했을 때와
- ┣ 같이 `의도되지 않은 변경을 걱정할 필요가 없기 때문에`
- ┗ 더욱더 안전한 프로그래밍이 가능하다.

> 클로저 : 상태가 의도적으로 변경되지 않도록 은닉(information hiding)
> 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고
> 유지하기 위해 사용됨

```js
const counter = (function () {
	// 카운트 상태 변수
	let num = 0;

	// 클로저인 메서드를 갖는 객체를 반환
	// 객체 리터럴은 스코프를 만들지 않음
	// 따라서 안래 메서드들의 상위 스코프 :
	// 즉시 실행 함수의 렉시컬 환경임
	return {
		// num: 0 // 프로퍼티는 public 하므로 은닉 X
		increase() {
			return ++num;
		},
		decrease() {
			return num > 0 ? --num : 0;
		},
	};
})();

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2

console.log(counter.decrease()); // 1
console.log(counter.decrease()); // 0
```

- 위 예제 : 즉시 실행 함수가 반환하는 `객체 리터럴` :
- ┣ `즉시 실행 함수의 실행 단계에서 평가되어 객체가 됨`
- ┣ 객체의 메서드도 함수 객체로 생성됨
- ┣ `객체 리터럴의 중괄호` → `코드 블록이 아니므로`
- ┗ 별도의 스코프를 생성하지 않음

- 위 예제의 `increase, decrease 메서드의 상위 스코프` :
- ┣ increase, decrease `메서드가 평가되는 시점`에
- ┣ `실행중인 실행 컨텍스트인 즉시 실행 함수 실행 컨텍스트`의
- ┗ `렉시컬 환경`임

- ┣ 따라서 → increase, decrease `메서드가 언제 어디서 호출`되는
- ┣ 상관없이 increase, decrease 함수는 `즉시 실행 함수의 스코프의 식별자`를
- ┗ `참조가 가능`함

```js
const Counter = (function () {
	// 1 카운트 상태 변수
	let num = 0;

	function Counter() {
		// this.name = 0; // 2. 프로퍼티는 public 하므로 은닉 X
	}

	Counter.prototype.increase = function () {
		return ++num;
	};

	Counter.prototype.decrease = function () {
		return num > 0 ? --num : 0;
	};

	return Counter;
})();

const counter = new Counter();
```

- 위 예제 num(1)은 생성자 함수 Counter가 생성할 인스턴스의 프로퍼티가 아니라
- ┣ 즉시 실행 함수 내에서 선언된 벼수
- ┣ 만약 : num이 생성자 함수 Counter가 생성할 인스턴스의 프로퍼티라면
- ┣ public → 은닉 변수가 아니게 됨
- ┗ 고로 즉시 실행 함수내에 변수를 선언하여 사용

- 생성자 함수 Counter : 프로토타입을 통해 `increase, decrease 메서드를 상속`
- ┣ 받는 인스턴스를 생성하게 됨
- ┣ 모두 자신의 함수 정의가 평가되어 → `함수 객체가 될 때`
- ┣ 실행 중인 실행 컨텍스트인 즉시 실행 함수 실행 컨텍스트의
- ┣ `렉시컬 환경을 기억하는 클로저`임
- ┣ 프로토타입을 통해 `상속되는 프로토타입 메서드일지라도`
- ┣ 즉시 실행 함수의 `자유 변수 num을 참조가 가능함`
- ┗ num 변수의 값은 increase, decrease 메서드 만이 변경이 가능함

- 변수 값이 의도치 않게 변경되는 것은 `가변(mutable)` 데이터를 피하고
- ┣ `불변성(immutability)`을 지향하는 함수형 프로그래밍에서 부수 효과를
- ┣ 최대한 억제하여 오류를 피하고
- ┗ 프로그램의 안전성을 높이기 위해 클로저는 적극적으로 사용됨

```js
// 함수를 인수로 전달받고 함수를 반환하는 고차 함수
// 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환
function makeCounter(predicate) {
	// 카운트 상태를 유지하기 위한 자유 변수
	let counter = 0;

	// 클로저를 반환
	return function () {
		// 인수로 전달받은 보조 함수에 상태 변경을 위임
		counter = predicate(counter);
		return counter;
	};
}

// 보조 함수
function increase(n) {
	return ++n;
}

// 보조 함수
function decrease(n) {
	return --n;
}

// 함수로 함수를 생성
// makeCounter 함수 : 보조 함수를 인수로 전달받아 함수를 반환
const increaser = makeCounter(increase); // 1
console.log(increaser()); // 1
console.log(increaser()); // 2

// increaser 함수완느 별개의 독립된 렉시컬 환경을 갖기 때문에
// 카운터 상태가 연됭하지 않음
const decreaser = makeCounter(decrease); // 2
console.log(decreaser()); // -1
console.log(decreaser()); // -2
```

- makeCounter 함수 : 1. 보조 함수를 인자로 전달받고
- ┣ 2. `함수를 반환하는 고차 함수`임
- ┣ makeCounter 함수가 반환하는 함수 :
- ┣ 자신이 `생성됐을 때의 렉시컬 환경`인 `makeCounter 함수의 스코프에 속한`
- ┗ `counter 변수를 기억하는 클로저`임

- makeCounter 함수 : 인자로 전달받은 보조 함수를 합성하여
- ┣ `자신이 반환하는 함수의 동작을 변경이 가능`하다.
- ┣ makeCounter `함수를 호출해 함수를 반환할 때 반환된 함수` :
- ┣ `자신만의 독립된 렉시컬 환경을 갖는다는 것`
- ┣ 이는 : `함수를 호출하면 그때마다 새로운 makeCounter 함수 실행 컨텍스트`의
- ┗ `렉시컬 환경이 생성`되기 때문임

- makeCounter 함수를 호출하면 makeCounter 함수의 실행 컨텍스트가 생성
- ┣ makeCounter 함수 : 함수 객체를 생성하여 반환한 후 소멸
- ┣ makeCounter 함수가 반환한 함수 : makeCounter 함수의 렉시컬 환경을
- ┣ 상위 스코프로서 기억하는 클로저이며, 전역 변수인 increaser에 할당
- ┣ 이때 makeCounter 함수의 실행 컨텍스트는 소멸되지만
- ┣ makeCounter 함수 실행 컨텍스트의 렉시컬 환경 :
- ┣ makeCounter 함수가 반환한 함수의 [[Environment]] 내부 슬롯에 의해
- ┗ 참조되고 있기 때문에 소멸되지 않음

- makeCounter 함수를 호출하면 → 새로운 makeCounter 함수의 실행 컨텍스트 생성
- ┣ 그리고 : 함수 객체를 생성하여 반환하고 소멸
- ┣ 반환한 함수 → makeCounter 함수의 렉시컬 환경을 상위 스코프로 기억하는 클로저
- ┣ 전역 변수 decrease에 핼당
- ┗ 이또한 반환 함수의 [[Environment]] 내부 슬롯에 참조 → 소멸 X

> 고로 다른 렉시컬 환경을 가지기 때문에
> 자유 변수 counter를 공유하지 않아서
> 원하는대로 동작 하지 않음
> → 렉시컬 환경을 공유하는 클로저 생성

```js
// 함수를 반환하는 고차 함수
// 이 함수느 : 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는
// 클로저를 반환하게됨
const counter = (function() {
    // 카운트 상태를 유지하기 위한 자유 변수
    let counter = 0;

    // 함수를 인수로 전달받는 클로저를 반환
    return function (predicate) {
        // 인수로 전달받은 보조 함수에 상태 변경을 위임
        counter predicate(counter);
        return counter;
    }
}());

// 보조 함수
function increase(n) {
    return ++n;
}

// 보조 함수
function decrease(n) {
    return --n;
}

// 보조 함수를 전달하여 호출
console.log(counter(increase)); // 1
console.log(counter(increase)); // 2

// 자유 변수를 공유
console.log(counter(decrease)); // 1
console.log(counter(decrease)); // 0
```

## 24.5 캡슐화와 정보 은닉

- `캡슐화(encapsulation)` : 객체의 상태를 나타내는
- ┣ 1. 프로퍼티와, 2. 메서드(프로퍼티를 참조하고 조작 가능한 동작)
- ┗ 하나로 묶는 것을 뜻함

> 캡슐화 : 객체의 프로퍼티나 메서드 감출 목적으로 사용
> 이를 은닉(information hiding)이라고 함

- 정보 은닉 : 외부에 공개할 필요가 없는 것들을 감추어
- ┣ 1. 객체의 상태 변경 방지
- ┣ 2. 객체 간의 상호 의존성
- ┗ 3. 결합도(coupling)를 낮추는 효과가 있음

- 대부분의 객체지향 프로그래밍 언어 : 클래스를 정의
- ┣ `public`, `private`, `protected` 등의 `접근 제한자를 사용`해서
- ┗ 공개 범위를 한정이 가능함

> 메서드를 프로토타입 메서드로 변경하여 sayHi 메서드의 중복 생성을 방지

```js
function Person(name, age) {
	this.name = name; // public
	let _age = age; // private
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
	// Person 생성자 함수의 지역 변수 _age
	// 참조가 불가능하다.
	console.log(`Hi! My name is ${this.name}. I am ${_age}`);
};
```

- 이때 Person.prototype.sayHi 메서드 내에서
- ┣ Person 생성자 함수의 지역 변수 `_age참조 불가`의 문제 발생
- ┗ `즉시 실행 함수를 사용해서 이를 해결`
