# 목차

- [11 원시 값과 객체의 비교](#11-%EC%9B%90%EC%8B%9C-%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90)
  - [11.1 원시 값](#111-%EC%9B%90%EC%8B%9C-%EA%B0%92)
    - [11.1.1 변경 불가능한 값](#1111-%EB%B3%80%EA%B2%BD-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%92)
    - [11.1.2 문자열과 불변성](#1112-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC-%EB%B6%88%EB%B3%80%EC%84%B1)
    - [11.1.3 값에 의한 전달](#1113-%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%AC)
  - [11.2 객체](#112-%EA%B0%9D%EC%B2%B4)
    - [11.2.1 변경 가능한 값](#1121-%EB%B3%80%EA%B2%BD-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%92)
    - [11.2.2 참조에 의한 전달](#1122-%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%AC)

# 11 원시 값과 객체의 비교

- 6장에서 JS가 제공하는 7개의 데이터 타입
- ┣ 숫자, 문자열, 불리언, null, undefined, 심벌, 객체
- ┣ 이들은 크게 `원시(primitive type)`와 `객체(object, reference)`
- ┗ 타입으로 구분 가능하다.

> 그러면 왜 이들을 원시와 객체로 분리를 할까

1. 원시 타입의 값 → 원시 값은 변경 불가능한 immutable value 값
   ┗ 이에 반해서 객체 타입 → 변경 가능 mutable value

2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값 저장

   - ┗ 이에 반해서 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장

3. 원시 값을 갖는 변수를 다른 변수에 할당하면 `원본의 원시 값이 복사되어 전달`
   - ┣ 이를 `값에 의한 전달(pass by value)`라고 함
   - ┣ 이에 반해서 객체를 가르키는 변수 → 다른 변수에 할당시
   - ┣ 원본의 참조 값이 복사되어 전달
   - ┗ 이를 `참조에 의한 전달(pass by reference)`

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- `원시 타입(primitive type)`의 값, 원시 값 → 변경 불가능한 `immutable value`
- ┣ 다시 말해 한번 생성된 원시 값은 `읽기 전용(read only)`으로 값을 변경 불가
- ┗ 값을 변경할 수 없다는 것이 의미하는 바는?
- `변수`와 `값`은 `구분해서 생각`해야 함
- ┣ 1. `변수` : 하나의 값을 저장하기 위해
- ┣ 확보한 메모리 공간 자체 또는 그 메모리 공간을
- ┗ 식별하기 위해서 사용된 이름
- ┣ 2. `값` : `변수`에 저장된 데이터로서
- ┗ 표현식에 의해 평가되어 생성된 결과

> 변경 불가능 하다는 것은 `변수`가 아닌 `값`에 대한 진술

- `원시 값`을 변경 불가 → 원시 값 자체를 변경할 수 없다는 점
- ┣ `변수` 값을 변경할 수 없다는 것이 아님
- ┣ `변수`는 언제든지 재할당을 통해 변경(교체) 할 수 있음
- ┗ 그렇기 떼문에 `변수`라고 함

- 변수의 상대 개념인 `상수`는 재할당이 금지된 변수를 뜻함
- ┣ `상수`도 값을 저장하기 위한 메모리 공간이 필요 → 변수라고 할 수 있음
- ┣ 그러나 변수 : 언제나 재할당을 통해 변경(교체) 가능하지만
- ┣ `상수` : `단 한번만 할당`이 허용되고 변수 값을 변경(교체)불가
- ┗ `상수와 변경 불가능한 값을 동일시 하는 것은 곤란`

> 상수 : 재할당이 금지된 변수일 뿐

- 원시 값은 변경 불가능한 값 → 읽기 전용 값
- ┗ 원시 값은 어떤 일이 있어도 불변

> 이러한 원시 특성은 데이터의 신뢰성을 보장

- 값의 할당에서 보았듯 원시 값을 할당한 `변수`에
- ┣ 새로운 원시 값을 재할당하면 메모리에 저장되어 있는
- ┣ 재할당 이전의 원시 값을 변경하는 것이 아닌
- ┣ 새로운 메모리 공간을 확보 → 재할당한 원시 값 저장
- ┣ `변수` : 새롭게 재할당한 원시 값을 가르킴
- ┗ 이 때 `변수`가 참조하던 `메모리 공간의 주소가 바뀜`

- 변수가 참조하던 `메모리 공간의 주소가 변경`된 이유
- ┣ 변수에 할당된 원시 값이 변경 불가능한 값이기 때문
- ┣ 원시 값이 변경 가능 → 변수에 새로운 원시 값 재할당할 경우
- ┣ 변수가 가르키던 메모리 공간의 주소를 바꿀 필요 없이
- ┣ 원시 값 자체를 변경하면됨
- ┗ 이 경우에는 변수가 참조하던 메모리 공간의 주소는 안바뀜

- 그러나 `원시 값`은 `변경 불가능한 값`이기 때문에 값을 `직접 변경 불가`
- ┣ 그렇기에 변수 값을 변경하기 위해 `원시 값을 재할당` 하면
- ┣ → `새로운 메모리 공간 확보` → `재할당한 값을 저장`
- ┣ → 변수가 참조하던 `메모리 공간의 주소`를 변경
- ┗ 값의 이러한 특성을 `불변성`

- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에
- ┣ 변수 값을 변경할 수 잇는 방법이 없음
- ┣ 만약 재할당 이외에 원시 값인 변수 값을 변경할 수 있다면
- ┣ 예기치 않게 변수 값이 변경될 수 있다는 것을 의미
- ┗ 이는 값의 변경 → 상태 변경을 추적하기 어렵게 만듬

### 11.1.2 문자열과 불변성

- 원시 값을 저장하기 위해서는 확보해야 하는 메모리 공간의 크기를 결정
- ┣ 이를 위해 원시 타입별로 메모리 크기가 미리 정해져 잇음
- ┣ 단 ECMAScript 사양에 `문자열 타입(2바이트)`, `숫자 타입(8바이트)`
- ┣ 이외의 원시 타입은 크기를 명확히 규명하지 않음
- ┗ `브라우저 별로 달라질 수 있다는 의미!!!`

- 원시 값인 문자열은 다른 원시 값과 비교할 때 독특한 특징이 존재
- ┣ 문자열은 0개 이상의 `문자(character)`로 이루어진 집합
- ┣ 1개의 문자는 2바이트 메모리 공간에 저장
- ┣ 그렇기에 문자열은 몇 개의 문자로 이루어졌냐 → 메모리 크기 공간 지정
- ┣ `숫자 값`은 1도 100000도 `동일한 8바이트` 문자열의 경우
- ┗ 몇 글자로 이루어졌냐에 따라서 그 크기가 달라지게 된다.

- 이러한 이유로 C에는 하나의 문자를 위한 데이터 타입 → char만
- ┣ 있을 뿐 문자열 타입 존재 X → 문자열을 문자의 배열로 처리
- ┗ JAVA에서는 String 깩체로 처리

- JS 에서는 개발자의 편의를 위해서 원시 타입인 문자열 타입을 제공
- ┣ 이는 JS의 장점 중 하나
- ┣ JS 문자열 : 원시 타입, 변경 불가
- ┗ 이는 문자열이 생성된 뒤 변경할 수 없음을 의미

```js
var str = 'Hello';
str = 'world';
```

- 첫 번째 문이 실행되면 Hello가 생성되고
- ┣ 식별자 str은 문자열 Hello가 저장된 메모리 공간의
- ┣ 첫 번째 메모리 셀 주소를 가르킴
- ┣ 두 번째 문이 실행되면 이전에 생성된 문자열을 수정하는 것이 아닌
- ┣ 새로운 문자열 'world'를 메모리에 생성하고
- ┣ 식별자 str은 이를 가르키게 됨
- ┗ 이 때 문자열 Hello, 'world'는 모두 메모리에 존재

> 식별자가 어느 메모리의 첫 셀 주소를 가르키게 되는지가 차이점이다!!!

- 문자열은 유사 배열 객체이면서 이터러블 이기 때문에
- ┗ 배열과 비슷하게 각 문자에 접근이 가능하다.

- `유사 배열 객체(array like object)`
- ┣ `유사 배열 객체` : 1. 마치 배열처럼 `인덱스로 프로퍼티 접근` 가능
- ┣ 2. `length` 프러퍼티를 갖는 객체를 뜻함
- ┣ 문자열 : 배열처럼 인덱스를 통해 각 문자 접근 가능
- ┣ `length` 프로퍼티를 가지기 때문에
- ┣ `유사 배열 객체` 이며
- ┗ `for문을 통한 순회`가 가능하다.

> 원시 값인 문자열이 객체일 수도 있다는 말이 혼동될 수 있지만
>
> > 원시 값을 객체처럼 사용하면 원시 감싸는 래퍼 객체로 자동 변환된다는 점 기억

```js
var str = 'string';

// 문자열은 유사 배열이기 때문에 배열과 유사하게 인덱스를 사용해 각 문자 접근 가능
// 그러나 문자열은 원시 값이기 때문에 변경 불가, 에러도 발생하지 않음
str[0] = 'S';

console.log(str); // string
```

- `str[0] = 'S'` 처럼 이미 생성된 문자열 일부를 변경해도 변경 X
- ┣ 문자열은 변경 불가능한 값이기 때문
- ┣ 한 번 생성된 문자열은 읽기 전용 값으로서 변경 불가
- ┣ `원시 값`은 어떤 일이 있어도 `불변`
- ┗ 이는 예기치 못한 변경 에서 자유롭다 → 데이터 신뢰성 보장

- 변수에 새로운 `문자열을 재할당하는 것`은 물론 가능
- ┣ 이는 기존 문자열을 변경하는 것이 아닌
- ┗ `새로운 문자열을 재할당` 하는 것 이기 때문!!!

### 11.1.3 값에 의한 전달

- `변수에 원시 값을 갖는 변수를 할당`하면
- ┣ `변수(copy)`에는 할당되는 변수(score)의 `원시 값`이
- ┣ `복사되어 전달`됨
- ┗ 이를 `값에 의한 전달`이라고 함

> 이를 착각하여 둘이 같은 메모리 주소를 가진다고 할 수 있지만

    둘은 값만 같고 엄연히 다른 메모리 공간에 저장된다

```js
var score = 80;

// copy 변수에 score 변수의 값 80이 복사되어 할당
var copy = score;

console.log(score === copy); // true

copy = 100;

console.log(score === copy); // false
```

> 둘 이 다른 메모리 공간에 저장된 별개의 값 임을 잊지 말자

- 하지만 이에 대한 개념은 ECMAScript에 공식적으로 실린 의미가 아님
- ┣ python의 경우 둘이 같은 메모리 공간을 공유하다 → 다른 변수에 재할당 하면
- ┣ 다른 메모리 공간 공유
- ┣ `값에 의한 전달` 이라는 용어도 등장하지 않음
- ┗ `값에 의한 전달`, `참조에 의한 전달` → `공유에 의한 전달` 이라고도 사용

- 식별자 : 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름
- ┣ 값 : 메모리 공간에 저장
- ┣ 따라서 식별자는 메모리 공간에 저장되어 있는 값을 구별 가능해야 하므로
- ┗ `변수와 같은 식별자`는 값이 아닌 `메모리 공간을 기억`!!!

> 식별자로 값을 구별해서 식별 : 식별자가 기억하고 잇는 메모리 공간 주소

    이를 통해서 메모리 공간에 저장된
    ┣ 값에 접근할 수 있다는 의미임
    ┗ 식별자 : 메모리 주소에 붙인 이름

```js
var x = 10;
```

- 위 예제의 경우 `할당 연산자`는 숫자 리터럴 10에 의해 생성된
- ┣ `숫자 값 10`이 저장된 `메모리 공간의 주소를 전달`함
- ┗ 이를 통해 `식별자 x`는 메모리 공간에 저장된 숫자 값 10을 `식별가능`

```js
var copy = score;
```

- 위 예제의 경우 score는 식별자 표현식으로서 숫자 값 80으로 평가
- ┗ 이때 두 가지 평가 방식이 가능

1. 새로운 80을 생성(복사)해서 메모리 주소를 전달
   ┗ 이 방식의 경우 두 변수가 기억하는 메모리 주소가 다름

2. score 변수값 80의 메모리 주소를 그대로 전다
   ┗ 할당 시점에 두 변수가 기억하는 메모리 주소가 같음

- 이처럼 값의 의한 전달 : 사실은 값을 전달하는 것이 아닌
- ┣ `메모리 주소를 전달`!!!
- ┗ 단 전달된 메모리 주소를 통해 메모리 공간 접근 → 값을 참조 가능

- 중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 할당 시점이든
- ┣ 두 변수 중 어느 하나라도 재할당 하는 시점이든
- ┣ 결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된
- ┗ 별개의 값이 되어 한쪽에서 재할당을 하더라도 간섭 불가하다는 점!

## 11.2 객체

- 객체는 `프로퍼티`의 개수가 정해져 있지 않으며
- ┣ `동적`으로 추가되고 삭제 가능
- ┣ 또한 `프로퍼티`의 값이 제약이 없음
- ┣ 따라서 `객체`는 `원시 값과 같이` 확보해야 할 `메모리 공간의 크기`를
- ┗ `사전에 정해둘 수 있음`

- 객체는 복합적인 자료구조인 객체를 관리하는 방식이 원시 값과 비교해서
- ┣ 구현 방식도 제조사 마다 다르고 복잡하다.
- ┣ `원시 값` : 상대적으로 적은 메모리 소비
- ┣ `객체` : 경우에 따라 클 수 있음
- ┗ 객체를 생성하고 `프로퍼티`에 접근하는 경우 비용이 많이 듬

- 객체는 이렇기에 원시 값과 다른 방식으로 동작하도록 설계되어 있음

- JS에서 객체의 관리 방식
- ┣ JS 객체는 `프로퍼티` 키를 인덱스로 사용하는
- ┣ 해시 테이블(hash table) : 연관 배열(associative array, map,
- ┣ dictionary, lookup table) 이라고 생각 가능
- ┣ 대부분의 JS 엔진은 해시 테이블과 유사한 성능을 위해
- ┗ 일반적인 Hash 보다 나은 방법으로 객체를 구현

- JAVA, C++ 같은 `클래스 기반 객체지향 언어`는 사전에 정의된
- ┣ 클래스를 기반으로 `객체(인스턴스)`를 생성하게 됨
- ┣ 객체를 생성하기 전에 이미 `프로퍼티`나 메서드가 정해져 있으며
- ┣ 그대로 객체를 생성함
- ┗ 객체가 생성된 이후에는 `프로퍼티`를 삭제하거나 추가 불가

- JS의 경우 `클래스 없이 객체를 생성` 가능
- ┣ 객체가 생성된 이후라도 `동적`으로
- ┣ 프로퍼티, 메서드 추가 가능
- ┣ 사용은 편리하지만 → 성능면으로는 클래스 기반보다
- ┗ 객체의 생성과 프로퍼티 접근에 비용이 더 많이 드는 `비효율적 방식`

- 그렇기에 V8 JS 엔진에서는 프로퍼티 접근을 위해서
- ┣ `동적 탐색(dynamic lookup)`대신
- ┣ `히든 클래스(hidden class)`라는 방식을 사용해서
- ┣ c++ 객체의 프로퍼티에 접근하는 정도의 `성능을 보장`
- ┣ 히든 클래스는 `자바`와 같이 `고정된 객체 레이아웃(class)`과
- ┗ `유사하게 동작`하게됨

### 11.2.1 변경 가능한 값

- 객체(참조) 타입의 값
- ┣ 객체는 변경 가능한 mutable value 임
- ┗ 변수에 객체를 할당하면 어떤 일이 일어나는지 확인

```js
var person = {
	name: 'jang',
};
```

- `원시 값`을 할당한 변수가 기억하는 `메모리 주소`를 통해
- ┣ `메모리 공간에 접근`하면 `원시 값에 접근`이 가능
- ┣ `원시 값을 할당한 변수` : `원시 값 자체`를 값으로 가짐
- ┣ 그러나 `객체를 할당한 변수`가 기억하는 `메모리 주소`를 통해
- ┣ `메모리 공간`에 접근하면 `참조 값(reference value)`에 접근 가능
- ┗ 참조 값 : 생성된 객체가 저장된 메모리 공간의 주소, 그 자체

- `원시 값을 할당한 변수`를 참조 :
- ┣ `메모리에 저장`되어 있는 `원시 값`에 접근
- ┣ 그러나 `객체를 할당한 뒤 변수`를 참조 :
- ┗ `메모리에 저장`되어 있는 `참조 값`을 통해 `실제 객체`에 접근

```js
//할당이 이뤄지는 시점에 객체 리터럴이 되고 그 결과 객체가 생성
var person = {
	name: 'Jang',
};
console.log(person);
```

- 일반적으로 `원시 값을 할당한 변수` :
- ┣ `변수는 O 값을 갖는다`, `변수의 값은 O `라고 함
- ┣ 하지만 `객체를 할당한 변수` :
- ┣ `변수는 객체를 참조`, `변수는 객체를 가리키고(point)`라고 표현
- ┗ 위의 예제에서 `person 변수`는 `객체 {name: 'Jang'}`을 `가리키고(참조)`하는 중

- `원시 값` : 변경 불가능한 값
- ┣ `원시 값`을 갖는 변수의 값을 변경하기 위해서는
- ┗ 재할당 외에는 방법이 없음

- 객체 : 변경 가능한 값
- ┣ 객체를 할당한 변수는 재할당 없이 객체를 `직접 변경 가능`
- ┣ 1. 재할당 없이 `프로퍼티`를 `동적 추가`
- ┣ 2. `프로퍼티` 값을 `갱신` 가능
- ┗ 3. `프로퍼티` 자체를 `삭제` 가능

```js
var person = {
	name: 'Jang',
};
// 갱신
person.name = 'Kim';
// 동적 추가
person.age = 23;
```

- `원시 값` : 변경 불가
- ┣ `원시 값`을 갖는 변수의 값을 변경
- ┗ 재할당을 통해 메모리에 `원시 값`을 새롭게 생성해야 함

- 객체의 : 변경가능
- ┣ 메모리에 저장된 객체 직접 수정가능
- ┗ 이때 객체를 할당한 변수에 재할당 x → 객체를 할당한 변수의 참조 값 변경 X

- 앞에서 보았듯 객체를 생성하고 관리하는 방식은 복잡하며
- ┣ 비용이 많이드는 일임...
- ┣ 객체를 변경할 때마다 이전 값을 복사해서 새롭게 생성한다면
- ┣ 명확하고 신뢰성이 확보 되겠지만
- ┣ 1. 객체의 `크기가 매우 클 수` 있고
- ┣ 2. 원시 값 처럼 `크기가 일정하지 않을 수` 있으며
- ┣ 3. `프로퍼티 값이 객체`일 경우도 존재 할 수 있어서
- ┣ `복사(deep copy)` 해서 생성하는 비용이 많이 들게됨
- ┗ 메모리의 효율적 소비가 어렵고 성능이 나빠짐

- 1. 메모리를 효율적으로 사용하기 위해서
- ┣ 2. 객체를 복사해 생성하는 비용을 절약하여 성능 향상 위해서
- ┣ `객체`는 `변경 가능한 값으로 설계`
- ┣ 메모리 사용의 효율성과 성능을 위해
- ┗ 어느 정도의 구조적인 단점을 감안한 설계

- 객체는 이러한 `구조적 단점에 부작용`이 존재
- ┣ 원시 값과 다르게 `여러개의 식별자`가
- ┗ `하나의 객체를 공유`할 수 있다는 점!!!

> 얕은 복사와 깊은 복사

    얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른객체
    ┣ 원본과 복사본은 참조 값이 다른 별개의 객체
    ┣ 얕은 복사 : 객체에 중첩되어 있는 경우
    ┗ 참조 값을 복사
    ┣ 깊은 복사 : 객체에 중첩된 객체 모두 복사
    ┗ 완전한 복사본을 만듬

> 원시 값을 할당한 변수를 다른 변수에 할당하는 것 : 깊은 복사
> 객체를 할당한 변수를 다른 변수에 할당하는 것 : 얕은 복사

### 11.2.2 참조에 의한 전달

- 여러 개의 식별자가 하나의 객체를 공유 할 수 있다는 것의 의미
- ┗ 그리고 그로 인해서 생기는 부작용에 대해서 학습

- 객체를 가리키는 변수(원본)를 다른 변수(사본)에 할당하면
- ┗ `원본의 참조 값이 복사되어 전달`

> 이를 참조에 의한 전달

- 원본 person을 사본 copy에 할당하면
- ┣ 원본의 참조 값을 복사해서 전달
- ┣ 이 때 원본과 사본은 `저장된 메모리 주소는 다르지만`
- ┣ `동일한 참조 값`을 가지게 됨
- ┣ → 둘 다 동일한 객체를 가르키게 됨
- ┗ 이를 `두 개의 식별자가 하나의 객체를 공유`한다고 함

- 원본 또는 사본 중 어느 한쪽에서 객체를 변경(프로퍼티 추가, 삭제)하면
- ┗ 서로에게 영향을 주고 받게 됨

- 결국 `값에 의한 전달`과 `참조에 의한 전달`은 식별자가 기억하는
- ┣ 메모리 공간에 저장되어 있는 `값을 복사해서 전달` 한다는 의미에서
- ┗ 동일하다고 생각할 수 있음
- ┣ 다만 식별자가 기억하는 메모리 공간
- ┣ 즉 : `변수에 저장되어 있는 값`이
- ┣ `1. 원시 값`, `2. 참조 값` 이냐는 차이가 존재
- ┗ JS에는 `참조에 의한 전달은 존재 X` → `값에 의한 전달만 존재`!!!

- JS의 이 같은 동작 방식을 설명하는 정확한 용어가 존재 X
- ┣ 전달되는 값의 종류가 1. 원시값 인지 2. 참조 값 인지
- ┣ 구별하는 용도로만 1. 값에 의한 전달
- ┣ 2. 참조에 의한 전달로만 구분하기로 함
- ┣ JS에는 포인터가 존재하지 X
- ┣ 그렇기에 다른 프로그래밍 용어에서의 참조에 의한 전달과
- ┗ 다르다는 것을 유념

> 예제

```js
var person1 = {
	name: 'Lee',
};

var person2 = {
	name: 'Lee',
};
console.log(person1 === person2); // false
console.log(person1.name === person2.name); // true
```

- `===` 일치 비교 연산자 : 변수에 저장되어 있는 값을
- ┗ 타입을 변환하지 않고 비교

- `객체를 할당한 변수` → `참조 값`을 가지고 있고
- ┗ `원시 값을 할당한 변수` → `원시 값 자체`를 가지고 있음

- 그렇기에 `객체를 할당` → `참조 값 비교`
- ┗ `원시 값 할당` → `원시 값 비교`

> 객체 리터럴은 평가 될 때 마다 객체를 생성

    내용은 같지만 다른 메모리에 저장된 별개의 객체

> 프로퍼티 값을 참조하는 person.name의 경우

    값으로 평가될 수 있는 표현식
    ┗ 두 표현식 모두 원시 값 'Lee'로 평가
