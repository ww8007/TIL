# 리덕스로 상태 관리하기

- `리덕스`는 Js를 위한 `상태 관리 프레임워크`
- 리액트를 사용하는 많은 프로젝트에서 사용됨

- 이유
  1. `컴포넌트 코드`로부터 `상태 관리 코드 분리` 가능
  2. `서버 렌더링` 시 `데이터 전달`이 편함
  3. `로컬 스토리지`에 `데이터 저장` 및 `불러오는` 코드를 `쉽게` 작성
  4. `같은 상태값`을 `다수의 컴포넌트`에서 불러오기 좋음
  5. `부모 컴포넌트`에서 `깊은 곳`에 있는 `자식 컴포넌트`에게 전달 좋음
  6. `알림창`과 같은 `전역 컴포넌트 상태값` 관리
  7. `페이지가 전환`되어도 `데이터는 살아` 있어야 할 때 좋음

## 리덕스 사용 시 따라야 할 세 가지 원칙

1. `전체 상태값`을 하나의 객체에 저장
2. 상태값은 불변 객체
3. 상태값은 순수 함수 함수에 의해서만 변경

### 하나의 객체에 프로그램 전체 상태값 저장

- `전체 상태값`이 `하나의 자바스크립트 객체`로 표현되기 때문에 활용도가 높아짐
- 리덕스를 사용하면 `하나의 객체`를 `직렬화(serialize)` 해서

  - -> 서버와 클라이언트가 `전체 상태값`을 주고 받을 수 있음

- 프로그램이 특정한 상태에 있을 때 발생하는 버그를 확인하기 위해 저장

  - -> `반복해서 재현` 가능
  - -> 상태값 버리지 않고 `저장`시
    - -> `실행 취소(undo)`
    - -> `다시 실행(redo)` 가능

- 그러나 상태값을 리덕스로 관리하는 것은 쉬운일이 아님
- `애니메이션`을 위한 데이터나 `문자열 입력`창의 상태값은 `컴포넌트에서 관리`하는게 좋을 수 있음
- `로직이 간단` -> 리덕스를 `사용하지 않는`게 좋을 수 있음

### 상태값을 불변객체로 관리

```js
const incrementAction = {
  type: 'INCREMENT', // -1-
  amount: 123, // -2-
};
const conditionalIncrementAction = {
  type: 'CONDITIONAL_INCREMENT', // -1-
  //-2-
  amount: 2,
  gt: 10,
  lt: 100,
  // -2-
};
store.dispatch(incrementAction); // -3-
store.dispatch(conditionalIncrementAction); // -3-
```

1. `액션 객체`는 `type 속성값`이 존재해야함
   - `type 속성값`으로 `액션 객체`를 구분
2. `type 속성값`을 제외한 나머지는 상태값을 수정하기 위해 사용하는 정보
3. `액션 객체`와 함께 `dispatch` 메서드를 호출하면 상태값이 변경

- 리덕스의 `상태값을 수정하는 유일한 방법` `액션 객체와 함께 dispatch 메서드를 호출`하는 것
- 다른 `어떤 방법`으로도 상태값을 `절대 수정하면 안됨`

- 상태값은 `dispatch 메서드가 호출된 순서`대로 `리덕스 내부`에서 변경

  - -> 우리가 `실행 순서를 보장` 받을 수 있고 `그 과정을 쉽게 이해`가능

- 또한 `액션 객체는 평범한 자바스크립트 객체`이기 때문에 `입력된 순서를 저장`해놓고

  - -> `그 과정을 쉽게 재현 가능`

- 상태값 수정이라는 하나의 목표를 보면 불변을 굳이 사용해야 하나? 의문점 가질 수 있음

  - -> 그러나 `이전 상태값과` `이후 상태값을 비교`해서 변경 여부 파악에서는 `불변 객체가 유리`

- 상태값 변경을 빠르게 확인할 수 있으면 `메모이제이션`과 같은 기능 활용 좋음
- `렌더링 속도` 올리는데 유리

### 오직 순수 함수에 의해서만 상태값을 변경해야 한다.

- 리덕스에서 `상태값을 변경하는 함수`를 `리듀서(reducer)`라고 부름
- `리듀서`의 구조

  ```js
  (state, action) => nextState;
  ```

- `리듀서`는 `이전 상태값`과 `액션 객체`를 `입력으로 받아`서 `새로운 상태값 생성`

  - -> 순수함수!!!

- `순수 함수`는 `부수 효과(side effect)`를 발생시키지 않아야 함
  - -> `부수효과` : 전역 변수 값 수정, API 요청 등의 `함수 외부의 상태를 변경`시키는 것
- `순수 함수`는 `같은 인수`에 대해서 `항상 같은 값을 반환`해야함
  - -> `반환값`을 계산할 때 `랜덤 함수`나 `시간 함수`를 이용하면 순수 함수가 아님
  - -> `리듀서` 내부에 setTimeout이나 시간, 랜덤 이용하지 않도록 함

```js
// 장동현님 안녕하세요. 지금은 10시 30분 입니다. // -1-
sayHello1('장동현');
sayHello2('장동현', '10:30');
```

1. 두 함수는 주석의 내용과 `같은 문자열을 반환`
2. sayHello1 함수는 내부적으로 시간 함수 호출하기 때문에 순수 함수가 아니다.
   - `같은 인수`를 입력해도 `호출 시점` 따라서 `다른 값 출력`되기 때문에

> 순수 함수의 또 다른 장점은 테스트 코드 작성이 쉬움

```js
// -1-
const now = new Date();
const hour = now.getHours();
const minute = now.getMinutes();
expect(sayHello('장동현')toBe(
    `장동현님 안녕하세요. 지금은 ${hour}시 ${minute}분입니다.`
))
// -1-
// -2-
expect(sayHello2('장동현')toBe(
    `장동현님 안녕하세요. 지금은 10시 30분입니다.`
))
// -2-
```

1. sayHello 함수는 내부적으로 현재 시각을 사용하기 때문에 테스트 코드에서도 현재 시간을 가져와야 함
   - 하지만 현재 시각을 가져오는 시점이 서로 다르므로 `간헐적으로 테스트 실패 가능성`
   - `일정 수준의 오차 허용` 가능 -> `번거로움`
2. `순수 함수` 작성 -> `고민 없이 테스트 코드` 작성 가능

- `리듀서는 순수 함수`이기 때문에 `상태값`과 `액션 객체를 입력`하면
  - -> `항상 같은 다음 상태값` 반환
  - -> `실행된 액션 객체 순서대로 저장`하고
  - -> 나중에 `똑같은 순서대로 dispatch` 실행하면 `쉽게` `리플레이(replay)` 가능

## 리덕스 주요 개념 이해

- 리덕스의 `상태값이 변경되는 과정`

| 액션 | ➡️  | 미들웨어 | ➡️  | 리듀서 | ➡️  | 스토어 |
| ---- | --- | -------- | --- | ------ | --- | ------ |
| ⬆️   |     | ⬅️       | 뷰  | ⬅️     |     | ⬇️     |

- 뷰는 리액트의 컴포넌트라고 생각할 수 있음
- 상태값을 변경하는 과정에서 거치게 되는 리덕스의 4가지 요소
  1. 액션
  2. 미들웨어
  3. 리듀서
  4. 스토어 학습

### 액션

- 액션(action)은 type 속성을 가진 자바스크립트 객체
- 액션 객체를 dispatch 메서드에 넣어서 호출하면
  - ➡️ 리덕스는 상태값을 변경하기 위해 위의 표 과정 실행
  - ➡️ 액션 객체는 type 속성 이외에 원하는 속성값 얼마든지 넣을 수 있음

#### 액션을 발생시키는 예제 코드

```js
store.dispatch({ type: 'ADD', title: '영화 보기', priority: 'hight' }); // -1-
store.dispatch({ type: 'REMOVE', id: 123 });
store.dispatch({ type: 'REMOVE_ALL' });
```

- 각 액션은 고유한 type 속성값을 사용 ➡️ Typescript type guard와 비슷한 역할
  - ➡️ 식별가능한 유니온 타입 이용

1. ADD 라는 단어 하나만으로 충돌을 피하기 위해서는 다음과 같이 접두사를 붙이는 방법 많이 사용

```js
store.dispatch({ type: 'todo/ADD', title: '영화 보기', priority: 'hight' }); // -1-
store.dispatch({ type: 'todo/REMOVE', id: 123 });
store.dispatch({ type: 'todo/REMOVE_ALL' });
```

- dispatch 메서드를 호출할 때 직접 `액션 객체`를 입력하는 방법은 사용하지 않는게 좋음
  - ➡️ 액션 객체 : type 속성값이 존재 해야함
- `todo/App` 액션의 경우 title, priority라는 두 속성값이 항상 존재하도록 강제
  - ➡️ 액션 생성자 함수를 이용해서 해결

##### 액션 생성자 함수의 예

function
