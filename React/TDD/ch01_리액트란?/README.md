# 1. 리액트란?

## 목차

- [1. 리액트란?](#1-%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%9E%80)
  - [1.1 자바스크립의 역사](#11-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%EC%9D%98-%EC%97%AD%EC%82%AC)
  - [1.2 리액트의 특징](#12-%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95)
    - [1.2.1 가상 돔](#121-%EA%B0%80%EC%83%81-%EB%8F%94)
    - [1.2.2 단방향 데이터 바인딩](#122-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B0%94%EC%9D%B8%EB%94%A9)
    - [1.2.3 JSX](#123-jsx)
    - [1.2.4 선언형 프로그래밍](#124-%EC%84%A0%EC%96%B8%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
    - [1.2.5 컴포넌트 기반](#125-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B8%B0%EB%B0%98)

## 1.1 자바스크립의 역사

- React : `JS 언어를 기반`으로 동작하는 라이브러리
- ┣ 고로 JS에 대한 이해가 필요함
- ┣ JS 역사 : 넷스케이프 커뮤니케이션즈
- ┣ 1. JS를 만들었고
- ┗ 2. JS에 큰 영향을 미쳤음

- 95년 넷스케이프 커뮤니케이션즈 :
- ┣ `정적인 HTML`을 `동적으`로 표현하기 위한
- ┣ 경량 프로그래밍 언어를 도입하기로 하고
- ┣ 새로운 프로그래밍 언어 개발에 착수
- ┗ 이 때 탄생 : JS 언어

- `JS의 기반이 되는 언어인 Mocha`
- ┣ JS는 많은 언어로부터 영감
- ┣ `클로져(Closure) : 리스프(Lisp)`
- ┣ `프로토타입 상속 : 스몰토크에서 파생된`
- ┣ 셀프(Self) 프로그래밍 언어
- ┣ 넷스케이프 커뮤니케이션즈

## 1.2 리액트의 특징

- `가상 돔`과 같은 새로운 개념과
- ┣ 다른 JS 프레임워크와는 다르게
- ┣ `단반향 데이터 바인딩` 사용
- ┗ 리액트 만의 독자적인 특징

### 1.2.1 가상 돔

- 리액트 : `가상 돔`이라는 개념으로
- ┣ `웹 퍼포먼스 향상에 새로운 접근 방식`
- ┗ 이를 통해 웹 애플리케이션 `성능 극대화`

- 브라우저 :
- ┣ 1. `네트워크를 통해 HTML을 전달`받으면
- ┣ 2. `브라우저의 렌더 엔진` :
- ┣ `HTML을 파싱` → 3. `돔 노드(DOM Node)`로 이루어진
- ┣ `트리`를 만들어내게 됨
- ┣ 4. 또한 `CSS 파일`과 각 `엘리먼트의 인라인 스타일` 파싱
- ┗ 5. 스타일 정보를 가진 `새로운 스타일 렌더 트리 생성`

- 이렇게 렌더 트리가 생성되면
- ┣ 브라우저 : `Attachment 라는 과정`을 통해
- ┣ `스타일 정보를 계산`하게 됨
- ┣ `렌더 트리의 모든 노드` : `attach 메서드`를 가짐
- ┣ `Attachment 과정에서 이 메서드가 호출`되게 됨
- ┣ `해당 메소드 : 스타일 정보를 계산`하고
- ┣ `결과값을 객체 형태로 변환함`
- ┣ 이 과정은 동기적으로 작동하며
- ┣ 만약 `렌더 트리에 새로운 노드가 추가`되면
- ┗ `해당 노드의 attach 메소드가 실행됨`

- 렌더 트리 : Attachment 과정을 거친 후
- ┣ `레이아웃이라는 과정을 거치게 됨`
- ┣ 레이아웃 과정에서는
- ┣ 브라우저가 `렌더 트리의 각 노드에 좌표를 부여`하고
- ┗ 어디에 어떻게 표시해야할지 결정하게 됨

- 마지막으로 브라우저 :
- ┣ `노드에 paint() 메서드`를 호출하여
- ┣ 렌더링된 요소들에 색상을 입히는
- ┣ `Painting 이라는 과정을 거친 후 최종적으로`
- ┗ 화면을 표시하게 됨

> 레이아웃 작업이 반복 : 리플로우(Reflow)

    성능 이슈가 발생됨

> 페인팅 작업 반복 : 리페인트

- 리액트 :
- ┣ 리플로우와 리페인트의 문제를 해결하기 위해
- ┣ `화면에 표시되는 돔`과 `동일한 돔`을 `메모리상`에
- ┣ `생성`을 하고, `돔 조작이 발생`되면
- ┣ `메모리상에 생성한 가상 돔에서 모든 연산을 한 후`
- ┗ `실제 돔을 갱신`하여 `리플로우와 리페인트 연산 최소화`

- 예시 :
- ┣ 사용자 로그인
- ┣ 1. 사용자 프로필 화면에 표시
- ┣ 2. 기존 컨텐츠 삭제
- ┣ 3. 해당 사용자 추천 컨텐츠 표시
- ┣ 4. 친구 리스트
- ┣ 4번의 동작을 하지만
- ┗ `리액트는 이를 한번에 실행`

### 1.2.2 단방향 데이터 바인딩

- 싱글 페이지 어플리케이션의 대표적인
- ┣ 앵귤러, 뷰(Vue) : 양방향 데이터 바인딩
- ┣ 양방향 데이터 바인딩 :
- ┣ 1. `사용자 UI의 데이터 변경`을 감사히는 Watcher,
- ┣ 2. `JS에서 변경되는 데이터`를 감시하는 Watcher를
- ┣ 통해 `UI와 프로그램 안에 데이터를 자동으로`
- ┣ `동기화해 주는 시스템`임
- ┣ 이를 통해 프로그래머는 JS 내에 데이터 변경과
- ┣ `사용자 UI에서 데이터 변경 및 동기화를 크게`
- ┣ 신경쓰지 않고 프로그램을 작성이 가능함

- 장점도 았지만 단점도 존재
- ┣ 1. `데이터 동기화 위해 두 개의 Watcher`
- ┣ `오버스펙`일 경우가 발생
- ┣ 2. 수많은 Watcher에 의해
- ┗ `반대로 성능 저하가 발생 가능`

> 이를 피하기 위해 React : 단반향 데이터 바인딩 채택

- 단방향 데이터 바인딩 :
- ┣ `단 하나의 Watcher가 JS 데이터 갱신을 감지`하여
- ┣ `사용자의 UI 데이터를 갱신`함
- ┣ 사용자가 UI를 통해 데이터를 갱신할 때는
- ┣ `양방향 데이터 바인딩과 다르게`
- ┣ Watcher가 아닌 Event를 통해 데이터를 갱신하게 됨
- ┣ 이처럼 하나의 Watcher를 사용하기 때문에
- ┣ 1. `양방향 데이터에 바인딩에서 발생하는 문제를 없애고`
- ┗ 2. `더 확실하게 데이터 추적이 가능함`

> 또한 Flux라는 개념을 도입하여

    데이터의 흐름이 한쪽으로 진행되게
    설정해뒀음

### 1.2.3 JSX

- 리액트 : `JSX라는 독특한 문법`을 가지고 있음
- ┣ `JSX : JS와 HTML을 동시에 사용`
- ┣ HTML에 JS 변수들을 바로 사용할 수 있는
- ┣ 일종의 `템플릿 언어(Template language)`

```js
const App = () => {
	const hello = `Hello World!`;
	return <div>{hello}</div>;
};
```

### 1.2.4 선언형 프로그래밍

- 프로그래밍 :
- ┣ 1. `선언형 프로그래밍`
- ┣ 2. `명령형 프로그래밍`
- ┣ 으로 구별할 수 있음

- `명령형 프로그래밍` :
- ┣ 프로그래밍 할 때
- ┣ `어떻게(How)`에 집중하여 프로그래밍
- ┣ 택시틀 타고 집
- ┣ 첫 번째 사거리 우회전 삼거리 나올 때까지 직진
- ┣ 우리 집
- ┣ 이런 것이 명령형 프로그래밍

- 선언형 프로그래밍 ;
- ┣ 명령형 프로그래밍과 다르게
- ┣ `무엇(What)`에 집중함
- ┣ 택시를 타고 집
- ┣ 우리 집은 XXX 번지 입니다
- ┣ 이게 끝임

```js
// 명령형
const double = (arr) => {
	let result = [];
	for (const a of arr) {
		result.push(a * 2);
	}
	return result;
};

// 선언형
const double = (arr) => {
	return arr.map((elem) => elem * 2);
};
```

- 두 함수 : 같은 동작을 하는 JS 함수

> 명령형

    과정 중심의 프로그래밍

> 선언형

    결과값이 무엇인지에 집중

- 리액트에서는 특히 JSX를 사용해서
- ┣ 더욱 명확하게 선언형 프로그래밍

> 명령형

```js
const arr = [1, 2, 3, 4, 5];
const elem = document.querySelector('#list');

for (let i = 0; i < arr.length; i++) {
	const child = document.createElement('li');
	child.innerHTML = arr[i];
	elem.appendChild(child);
}
```

> 선언형

```js
const arr = [1, 2, 3, 4, 5];
return (
    <ul>
        {arr.map((elem)=> (
            <li>{elem}</li>
        )}
        )}
    </ul>
)
```

### 1.2.5 컴포넌트 기반

- 리액트 : 작고 고립된 코드들을 이용하여 구현

```js
const Title = () => {
	return <h1>Hello world</h1>;
};

const Button = () => {
	return <button>This is a Button</button>;
};
```
